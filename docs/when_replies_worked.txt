frontend/src/components/chat/ReplyModal/index.tsx
```
import React, { useState } from 'react';
import styled from 'styled-components';
import { StoreMessage } from '../../../types';

interface ReplyModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSubmit: (content: string) => void;
  parentMessage: StoreMessage;
}

const ModalOverlay = styled.div<{ isOpen: boolean }>`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.5);
  display: ${props => props.isOpen ? 'flex' : 'none'};
  justify-content: center;
  align-items: center;
  z-index: 1000;
`;

const ModalContent = styled.div`
  background-color: ${props => props.theme.colors.background};
  border: 2px solid ${props => props.theme.colors.border};
  padding: 16px;
  width: 90%;
  max-width: 500px;
  font-family: 'Courier New', monospace;
`;

const Title = styled.h2`
  color: ${props => props.theme.colors.primary};
  margin: 0 0 16px 0;
  font-size: 1.2em;
`;

const ParentMessage = styled.div`
  color: ${props => props.theme.colors.secondary};
  background-color: ${props => props.theme.colors.hover};
  padding: 8px;
  margin-bottom: 16px;
  border-left: 2px solid ${props => props.theme.colors.border};
`;

const TextArea = styled.textarea`
  width: 100%;
  min-height: 100px;
  padding: 8px;
  margin-bottom: 16px;
  background-color: ${props => props.theme.colors.background};
  color: ${props => props.theme.colors.text};
  border: 1px solid ${props => props.theme.colors.border};
  font-family: 'Courier New', monospace;
  resize: vertical;

  &:focus {
    outline: none;
    border-color: ${props => props.theme.colors.primary};
  }
`;

const ButtonContainer = styled.div`
  display: flex;
  justify-content: flex-end;
  gap: 8px;
`;

const Button = styled.button<{ primary?: boolean }>`
  background-color: ${props => props.primary ? props.theme.colors.primary : 'transparent'};
  color: ${props => props.primary ? props.theme.colors.background : props.theme.colors.text};
  border: 1px solid ${props => props.theme.colors.border};
  padding: 8px 16px;
  cursor: pointer;
  font-family: 'Courier New', monospace;

  &:hover {
    background-color: ${props => props.primary ? props.theme.colors.primaryHover : props.theme.colors.hover};
  }
`;

const ReplyModal: React.FC<ReplyModalProps> = ({
  isOpen,
  onClose,
  onSubmit,
  parentMessage
}) => {
  const [content, setContent] = useState('');

  const handleSubmit = () => {
    if (content.trim()) {
      onSubmit(content.trim());
      setContent('');
      onClose();
    }
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && e.ctrlKey) {
      handleSubmit();
    } else if (e.key === 'Escape') {
      onClose();
    }
  };

  return (
    <ModalOverlay isOpen={isOpen} onClick={onClose}>
      <ModalContent onClick={e => e.stopPropagation()}>
        <Title>Reply to Message</Title>
        <ParentMessage>
          {parentMessage.content}
        </ParentMessage>
        <TextArea
          value={content}
          onChange={e => setContent(e.target.value)}
          onKeyDown={handleKeyDown}
          placeholder="Type your reply here... (Ctrl+Enter to send)"
          autoFocus
        />
        <ButtonContainer>
          <Button onClick={onClose}>Cancel</Button>
          <Button primary onClick={handleSubmit}>Reply</Button>
        </ButtonContainer>
      </ModalContent>
    </ModalOverlay>
  );
};

export default ReplyModal; 
```

frontend/src/components/chat/MessageReplies/index.tsx
```
import React, { useEffect } from 'react';
import styled from 'styled-components';
import { useSelector, useDispatch } from 'react-redux';
import { StoreMessage, RootState } from '../../../types';
import { transformMessage } from '../../../utils/messageTransform';
import Message from '../Message';
import { setReplies } from '../../../store/messages/messagesSlice';
import { getReplies } from '../../../services/api/chat';

interface MessageRepliesProps {
  parentId: string;
  replies: StoreMessage[];
  isExpanded: boolean;
  onToggleReplies: (messageId: string) => void;
  onDelete: (messageId: string) => void;
  currentUserId?: string;
}

const RepliesContainer = styled.div<{ isExpanded: boolean }>`
  display: ${props => props.isExpanded ? 'block' : 'none'};
  margin-left: 24px;
  position: relative;
  border-left: 2px solid ${props => props.theme.colors.border};
  margin-top: 2px;
  margin-bottom: 2px;
  padding-left: 8px;

  &:before {
    content: '';
    position: absolute;
    left: -2px;
    top: 0;
    width: 8px;
    height: 2px;
    background-color: ${props => props.theme.colors.border};
  }
`;

const ReplyWrapper = styled.div`
  position: relative;
  padding: 2px 0;
  background-color: ${props => props.theme.colors.backgroundDark};

  &:hover {
    background-color: ${props => props.theme.colors.hover};
  }

  &:last-child {
    &:after {
      content: '';
      position: absolute;
      left: -10px;
      bottom: 50%;
      width: 8px;
      height: 2px;
      background-color: ${props => props.theme.colors.border};
    }
  }
`;

const MessageReplies: React.FC<MessageRepliesProps> = ({
  parentId,
  replies,
  isExpanded,
  onToggleReplies,
  onDelete,
  currentUserId,
}) => {
  const dispatch = useDispatch();
  const users = useSelector((state: RootState) => state.chat?.users || {});
  const activeChannelId = useSelector((state: RootState) => state.chat.activeChannelId);

  // Load replies when expanded
  useEffect(() => {
    const loadReplies = async () => {
      if (!isExpanded || !activeChannelId || !parentId) return;

      try {
        const fetchedReplies = await getReplies(parentId);
        const transformedReplies = fetchedReplies.map(reply => transformMessage(reply));

        dispatch(setReplies({
          channelId: activeChannelId,
          messageId: parentId,
          replies: transformedReplies
        }));
      } catch (error) {
        console.error('Error loading replies:', error);
      }
    };

    loadReplies();
  }, [isExpanded, activeChannelId, parentId, dispatch]);

  // Sort replies by creation time
  const sortedReplies = [...replies].sort((a, b) => {
    const timeA = new Date(a.createdAt).getTime();
    const timeB = new Date(b.createdAt).getTime();
    return timeA - timeB;
  });

  return (
    <RepliesContainer isExpanded={isExpanded}>
      {sortedReplies.map((reply) => (
        <ReplyWrapper key={reply.id}>
          <Message
            content={reply.content}
            sender={users[reply.userId]?.username || reply.userId}
            timestamp={reply.createdAt}
            userId={reply.userId}
            currentUserId={currentUserId}
            onDelete={() => onDelete(reply.id)}
            replyCount={0}
            isExpanded={false}
            onToggleReplies={() => {}}
            onReply={() => {}}
            isReply
          />
        </ReplyWrapper>
      ))}
    </RepliesContainer>
  );
};

export default MessageReplies; 
```
frontend/src/components/chat/MessageList/index.tsx
```
import React, { useEffect, useRef, forwardRef, useState, useCallback } from 'react';
import styled from 'styled-components';
import { useSelector, useDispatch } from 'react-redux';
import { RootState, StoreMessage, User } from '../../../types';
import Message, { ChatMessageProps } from '../Message';
import MessageReplies from '../MessageReplies';
import { getChannelMessages } from '../../../services/api/chat';
import { prependMessages } from '../../../store/messages/messagesSlice';
import { transformMessage } from '../../../utils/messageTransform';

interface MessageListProps {
  messages: StoreMessage[];
  selectedMessageId?: string | null;
  initialScrollComplete?: boolean;
  channelId?: string | null;
}

const MessageListContainer = styled.div`
  flex: 1;
  overflow-y: auto;
  padding: 16px;
  display: flex;
  flex-direction: column;
  height: 100%;
`;

const MessagesWrapper = styled.div`
  display: flex;
  flex-direction: column;
  gap: 8px;
  margin-top: auto;
  min-height: min-content;
`;

const LoadingIndicator = styled.div`
  text-align: center;
  padding: 8px;
  color: ${props => props.theme.colors.textLight};
  font-family: 'Courier New', monospace;
`;

const MessageWrapper = styled.div<{ $isSelected?: boolean }>`
  transition: all 0.3s ease;
  padding: 4px;
  border-radius: 4px;
  background-color: ${props => props.$isSelected ? '#3a3a3a' : 'transparent'};
  border-left: ${props => props.$isSelected ? '2px solid #666' : '2px solid transparent'};
  
  &.highlight {
    animation: flash 1s;
  }

  @keyframes flash {
    0% { background-color: #4a4a4a; }
    100% { background-color: ${props => props.$isSelected ? '#3a3a3a' : 'transparent'}; }
  }
`;

const MessageList = forwardRef<HTMLDivElement, MessageListProps>((props, ref) => {
  const { messages, selectedMessageId, initialScrollComplete: propInitialScrollComplete, channelId } = props;
  const containerRef = useRef<HTMLDivElement>(null);
  const highlightTimeoutRef = useRef<NodeJS.Timeout>();
  const scrollTimeoutRef = useRef<NodeJS.Timeout>();
  const prevSelectedMessageRef = useRef<string | null | undefined>(null);
  const lastMessageRef = useRef<string | null>(messages[messages.length - 1]?.id || null);
  const [shouldScrollToMessage, setShouldScrollToMessage] = useState(false);
  const [initialScrollComplete, setInitialScrollComplete] = useState(!!propInitialScrollComplete);
  const prevMessagesRef = useRef(messages);
  const isUserScrolling = useRef(false);
  const currentChannelRef = useRef<string | null>(messages[0]?.channelId || null);
  const isInitialRender = useRef(true);
  const [isLoadingMore, setIsLoadingMore] = useState(false);
  const dispatch = useDispatch();

  const { currentUser, users } = useSelector((state: RootState) => ({
    currentUser: state.auth.user,
    users: state.chat.users as { [key: string]: User }
  }));

  // Cleanup effect
  useEffect(() => {
    return () => {
      if (highlightTimeoutRef.current) {
        clearTimeout(highlightTimeoutRef.current);
      }
      if (scrollTimeoutRef.current) {
        clearTimeout(scrollTimeoutRef.current);
      }
    };
  }, []);

  // Initial render and channel change handler
  useEffect(() => {
    if (!containerRef.current) return;

    const newChannelId = messages[0]?.channelId;
    const channelChanged = newChannelId !== currentChannelRef.current;
    
    if ((isInitialRender.current || channelChanged) && messages.length > 0) {
      // Reset all scroll-related state
      setInitialScrollComplete(false);
      prevSelectedMessageRef.current = null;
      lastMessageRef.current = messages[messages.length - 1]?.id;
      isUserScrolling.current = false;
      currentChannelRef.current = newChannelId;

      // Use RAF to ensure DOM is updated before scrolling
      requestAnimationFrame(() => {
        if (containerRef.current) {
          containerRef.current.scrollTop = containerRef.current.scrollHeight;
          // Double-check scroll position after a brief delay
          setTimeout(() => {
            if (containerRef.current) {
              containerRef.current.scrollTop = containerRef.current.scrollHeight;
            }
          }, 50);
        }
      });
      setInitialScrollComplete(true);
    }

    isInitialRender.current = false;
  }, [messages[0]?.channelId]);

  // Add function to load older messages
  const loadOlderMessages = useCallback(async () => {
    if (!channelId || channelId === null || isLoadingMore) return;

    try {
      setIsLoadingMore(true);
      const container = containerRef.current;
      if (!container) return;

      // Store the scroll height and a reference element before loading
      const oldScrollHeight = container.scrollHeight;
      const oldFirstMessage = container.querySelector('[data-message-id]');
      const oldFirstMessageTop = oldFirstMessage?.getBoundingClientRect().top;

      const olderMessages = await getChannelMessages(
        channelId,
        50, // limit
        messages.length // skip
      );

      if (olderMessages.length > 0) {
        const transformedMessages = olderMessages.map(transformMessage);
        dispatch(prependMessages({
          channelId,
          messages: transformedMessages
        }));

        // After React has updated the DOM, adjust scroll position
        requestAnimationFrame(() => {
          if (!container) return;
          
          // Calculate new scroll position
          const newScrollHeight = container.scrollHeight;
          const heightDifference = newScrollHeight - oldScrollHeight;
          
          // Adjust scroll position to maintain the same relative position
          container.scrollTop = heightDifference;

          // Fine-tune adjustment if we have a reference element
          if (oldFirstMessage && oldFirstMessageTop) {
            const newFirstMessageTop = oldFirstMessage.getBoundingClientRect().top;
            const topDifference = newFirstMessageTop - oldFirstMessageTop;
            container.scrollTop += topDifference;
          }
        });
      }
    } catch (error) {
      console.error('Error loading older messages:', error);
    } finally {
      setIsLoadingMore(false);
    }
  }, [channelId, messages, dispatch, isLoadingMore]);

  // Handle scroll behavior
  useEffect(() => {
    if (!containerRef.current) return;

    const container = containerRef.current;
    let scrollTimeout: NodeJS.Timeout;

    const handleScroll = () => {
      isUserScrolling.current = true;
      clearTimeout(scrollTimeout);

      // Check if we're at the top
      if (container.scrollTop === 0 && !isLoadingMore) {
        loadOlderMessages();
      }

      scrollTimeout = setTimeout(() => {
        isUserScrolling.current = false;
      }, 150);
    };

    container.addEventListener('scroll', handleScroll);
    return () => {
      container.removeEventListener('scroll', handleScroll);
      clearTimeout(scrollTimeout);
    };
  }, [loadOlderMessages, isLoadingMore]);

  // Add effect to handle messages loading
  useEffect(() => {
    if (containerRef.current && messages.length > 0) {
      containerRef.current.scrollTop = containerRef.current.scrollHeight;
    }
  }, [messages.length]);

  // Handle user scrolling
  useEffect(() => {
    if (!containerRef.current) return;

    const container = containerRef.current;
    let scrollTimeout: NodeJS.Timeout;

    const handleScroll = () => {
      isUserScrolling.current = true;
      clearTimeout(scrollTimeout);
      scrollTimeout = setTimeout(() => {
        isUserScrolling.current = false;
      }, 150); // Reset after scrolling stops
    };

    container.addEventListener('scroll', handleScroll);
    return () => {
      container.removeEventListener('scroll', handleScroll);
      clearTimeout(scrollTimeout);
    };
  }, []);

  // Handle scroll behavior
  useEffect(() => {
    if (!containerRef.current || isInitialRender.current) return;

    const container = containerRef.current;
    const isAtBottom = container.scrollHeight - container.scrollTop <= container.clientHeight + 50;
    const hasNewMessages = messages[messages.length - 1]?.id !== lastMessageRef.current;
    const isNewMessage = hasNewMessages && messages.length > prevMessagesRef.current.length;
    const isOwnMessage = isNewMessage && messages[messages.length - 1]?.userId === currentUser?.id;

    // Always scroll to selected message when it changes
    if (selectedMessageId && selectedMessageId !== prevSelectedMessageRef.current) {
      const messageElement = container.querySelector(
        `[data-message-id="${selectedMessageId}"]`
      ) as HTMLElement;
      
      if (messageElement) {
        messageElement.scrollIntoView({
          behavior: 'smooth',
          block: 'center'
        });

        // Add highlight effect
        messageElement.classList.add('highlight');
        
        if (highlightTimeoutRef.current) {
          clearTimeout(highlightTimeoutRef.current);
        }
        
        highlightTimeoutRef.current = setTimeout(() => {
          messageElement.classList.remove('highlight');
        }, 1000);
      }
    } 
    // Immediately scroll to bottom for own messages or when already at bottom
    else if (isOwnMessage || (isNewMessage && isAtBottom)) {
      container.scrollTop = container.scrollHeight;
    }

    prevSelectedMessageRef.current = selectedMessageId;
    lastMessageRef.current = messages[messages.length - 1]?.id;
    prevMessagesRef.current = messages;
  }, [selectedMessageId, messages, currentUser?.id]);

  const handleDeleteMessage = (messageId: string) => {
    console.log('Delete message:', messageId);
  };

  const handleToggleReplies = (messageId: string) => {
    console.log('Toggle replies:', messageId);
  };

  const handleReply = (messageId: string) => {
    console.log('Reply to message:', messageId);
  };

  return (
    <MessageListContainer ref={containerRef}>
      <MessagesWrapper>
        {isLoadingMore && (
          <LoadingIndicator>Loading older messages...</LoadingIndicator>
        )}
        {[...messages].sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()).map(message => (
          <MessageWrapper
            key={message.id}
            $isSelected={message.id === selectedMessageId}
            data-message-id={message.id}
          >
            <Message
              content={message.content}
              sender={users[message.userId]?.username || message.userId}
              timestamp={message.createdAt}
              userId={message.userId}
              currentUserId={currentUser?.id}
              onDelete={() => handleDeleteMessage(message.id)}
              replyCount={message.replyCount || 0}
              isExpanded={message.isExpanded || false}
              onToggleReplies={() => handleToggleReplies(message.id)}
              onReply={() => handleReply(message.id)}
              isReply={false}
            />
            {message.isExpanded && message.replies && (
              <MessageReplies
                parentId={message.id}
                replies={message.replies}
                currentUserId={currentUser?.id}
                isExpanded={message.isExpanded}
                onToggleReplies={() => handleToggleReplies(message.id)}
                onDelete={handleDeleteMessage}
              />
            )}
          </MessageWrapper>
        ))}
      </MessagesWrapper>
    </MessageListContainer>
  );
});

MessageList.displayName = 'MessageList';

export default MessageList; 
```

frontend/src/store/messages/messagesSlice.ts
```
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { MessagesState, Reaction, StoreMessage } from '../../types';

const initialState: MessagesState = {
  messagesByChannel: {},
  loading: false,
  error: null,
};

const messagesSlice = createSlice({
  name: 'messages',
  initialState,
  reducers: {
    setMessages: (state, action: PayloadAction<{ channelId: string; messages: StoreMessage[] }>) => {
      const { channelId, messages } = action.payload;
      
      // Organize messages by parent/reply relationship
      const mainMessages: StoreMessage[] = [];
      const repliesByParentId: { [key: string]: StoreMessage[] } = {};

      // First pass: separate messages into main messages and replies
      messages.forEach(msg => {
        if (msg.parentId) {
          // This is a reply
          if (!repliesByParentId[msg.parentId]) {
            repliesByParentId[msg.parentId] = [];
          }
          repliesByParentId[msg.parentId].push(msg);
        } else {
          // This is a main message
          mainMessages.push(msg);
        }
      });

      // Second pass: attach replies to their parent messages
      mainMessages.forEach(msg => {
        if (repliesByParentId[msg.id]) {
          msg.replies = repliesByParentId[msg.id];
          msg.replyCount = repliesByParentId[msg.id].length;
          msg.repliesLoaded = true;
        }
      });

      // Update the state with organized messages
      state.messagesByChannel[channelId] = mainMessages;
      state.loading = false;
      state.error = null;
    },
    prependMessages: (state, action: PayloadAction<{ channelId: string; messages: StoreMessage[] }>) => {
      const { channelId, messages } = action.payload;
      if (!state.messagesByChannel[channelId]) {
        state.messagesByChannel[channelId] = [];
      }
      // Add messages to the beginning of the array, avoiding duplicates
      const existingIds = new Set(state.messagesByChannel[channelId].map(msg => msg.id));
      const newMessages = messages.filter(msg => !existingIds.has(msg.id));
      state.messagesByChannel[channelId] = [...newMessages, ...state.messagesByChannel[channelId]];
    },
    addMessage: (state, action: PayloadAction<{ channelId: string; message: StoreMessage }>) => {
      const { channelId, message } = action.payload;
      
      // Initialize channel messages array if it doesn't exist
      if (!state.messagesByChannel[channelId]) {
        state.messagesByChannel[channelId] = [];
      }

      // Check if message already exists
      const existingMessageIndex = state.messagesByChannel[channelId].findIndex(
        msg => msg.id === message.id
      );

      if (existingMessageIndex === -1) {
        // Add new message if it doesn't exist
        const newMessage = {
          ...message,
          replies: [],
          repliesLoaded: false,
          isExpanded: false,
          replyCount: message.replyCount || 0
        };
        
        state.messagesByChannel[channelId].push(newMessage);
        
        // Sort messages by creation time
        state.messagesByChannel[channelId].sort((a, b) => {
          const timeA = new Date(a.createdAt).getTime();
          const timeB = new Date(b.createdAt).getTime();
          return timeA - timeB;
        });

        // Update parent message if this is a reply
        if (message.parentId) {
          const parentMessage = state.messagesByChannel[channelId].find(
            msg => msg.id === message.parentId
          );
          if (parentMessage) {
            parentMessage.replyCount = (parentMessage.replyCount || 0) + 1;
            if (!parentMessage.replies) {
              parentMessage.replies = [];
            }
            parentMessage.replies.push(newMessage);
            // Sort replies by creation time
            parentMessage.replies.sort((a, b) => {
              const timeA = new Date(a.createdAt).getTime();
              const timeB = new Date(b.createdAt).getTime();
              return timeA - timeB;
            });
          }
        }
      } else {
        // Update existing message while preserving its state
        const existingMessage = state.messagesByChannel[channelId][existingMessageIndex];
        state.messagesByChannel[channelId][existingMessageIndex] = {
          ...message,
          replies: existingMessage.replies || [],
          repliesLoaded: existingMessage.repliesLoaded || false,
          isExpanded: existingMessage.isExpanded || false,
          replyCount: existingMessage.replyCount || 0
        };
      }
    },
    updateMessage: (state, action: PayloadAction<{ channelId: string; id: string; message: StoreMessage }>) => {
      const { channelId, id, message } = action.payload;
      const messages = state.messagesByChannel[channelId];
      if (!messages) return;

      // First check if it's a main message
      const index = messages.findIndex((msg: StoreMessage) => msg.id === id);
      if (index !== -1) {
        // Preserve existing state when updating
        const existingMessage = messages[index];
        messages[index] = {
          ...message,
          replies: existingMessage.replies || [],
          repliesLoaded: existingMessage.repliesLoaded || false,
          isExpanded: existingMessage.isExpanded || false,
          replyCount: existingMessage.replyCount || 0
        };
      } else {
        // Check if it's a reply to any message
        for (const mainMessage of messages) {
          if (mainMessage.replies) {
            const replyIndex = mainMessage.replies.findIndex(reply => reply.id === id);
            if (replyIndex !== -1) {
              // Preserve parent ID and other state when updating reply
              const existingReply = mainMessage.replies[replyIndex];
              mainMessage.replies[replyIndex] = {
                ...message,
                parentId: mainMessage.id,
                replies: existingReply.replies || [],
                repliesLoaded: existingReply.repliesLoaded || false,
                isExpanded: existingReply.isExpanded || false,
                replyCount: existingReply.replyCount || 0
              };
              break;
            }
          }
        }
      }
    },
    deleteMessage: (state, action: PayloadAction<{ channelId: string; messageId: string }>) => {
      const { channelId, messageId } = action.payload;
      const messages = state.messagesByChannel[channelId];
      if (messages) {
        state.messagesByChannel[channelId] = messages.filter((msg: StoreMessage) => msg.id !== messageId);
      }
    },
    addReaction: (state, action: PayloadAction<{ channelId: string; messageId: string; reaction: Reaction }>) => {
      const { channelId, messageId, reaction } = action.payload;
      const messages = state.messagesByChannel[channelId];
      if (messages) {
        const message = messages.find((msg: StoreMessage) => msg.id === messageId);
        if (message) {
          // Check if reaction already exists
          const existingReactionIndex = message.reactions.findIndex(
            (r: Reaction) => r.id === reaction.id || (r.emoji === reaction.emoji && r.userId === reaction.userId)
          );
          if (existingReactionIndex === -1) {
            message.reactions.push(reaction);
          }
        }
      }
    },
    removeReaction: (state, action: PayloadAction<{ channelId: string; messageId: string; reactionId: string }>) => {
      const { channelId, messageId, reactionId } = action.payload;
      const messages = state.messagesByChannel[channelId];
      if (messages) {
        const message = messages.find((msg: StoreMessage) => msg.id === messageId);
        if (message) {
          message.reactions = message.reactions.filter((reaction: Reaction) => reaction.id !== reactionId);
        }
      }
    },
    setReplies: (state, action: PayloadAction<{ channelId: string; messageId: string; replies: StoreMessage[] }>) => {
      const { channelId, messageId, replies } = action.payload;
      const messages = state.messagesByChannel[channelId];
      if (messages) {
        const messageIndex = messages.findIndex((msg: StoreMessage) => msg.id === messageId);
        if (messageIndex !== -1) {
          // Create a new message object with the updated replies
          const updatedMessage = {
            ...messages[messageIndex],
            replies: [
              ...(messages[messageIndex].replies || []),
              ...replies.filter(reply => 
                !messages[messageIndex].replies?.some(existingReply => 
                  existingReply.id === reply.id
                )
              )
            ],
            repliesLoaded: true,
            isExpanded: true // Auto-expand when new replies are added
          };
          
          // Update reply count
          updatedMessage.replyCount = updatedMessage.replies.length;
          
          // Update the message in the array
          messages[messageIndex] = updatedMessage;
        }
      }
    },
    toggleExpanded: (state, action: PayloadAction<{ channelId: string; messageId: string }>) => {
      const { channelId, messageId } = action.payload;
      const messages = state.messagesByChannel[channelId];
      if (messages) {
        const message = messages.find((msg: StoreMessage) => msg.id === messageId);
        if (message) {
          message.isExpanded = !message.isExpanded;
        }
      }
    },
  },
});

export const {
  setMessages,
  prependMessages,
  addMessage,
  updateMessage,
  deleteMessage,
  addReaction,
  removeReaction,
  setReplies,
  toggleExpanded
} = messagesSlice.actions;

export default messagesSlice.reducer; 
```