{"ast":null,"code":"import { getAuthToken } from '../api/auth';\n\n// Add WebSocket message types\n\nclass WebSocketService {\n  constructor() {\n    this.socket = null;\n    this.messageHandlers = [];\n    this.errorHandlers = [];\n    this.currentChannelId = null;\n    this.joinedChannels = new Set();\n    this.messageQueue = [];\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectTimeout = null;\n    this.isReconnecting = false;\n    this.connectionPromise = null;\n    this.joinPromise = null;\n    this.lastMessageId = null;\n    this.processingQueue = false;\n    this.heartbeatInterval = null;\n    this.lastHeartbeatResponse = Date.now();\n    this.handleClose = event => {\n      console.log('WebSocket connection closed:', {\n        code: event.code,\n        reason: event.reason,\n        wasClean: event.wasClean\n      });\n      if (this.socket === null) return;\n      const wasConnected = this.socket.readyState === WebSocket.OPEN;\n      this.socket = null;\n      this.joinedChannels.clear();\n      if (event.code !== 1000 && wasConnected) {\n        if (!this.isReconnecting && this.reconnectAttempts < this.maxReconnectAttempts) {\n          console.log('Initiating reconnection...');\n          this.attemptReconnect();\n        }\n      }\n    };\n    // Update message handler to track last message ID\n    this.handleWebSocketMessage = event => {\n      try {\n        var _this$socket;\n        console.log('=== WebSocket Message Received ===');\n        console.log('Raw data:', event.data);\n        const message = JSON.parse(event.data);\n        console.log('Parsed message:', message);\n        console.log('Current state:', {\n          currentChannelId: this.currentChannelId,\n          joinedChannels: Array.from(this.joinedChannels),\n          isConnected: this.isConnected(),\n          socketState: (_this$socket = this.socket) === null || _this$socket === void 0 ? void 0 : _this$socket.readyState\n        });\n\n        // Update heartbeat timestamp for any message\n        this.lastHeartbeatResponse = Date.now();\n        if (message.type === 'pong') {\n          console.log('Heartbeat response received');\n          return;\n        }\n\n        // Handle channel join responses separately\n        if (message.type === 'channel_joined') {\n          console.log('Successfully joined channel:', message.channelId);\n          this.joinedChannels.add(message.channelId);\n          return;\n        }\n\n        // For message events, update lastMessageId and validate message\n        if (message.type === 'message' || message.type === 'message_sent' || message.type === 'new_reply' || message.type === 'message_updated') {\n          if ('message' in message && message.message) {\n            console.log('Processing message event:', message.type);\n            console.log('Message content:', message.message);\n            if (typeof message.message === 'object' && 'id' in message.message) {\n              this.lastMessageId = message.message.id.toString();\n              console.log('Updated last message ID:', this.lastMessageId);\n            } else {\n              console.warn('Invalid message format:', message);\n            }\n          } else {\n            console.warn('Message event without message data:', message);\n          }\n        }\n\n        // Notify all handlers\n        console.log(`Notifying ${this.messageHandlers.length} message handlers`);\n        this.messageHandlers.forEach((handler, index) => {\n          try {\n            console.log(`Executing handler ${index + 1}...`);\n            handler(message);\n            console.log(`Handler ${index + 1} completed successfully`);\n          } catch (error) {\n            console.error(`Error in handler ${index + 1}:`, error);\n          }\n        });\n        console.log('=== Message Processing Complete ===');\n      } catch (error) {\n        console.error('Error handling WebSocket message:', error);\n        this.handleError(error instanceof Error ? error : new Error('Failed to process WebSocket message'));\n      }\n    };\n  }\n  async connect(channelId) {\n    console.log('WebSocket connect called for channel:', channelId);\n    console.log('Current connection state:', {\n      isConnected: this.isConnected(),\n      isConnectedToChannel: this.isConnectedToChannel(channelId),\n      currentChannelId: this.currentChannelId,\n      joinedChannels: Array.from(this.joinedChannels)\n    });\n    if (this.isConnected() && this.isConnectedToChannel(channelId)) {\n      console.log('Already connected to channel:', channelId);\n      return;\n    }\n    this.disconnect();\n    this.currentChannelId = channelId;\n    this.isReconnecting = false;\n    this.reconnectAttempts = 0;\n    try {\n      const token = getAuthToken();\n      if (!token) {\n        throw new Error('No authentication token found');\n      }\n      console.log('Creating new WebSocket connection...');\n      this.socket = new WebSocket(`ws://localhost:8000/ws/chat?token=${token}`);\n      await new Promise((resolve, reject) => {\n        const timeout = setTimeout(() => {\n          console.error('WebSocket connection timeout');\n          reject(new Error('WebSocket connection timeout'));\n        }, 5000);\n        if (this.socket) {\n          this.socket.onopen = () => {\n            console.log('WebSocket connection opened successfully');\n            clearTimeout(timeout);\n            this.startHeartbeat();\n            resolve();\n          };\n          this.socket.onerror = error => {\n            console.error('WebSocket connection error:', error);\n            clearTimeout(timeout);\n            reject(error);\n          };\n        }\n      });\n      if (this.socket) {\n        console.log('Setting up WebSocket message handlers...');\n        this.socket.onmessage = this.handleWebSocketMessage;\n        this.socket.onclose = this.handleClose;\n        console.log('Joining channel:', channelId);\n        await this.joinChannel(channelId);\n        console.log('Successfully joined channel:', channelId);\n      }\n    } catch (error) {\n      console.error('WebSocket connection failed:', error);\n      this.handleError(error instanceof Error ? error : new Error('WebSocket connection failed'));\n      throw error;\n    }\n  }\n  startHeartbeat() {\n    if (this.heartbeatInterval) {\n      clearInterval(this.heartbeatInterval);\n    }\n    this.heartbeatInterval = setInterval(() => {\n      if (!this.isConnected()) {\n        return;\n      }\n\n      // Check if we haven't received a heartbeat response in 30 seconds\n      if (Date.now() - this.lastHeartbeatResponse > 30000) {\n        console.warn('No heartbeat response received, reconnecting...');\n        this.reconnect();\n        return;\n      }\n      try {\n        var _this$socket2;\n        (_this$socket2 = this.socket) === null || _this$socket2 === void 0 ? void 0 : _this$socket2.send(JSON.stringify({\n          type: 'ping'\n        }));\n      } catch (error) {\n        console.error('Error sending heartbeat:', error);\n        this.reconnect();\n      }\n    }, 15000); // Send heartbeat every 15 seconds\n  }\n  reconnect() {\n    if (this.currentChannelId) {\n      this.disconnect();\n      this.connect(this.currentChannelId).catch(console.error);\n    }\n  }\n  async joinChannel(channelId) {\n    var _this$socket3;\n    console.log('Joining channel:', channelId, {\n      isConnected: this.isConnected(),\n      socketState: (_this$socket3 = this.socket) === null || _this$socket3 === void 0 ? void 0 : _this$socket3.readyState\n    });\n    if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {\n      throw new Error('Cannot join channel: WebSocket is not connected');\n    }\n    if (this.isConnectedToChannel(channelId)) {\n      console.log('Already connected to channel:', channelId);\n      return;\n    }\n    return new Promise((resolve, reject) => {\n      const joinMessage = {\n        type: 'join_channel',\n        channel_id: channelId\n      };\n      const joinTimeout = setTimeout(() => {\n        console.error('Channel join timeout');\n        reject(new Error('Channel join timeout'));\n      }, 5000);\n      const handleJoinResponse = event => {\n        try {\n          const data = JSON.parse(event.data);\n          console.log('Received join response:', data);\n          if (data.type === 'channel_joined' && data.channel_id === channelId && this.socket) {\n            console.log('Successfully joined channel:', channelId);\n            this.socket.removeEventListener('message', handleJoinResponse);\n            clearTimeout(joinTimeout);\n            this.joinedChannels.add(channelId);\n            resolve();\n          }\n        } catch (error) {\n          console.error('Error handling join response:', error);\n        }\n      };\n      if (this.socket) {\n        console.log('Sending join message:', joinMessage);\n        this.socket.addEventListener('message', handleJoinResponse);\n        this.socket.send(JSON.stringify(joinMessage));\n      } else {\n        reject(new Error('WebSocket not available'));\n      }\n    });\n  }\n  handleError(error) {\n    console.error('WebSocket error:', error);\n    this.errorHandlers.forEach(handler => handler(error));\n  }\n  isConnected() {\n    return this.socket !== null && this.socket.readyState === WebSocket.OPEN;\n  }\n  isConnectedToChannel(channelId) {\n    return this.isConnected() && this.joinedChannels.has(channelId) && this.currentChannelId === channelId;\n  }\n  onMessage(handler) {\n    this.messageHandlers.push(handler);\n    return () => {\n      this.messageHandlers = this.messageHandlers.filter(h => h !== handler);\n    };\n  }\n  onError(handler) {\n    this.errorHandlers.push(handler);\n    return () => {\n      this.errorHandlers = this.errorHandlers.filter(h => h !== handler);\n    };\n  }\n  disconnect() {\n    this.isReconnecting = false;\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\n      this.socket.close(1000);\n    }\n    this.socket = null;\n    this.joinedChannels.clear();\n    this.messageHandlers = [];\n    this.errorHandlers = [];\n    this.reconnectAttempts = 0;\n    this.connectionPromise = null;\n    this.joinPromise = null;\n  }\n  async processMessageQueue() {\n    if (this.processingQueue || this.messageQueue.length === 0) return;\n    this.processingQueue = true;\n    console.log(`Processing message queue (${this.messageQueue.length} messages)`);\n    while (this.messageQueue.length > 0) {\n      const message = this.messageQueue[0];\n      try {\n        if (this.isConnectedToChannel(message.channelId)) {\n          await this.sendMessage(message.channelId, message.content);\n          this.messageQueue.shift(); // Remove the successfully sent message\n        } else {\n          // If we're not connected to the channel, try to connect\n          try {\n            await this.connect(message.channelId);\n          } catch (error) {\n            console.error('Failed to connect while processing queue:', error);\n            break; // Stop processing if we can't connect\n          }\n        }\n      } catch (error) {\n        console.error('Failed to send queued message:', error);\n        // If sending fails, leave the message in the queue and try again later\n        break;\n      }\n    }\n    this.processingQueue = false;\n  }\n  async sendMessage(channelId, content) {\n    console.log('Attempting to send message:', {\n      channelId,\n      content\n    });\n    if (!this.isConnectedToChannel(channelId)) {\n      console.log('Not connected to channel, attempting to connect...');\n      try {\n        await this.connect(channelId);\n      } catch (error) {\n        console.error('Failed to connect:', error);\n        throw error;\n      }\n    }\n    const message = {\n      type: 'send_message',\n      channel_id: channelId,\n      content: content\n    };\n    if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {\n      console.error('WebSocket is not connected');\n      throw new Error('WebSocket is not connected');\n    }\n    try {\n      console.log('Sending WebSocket message:', message);\n      this.socket.send(JSON.stringify(message));\n      console.log('Message sent successfully');\n    } catch (error) {\n      console.error('Error sending message:', error);\n      throw error;\n    }\n  }\n  async attemptReconnect() {\n    if (this.isReconnecting || this.reconnectAttempts >= this.maxReconnectAttempts) {\n      console.log('Skipping reconnect: already reconnecting or max attempts reached');\n      return;\n    }\n    this.isReconnecting = true;\n    this.reconnectAttempts++;\n    console.log(`Attempting to reconnect (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})...`);\n    if (this.currentChannelId) {\n      const backoffTime = Math.min(1000 * Math.pow(2, this.reconnectAttempts - 1), 10000);\n      if (this.reconnectTimeout) {\n        clearTimeout(this.reconnectTimeout);\n      }\n      this.reconnectTimeout = setTimeout(async () => {\n        try {\n          await this.connect(this.currentChannelId);\n          this.isReconnecting = false;\n          // Process any queued messages after successful reconnection\n          await this.processMessageQueue();\n        } catch (error) {\n          console.error('Reconnection failed:', error);\n          if (this.reconnectAttempts < this.maxReconnectAttempts) {\n            this.isReconnecting = false; // Reset flag to allow next attempt\n            this.attemptReconnect();\n          } else {\n            console.log('Max reconnection attempts reached');\n            this.isReconnecting = false;\n            this.handleError(new Error('Failed to reconnect after maximum attempts'));\n          }\n        }\n      }, backoffTime);\n    } else {\n      this.isReconnecting = false;\n    }\n  }\n  getChatSocketState() {\n    var _this$socket4;\n    return ((_this$socket4 = this.socket) === null || _this$socket4 === void 0 ? void 0 : _this$socket4.readyState) || WebSocket.CLOSED;\n  }\n  offMessage(handler) {\n    this.messageHandlers = this.messageHandlers.filter(h => h !== handler);\n  }\n  offError(handler) {\n    this.errorHandlers = this.errorHandlers.filter(h => h !== handler);\n  }\n}\nconst wsService = new WebSocketService();\nexport default wsService;","map":{"version":3,"names":["getAuthToken","WebSocketService","constructor","socket","messageHandlers","errorHandlers","currentChannelId","joinedChannels","Set","messageQueue","reconnectAttempts","maxReconnectAttempts","reconnectTimeout","isReconnecting","connectionPromise","joinPromise","lastMessageId","processingQueue","heartbeatInterval","lastHeartbeatResponse","Date","now","handleClose","event","console","log","code","reason","wasClean","wasConnected","readyState","WebSocket","OPEN","clear","attemptReconnect","handleWebSocketMessage","_this$socket","data","message","JSON","parse","Array","from","isConnected","socketState","type","channelId","add","id","toString","warn","length","forEach","handler","index","error","handleError","Error","connect","isConnectedToChannel","disconnect","token","Promise","resolve","reject","timeout","setTimeout","onopen","clearTimeout","startHeartbeat","onerror","onmessage","onclose","joinChannel","clearInterval","setInterval","reconnect","_this$socket2","send","stringify","catch","_this$socket3","joinMessage","channel_id","joinTimeout","handleJoinResponse","removeEventListener","addEventListener","has","onMessage","push","filter","h","onError","close","processMessageQueue","sendMessage","content","shift","backoffTime","Math","min","pow","getChatSocketState","_this$socket4","CLOSED","offMessage","offError","wsService"],"sources":["Z:/GAUNTLET/projects/SERMO/sermo-app/frontend/src/services/websocket/index.ts"],"sourcesContent":["import { WebSocketMessage, WebSocketChannelJoinMessage, WebSocketChannelMessage, StoreMessage } from '../../types';\r\nimport { getAuthToken } from '../api/auth';\r\nimport { store } from '../../store';\r\nimport { addMessage, setReplies } from '../../store/messages/messagesSlice';\r\n\r\n// Add WebSocket message types\r\ninterface WebSocketJoinMessage {\r\n  type: 'join_channel';\r\n  channel_id: string;\r\n}\r\n\r\ninterface WebSocketJoinResponse {\r\n  type: 'channel_joined' | 'channel_join_error';\r\n  channelId: string;\r\n  error?: string;\r\n}\r\n\r\nclass WebSocketService {\r\n  private socket: WebSocket | null = null;\r\n  private messageHandlers: ((message: WebSocketMessage) => void)[] = [];\r\n  private errorHandlers: ((error: Error) => void)[] = [];\r\n  private currentChannelId: string | null = null;\r\n  private joinedChannels: Set<string> = new Set();\r\n  private messageQueue: { channelId: string; content: string }[] = [];\r\n  private reconnectAttempts = 0;\r\n  private maxReconnectAttempts = 5;\r\n  private reconnectTimeout: NodeJS.Timeout | null = null;\r\n  private isReconnecting = false;\r\n  private connectionPromise: Promise<void> | null = null;\r\n  private joinPromise: Promise<void> | null = null;\r\n  private lastMessageId: string | null = null;\r\n  private processingQueue = false;\r\n  private heartbeatInterval: NodeJS.Timeout | null = null;\r\n  private lastHeartbeatResponse: number = Date.now();\r\n\r\n  public async connect(channelId: string): Promise<void> {\r\n    console.log('WebSocket connect called for channel:', channelId);\r\n    console.log('Current connection state:', {\r\n      isConnected: this.isConnected(),\r\n      isConnectedToChannel: this.isConnectedToChannel(channelId),\r\n      currentChannelId: this.currentChannelId,\r\n      joinedChannels: Array.from(this.joinedChannels)\r\n    });\r\n\r\n    if (this.isConnected() && this.isConnectedToChannel(channelId)) {\r\n      console.log('Already connected to channel:', channelId);\r\n      return;\r\n    }\r\n\r\n    this.disconnect();\r\n    this.currentChannelId = channelId;\r\n    this.isReconnecting = false;\r\n    this.reconnectAttempts = 0;\r\n    \r\n    try {\r\n      const token = getAuthToken();\r\n      if (!token) {\r\n        throw new Error('No authentication token found');\r\n      }\r\n\r\n      console.log('Creating new WebSocket connection...');\r\n      this.socket = new WebSocket(`ws://localhost:8000/ws/chat?token=${token}`);\r\n\r\n      await new Promise<void>((resolve, reject) => {\r\n        const timeout = setTimeout(() => {\r\n          console.error('WebSocket connection timeout');\r\n          reject(new Error('WebSocket connection timeout'));\r\n        }, 5000);\r\n\r\n        if (this.socket) {\r\n          this.socket.onopen = () => {\r\n            console.log('WebSocket connection opened successfully');\r\n            clearTimeout(timeout);\r\n            this.startHeartbeat();\r\n            resolve();\r\n          };\r\n\r\n          this.socket.onerror = (error) => {\r\n            console.error('WebSocket connection error:', error);\r\n            clearTimeout(timeout);\r\n            reject(error);\r\n          };\r\n        }\r\n      });\r\n\r\n      if (this.socket) {\r\n        console.log('Setting up WebSocket message handlers...');\r\n        this.socket.onmessage = this.handleWebSocketMessage;\r\n        this.socket.onclose = this.handleClose;\r\n        console.log('Joining channel:', channelId);\r\n        await this.joinChannel(channelId);\r\n        console.log('Successfully joined channel:', channelId);\r\n      }\r\n      \r\n    } catch (error) {\r\n      console.error('WebSocket connection failed:', error);\r\n      this.handleError(error instanceof Error ? error : new Error('WebSocket connection failed'));\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  private startHeartbeat(): void {\r\n    if (this.heartbeatInterval) {\r\n      clearInterval(this.heartbeatInterval);\r\n    }\r\n\r\n    this.heartbeatInterval = setInterval(() => {\r\n      if (!this.isConnected()) {\r\n        return;\r\n      }\r\n\r\n      // Check if we haven't received a heartbeat response in 30 seconds\r\n      if (Date.now() - this.lastHeartbeatResponse > 30000) {\r\n        console.warn('No heartbeat response received, reconnecting...');\r\n        this.reconnect();\r\n        return;\r\n      }\r\n\r\n      try {\r\n        this.socket?.send(JSON.stringify({ type: 'ping' }));\r\n      } catch (error) {\r\n        console.error('Error sending heartbeat:', error);\r\n        this.reconnect();\r\n      }\r\n    }, 15000); // Send heartbeat every 15 seconds\r\n  }\r\n\r\n  private reconnect(): void {\r\n    if (this.currentChannelId) {\r\n      this.disconnect();\r\n      this.connect(this.currentChannelId).catch(console.error);\r\n    }\r\n  }\r\n\r\n  private handleClose = (event: CloseEvent) => {\r\n    console.log('WebSocket connection closed:', {\r\n      code: event.code,\r\n      reason: event.reason,\r\n      wasClean: event.wasClean\r\n    });\r\n\r\n    if (this.socket === null) return;\r\n    \r\n    const wasConnected = this.socket.readyState === WebSocket.OPEN;\r\n    this.socket = null;\r\n    this.joinedChannels.clear();\r\n\r\n    if (event.code !== 1000 && wasConnected) {\r\n      if (!this.isReconnecting && this.reconnectAttempts < this.maxReconnectAttempts) {\r\n        console.log('Initiating reconnection...');\r\n        this.attemptReconnect();\r\n      }\r\n    }\r\n  };\r\n\r\n  public async joinChannel(channelId: string): Promise<void> {\r\n    console.log('Joining channel:', channelId, {\r\n      isConnected: this.isConnected(),\r\n      socketState: this.socket?.readyState\r\n    });\r\n\r\n    if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {\r\n      throw new Error('Cannot join channel: WebSocket is not connected');\r\n    }\r\n\r\n    if (this.isConnectedToChannel(channelId)) {\r\n      console.log('Already connected to channel:', channelId);\r\n      return;\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const joinMessage = { type: 'join_channel', channel_id: channelId };\r\n      const joinTimeout = setTimeout(() => {\r\n        console.error('Channel join timeout');\r\n        reject(new Error('Channel join timeout'));\r\n      }, 5000);\r\n      \r\n      const handleJoinResponse = (event: MessageEvent) => {\r\n        try {\r\n          const data = JSON.parse(event.data);\r\n          console.log('Received join response:', data);\r\n          if (data.type === 'channel_joined' && data.channel_id === channelId && this.socket) {\r\n            console.log('Successfully joined channel:', channelId);\r\n            this.socket.removeEventListener('message', handleJoinResponse);\r\n            clearTimeout(joinTimeout);\r\n            this.joinedChannels.add(channelId);\r\n            resolve();\r\n          }\r\n        } catch (error) {\r\n          console.error('Error handling join response:', error);\r\n        }\r\n      };\r\n\r\n      if (this.socket) {\r\n        console.log('Sending join message:', joinMessage);\r\n        this.socket.addEventListener('message', handleJoinResponse);\r\n        this.socket.send(JSON.stringify(joinMessage));\r\n      } else {\r\n        reject(new Error('WebSocket not available'));\r\n      }\r\n    });\r\n  }\r\n\r\n  private handleError(error: Error): void {\r\n    console.error('WebSocket error:', error);\r\n    this.errorHandlers.forEach(handler => handler(error));\r\n  }\r\n\r\n  public isConnected(): boolean {\r\n    return this.socket !== null && this.socket.readyState === WebSocket.OPEN;\r\n  }\r\n\r\n  private isConnectedToChannel(channelId: string): boolean {\r\n    return this.isConnected() && this.joinedChannels.has(channelId) && this.currentChannelId === channelId;\r\n  }\r\n\r\n  public onMessage(handler: (message: WebSocketMessage) => void): () => void {\r\n    this.messageHandlers.push(handler);\r\n    return () => {\r\n      this.messageHandlers = this.messageHandlers.filter(h => h !== handler);\r\n    };\r\n  }\r\n\r\n  public onError(handler: (error: Error) => void): () => void {\r\n    this.errorHandlers.push(handler);\r\n    return () => {\r\n      this.errorHandlers = this.errorHandlers.filter(h => h !== handler);\r\n    };\r\n  }\r\n\r\n  public disconnect(): void {\r\n    this.isReconnecting = false;\r\n    if (this.reconnectTimeout) {\r\n      clearTimeout(this.reconnectTimeout);\r\n      this.reconnectTimeout = null;\r\n    }\r\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\r\n      this.socket.close(1000);\r\n    }\r\n    this.socket = null;\r\n    this.joinedChannels.clear();\r\n    this.messageHandlers = [];\r\n    this.errorHandlers = [];\r\n    this.reconnectAttempts = 0;\r\n    this.connectionPromise = null;\r\n    this.joinPromise = null;\r\n  }\r\n\r\n  private async processMessageQueue(): Promise<void> {\r\n    if (this.processingQueue || this.messageQueue.length === 0) return;\r\n\r\n    this.processingQueue = true;\r\n    console.log(`Processing message queue (${this.messageQueue.length} messages)`);\r\n\r\n    while (this.messageQueue.length > 0) {\r\n      const message = this.messageQueue[0];\r\n      \r\n      try {\r\n        if (this.isConnectedToChannel(message.channelId)) {\r\n          await this.sendMessage(message.channelId, message.content);\r\n          this.messageQueue.shift(); // Remove the successfully sent message\r\n        } else {\r\n          // If we're not connected to the channel, try to connect\r\n          try {\r\n            await this.connect(message.channelId);\r\n          } catch (error) {\r\n            console.error('Failed to connect while processing queue:', error);\r\n            break; // Stop processing if we can't connect\r\n          }\r\n        }\r\n      } catch (error) {\r\n        console.error('Failed to send queued message:', error);\r\n        // If sending fails, leave the message in the queue and try again later\r\n        break;\r\n      }\r\n    }\r\n\r\n    this.processingQueue = false;\r\n  }\r\n\r\n  public async sendMessage(channelId: string, content: string): Promise<void> {\r\n    console.log('Attempting to send message:', { channelId, content });\r\n\r\n    if (!this.isConnectedToChannel(channelId)) {\r\n      console.log('Not connected to channel, attempting to connect...');\r\n      try {\r\n        await this.connect(channelId);\r\n      } catch (error) {\r\n        console.error('Failed to connect:', error);\r\n        throw error;\r\n      }\r\n    }\r\n\r\n    const message = {\r\n      type: 'send_message',\r\n      channel_id: channelId,\r\n      content: content\r\n    };\r\n\r\n    if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {\r\n      console.error('WebSocket is not connected');\r\n      throw new Error('WebSocket is not connected');\r\n    }\r\n\r\n    try {\r\n      console.log('Sending WebSocket message:', message);\r\n      this.socket.send(JSON.stringify(message));\r\n      console.log('Message sent successfully');\r\n    } catch (error) {\r\n      console.error('Error sending message:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  private async attemptReconnect(): Promise<void> {\r\n    if (this.isReconnecting || this.reconnectAttempts >= this.maxReconnectAttempts) {\r\n      console.log('Skipping reconnect: already reconnecting or max attempts reached');\r\n      return;\r\n    }\r\n\r\n    this.isReconnecting = true;\r\n    this.reconnectAttempts++;\r\n\r\n    console.log(`Attempting to reconnect (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})...`);\r\n\r\n    if (this.currentChannelId) {\r\n      const backoffTime = Math.min(1000 * Math.pow(2, this.reconnectAttempts - 1), 10000);\r\n      \r\n      if (this.reconnectTimeout) {\r\n        clearTimeout(this.reconnectTimeout);\r\n      }\r\n\r\n      this.reconnectTimeout = setTimeout(async () => {\r\n        try {\r\n          await this.connect(this.currentChannelId!);\r\n          this.isReconnecting = false;\r\n          // Process any queued messages after successful reconnection\r\n          await this.processMessageQueue();\r\n        } catch (error) {\r\n          console.error('Reconnection failed:', error);\r\n          if (this.reconnectAttempts < this.maxReconnectAttempts) {\r\n            this.isReconnecting = false; // Reset flag to allow next attempt\r\n            this.attemptReconnect();\r\n          } else {\r\n            console.log('Max reconnection attempts reached');\r\n            this.isReconnecting = false;\r\n            this.handleError(new Error('Failed to reconnect after maximum attempts'));\r\n          }\r\n        }\r\n      }, backoffTime);\r\n    } else {\r\n      this.isReconnecting = false;\r\n    }\r\n  }\r\n\r\n  public getChatSocketState(): number {\r\n    return this.socket?.readyState || WebSocket.CLOSED;\r\n  }\r\n\r\n  // Update message handler to track last message ID\r\n  private handleWebSocketMessage = (event: MessageEvent) => {\r\n    try {\r\n      console.log('=== WebSocket Message Received ===');\r\n      console.log('Raw data:', event.data);\r\n      \r\n      const message = JSON.parse(event.data) as WebSocketMessage;\r\n      console.log('Parsed message:', message);\r\n      console.log('Current state:', {\r\n        currentChannelId: this.currentChannelId,\r\n        joinedChannels: Array.from(this.joinedChannels),\r\n        isConnected: this.isConnected(),\r\n        socketState: this.socket?.readyState\r\n      });\r\n      \r\n      // Update heartbeat timestamp for any message\r\n      this.lastHeartbeatResponse = Date.now();\r\n\r\n      if (message.type === 'pong') {\r\n        console.log('Heartbeat response received');\r\n        return;\r\n      }\r\n\r\n      // Handle channel join responses separately\r\n      if (message.type === 'channel_joined') {\r\n        console.log('Successfully joined channel:', message.channelId);\r\n        this.joinedChannels.add(message.channelId);\r\n        return;\r\n      }\r\n\r\n      // For message events, update lastMessageId and validate message\r\n      if (message.type === 'message' || message.type === 'message_sent' || message.type === 'new_reply' || message.type === 'message_updated') {\r\n        if ('message' in message && message.message) {\r\n          console.log('Processing message event:', message.type);\r\n          console.log('Message content:', message.message);\r\n          \r\n          if (typeof message.message === 'object' && 'id' in message.message) {\r\n            this.lastMessageId = message.message.id.toString();\r\n            console.log('Updated last message ID:', this.lastMessageId);\r\n          } else {\r\n            console.warn('Invalid message format:', message);\r\n          }\r\n        } else {\r\n          console.warn('Message event without message data:', message);\r\n        }\r\n      }\r\n\r\n      // Notify all handlers\r\n      console.log(`Notifying ${this.messageHandlers.length} message handlers`);\r\n      this.messageHandlers.forEach((handler, index) => {\r\n        try {\r\n          console.log(`Executing handler ${index + 1}...`);\r\n          handler(message);\r\n          console.log(`Handler ${index + 1} completed successfully`);\r\n        } catch (error) {\r\n          console.error(`Error in handler ${index + 1}:`, error);\r\n        }\r\n      });\r\n      console.log('=== Message Processing Complete ===');\r\n    } catch (error) {\r\n      console.error('Error handling WebSocket message:', error);\r\n      this.handleError(error instanceof Error ? error : new Error('Failed to process WebSocket message'));\r\n    }\r\n  };\r\n\r\n  public offMessage(handler: (message: WebSocketMessage) => void): void {\r\n    this.messageHandlers = this.messageHandlers.filter(h => h !== handler);\r\n  }\r\n\r\n  public offError(handler: (error: Error) => void): void {\r\n    this.errorHandlers = this.errorHandlers.filter(h => h !== handler);\r\n  }\r\n}\r\n\r\nconst wsService = new WebSocketService();\r\nexport default wsService; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}