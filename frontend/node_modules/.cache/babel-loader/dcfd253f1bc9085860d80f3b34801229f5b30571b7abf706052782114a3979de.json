{"ast":null,"code":"import { getAuthToken } from '../api/auth';\nimport store from '../../store';\nimport { addMessage } from '../../store/messages/messagesSlice';\nclass WebSocketService {\n  constructor() {\n    this.socket = null;\n    this.messageHandlers = [];\n    this.errorHandlers = [];\n    this.currentChannelId = null;\n    this.processedMessageIds = new Set();\n    this.handleMessage = event => {\n      try {\n        const message = JSON.parse(event.data);\n        console.log('WebSocket message received:', message);\n\n        // Handle error messages\n        if (message.type === 'error') {\n          console.error('WebSocket error message:', message);\n          this.errorHandlers.forEach(handler => handler({\n            code: message.code || 'UNKNOWN_ERROR',\n            message: message.content || 'Unknown error occurred'\n          }));\n          return;\n        }\n\n        // Handle channel access errors\n        if (message.type === 'channel_access_denied') {\n          console.error('Channel access denied:', message);\n          this.errorHandlers.forEach(handler => handler({\n            code: 'CHANNEL_ACCESS_DENIED',\n            message: message.content || 'Access to this channel was denied'\n          }));\n          return;\n        }\n\n        // Filter out message_sent confirmations\n        if (message.type === 'message_sent') {\n          console.log('Ignoring message_sent confirmation');\n          return;\n        }\n\n        // Handle new messages\n        if (message.type === 'message' && message.message) {\n          const messageId = message.message.id;\n          if (messageId) {\n            if (this.processedMessageIds.has(messageId)) {\n              console.log('Ignoring duplicate message:', messageId);\n              return;\n            }\n            this.processedMessageIds.add(messageId);\n\n            // Limit the size of the Set to prevent memory growth\n            if (this.processedMessageIds.size > 1000) {\n              const idsArray = Array.from(this.processedMessageIds);\n              this.processedMessageIds = new Set(idsArray.slice(-500));\n            }\n\n            // Transform and dispatch the message to Redux store\n            const storeMessage = {\n              id: String(message.message.id),\n              content: message.message.content,\n              channelId: String(message.message.channel_id),\n              userId: String(message.message.sender_id),\n              reactions: [],\n              attachments: [],\n              createdAt: message.message.created_at,\n              updatedAt: message.message.created_at\n            };\n            store.dispatch(addMessage(storeMessage));\n          }\n        }\n\n        // Handle successful messages\n        this.messageHandlers.forEach(handler => handler(message));\n      } catch (error) {\n        console.error('Error parsing WebSocket message:', error);\n      }\n    };\n  }\n  connect(channelId) {\n    var _this$socket, _this$socket2, _this$socket3;\n    // If already connected to this channel, do nothing\n    if (((_this$socket = this.socket) === null || _this$socket === void 0 ? void 0 : _this$socket.readyState) === WebSocket.OPEN && this.currentChannelId === channelId) {\n      console.log('WebSocket already connected to channel', channelId);\n      return;\n    }\n\n    // If connected to a different channel, disconnect first\n    if (((_this$socket2 = this.socket) === null || _this$socket2 === void 0 ? void 0 : _this$socket2.readyState) === WebSocket.OPEN && this.currentChannelId !== channelId) {\n      console.log('Disconnecting from channel', this.currentChannelId);\n      this.disconnect();\n    }\n    const token = getAuthToken();\n    if (!token) {\n      console.error('No auth token available for WebSocket connection');\n      return;\n    }\n    const baseWsUrl = process.env.REACT_APP_WS_URL || 'ws://localhost:8000/ws';\n    console.log('Base WebSocket URL:', baseWsUrl);\n    const wsUrl = `${baseWsUrl}/chat?token=${token}`;\n    console.log('Full WebSocket URL:', wsUrl);\n    console.log('WebSocket readyState before connection:', (_this$socket3 = this.socket) === null || _this$socket3 === void 0 ? void 0 : _this$socket3.readyState);\n    try {\n      this.socket = new WebSocket(wsUrl);\n      console.log('WebSocket instance created, readyState:', this.socket.readyState);\n      this.currentChannelId = channelId;\n      this.processedMessageIds.clear(); // Clear processed messages when connecting to a new channel\n\n      this.socket.onopen = () => {\n        var _this$socket4;\n        console.log('WebSocket connection opened, readyState:', (_this$socket4 = this.socket) === null || _this$socket4 === void 0 ? void 0 : _this$socket4.readyState);\n        console.log('WebSocket connected to channel', channelId);\n        // Join the channel immediately after connection\n        this.joinChannel(channelId);\n      };\n      this.socket.onmessage = this.handleMessage;\n      this.socket.onerror = error => {\n        console.error('WebSocket error:', error);\n        this.errorHandlers.forEach(handler => handler({\n          code: 'WEBSOCKET_ERROR',\n          message: 'WebSocket connection error'\n        }));\n      };\n      this.socket.onclose = event => {\n        console.log('WebSocket disconnected with code:', event.code);\n        this.socket = null;\n        this.currentChannelId = null;\n\n        // Handle specific close codes\n        switch (event.code) {\n          case 1003:\n            // Unsupported\n            this.errorHandlers.forEach(handler => handler({\n              code: 'UNSUPPORTED',\n              message: 'WebSocket connection not supported'\n            }));\n            break;\n          case 4001:\n            // Channel access denied\n            this.errorHandlers.forEach(handler => handler({\n              code: 'CHANNEL_ACCESS_DENIED',\n              message: 'Access to the channel was denied'\n            }));\n            break;\n          case 4002:\n            // Authentication failed\n            this.errorHandlers.forEach(handler => handler({\n              code: 'AUTH_FAILED',\n              message: 'Authentication failed'\n            }));\n            break;\n          default:\n            // Try to reconnect for other close codes\n            if (channelId) {\n              setTimeout(() => {\n                console.log('Attempting to reconnect WebSocket...');\n                this.connect(channelId);\n              }, 5000);\n            }\n        }\n      };\n    } catch (error) {\n      console.error('Error creating WebSocket:', error);\n      this.errorHandlers.forEach(handler => handler({\n        code: 'WEBSOCKET_ERROR',\n        message: 'Failed to create WebSocket connection'\n      }));\n    }\n  }\n  disconnect() {\n    if (this.socket) {\n      this.socket.close();\n      this.socket = null;\n      this.currentChannelId = null;\n    }\n  }\n  sendMessage(channelId, content) {\n    var _this$socket5;\n    // If not connected to the right channel, connect first\n    if (this.currentChannelId !== channelId) {\n      console.log('Connecting to channel before sending message');\n      this.connect(channelId);\n    }\n    if (((_this$socket5 = this.socket) === null || _this$socket5 === void 0 ? void 0 : _this$socket5.readyState) === WebSocket.OPEN) {\n      const message = {\n        type: 'message',\n        channel_id: channelId,\n        content: content\n      };\n      this.socket.send(JSON.stringify(message));\n    } else {\n      console.error('WebSocket is not connected');\n      this.errorHandlers.forEach(handler => handler({\n        code: 'NOT_CONNECTED',\n        message: 'WebSocket is not connected'\n      }));\n    }\n  }\n  async joinChannel(channelId) {\n    var _this$socket6;\n    if (((_this$socket6 = this.socket) === null || _this$socket6 === void 0 ? void 0 : _this$socket6.readyState) === WebSocket.OPEN) {\n      console.log('Joining channel:', channelId);\n      const message = {\n        type: 'join_channel',\n        channel_id: parseInt(channelId)\n      };\n      this.socket.send(JSON.stringify(message));\n    } else {\n      console.error('WebSocket is not connected');\n      this.errorHandlers.forEach(handler => handler({\n        code: 'NOT_CONNECTED',\n        message: 'WebSocket is not connected'\n      }));\n    }\n  }\n  leaveChannel(channelId) {\n    var _this$socket7;\n    if (((_this$socket7 = this.socket) === null || _this$socket7 === void 0 ? void 0 : _this$socket7.readyState) === WebSocket.OPEN && this.currentChannelId === channelId) {\n      const message = {\n        type: 'leave_channel',\n        channel_id: channelId\n      };\n      this.socket.send(JSON.stringify(message));\n      this.disconnect();\n    }\n  }\n  onMessage(handler) {\n    this.messageHandlers.push(handler);\n    return () => {\n      this.messageHandlers = this.messageHandlers.filter(h => h !== handler);\n    };\n  }\n  onError(handler) {\n    this.errorHandlers.push(handler);\n    return () => {\n      this.errorHandlers = this.errorHandlers.filter(h => h !== handler);\n    };\n  }\n  getChatSocketState() {\n    var _this$socket8;\n    return ((_this$socket8 = this.socket) === null || _this$socket8 === void 0 ? void 0 : _this$socket8.readyState) || WebSocket.CLOSED;\n  }\n  getCurrentChannelId() {\n    return this.currentChannelId;\n  }\n}\nconst wsService = new WebSocketService();\nexport default wsService;","map":{"version":3,"names":["getAuthToken","store","addMessage","WebSocketService","constructor","socket","messageHandlers","errorHandlers","currentChannelId","processedMessageIds","Set","handleMessage","event","message","JSON","parse","data","console","log","type","error","forEach","handler","code","content","messageId","id","has","add","size","idsArray","Array","from","slice","storeMessage","String","channelId","channel_id","userId","sender_id","reactions","attachments","createdAt","created_at","updatedAt","dispatch","connect","_this$socket","_this$socket2","_this$socket3","readyState","WebSocket","OPEN","disconnect","token","baseWsUrl","process","env","REACT_APP_WS_URL","wsUrl","clear","onopen","_this$socket4","joinChannel","onmessage","onerror","onclose","setTimeout","close","sendMessage","_this$socket5","send","stringify","_this$socket6","parseInt","leaveChannel","_this$socket7","onMessage","push","filter","h","onError","getChatSocketState","_this$socket8","CLOSED","getCurrentChannelId","wsService"],"sources":["Z:/GAUNTLET/projects/SERMO/sermo-app/frontend/src/services/websocket/index.ts"],"sourcesContent":["import { WebSocketMessage } from '../../types';\r\nimport { getAuthToken } from '../api/auth';\r\nimport store from '../../store';\r\nimport { addMessage } from '../../store/messages/messagesSlice';\r\n\r\nclass WebSocketService {\r\n  private socket: WebSocket | null = null;\r\n  private messageHandlers: ((message: WebSocketMessage) => void)[] = [];\r\n  private errorHandlers: ((error: { code: string; message: string }) => void)[] = [];\r\n  private currentChannelId: string | null = null;\r\n  private processedMessageIds: Set<string> = new Set();\r\n\r\n  connect(channelId: string) {\r\n    // If already connected to this channel, do nothing\r\n    if (this.socket?.readyState === WebSocket.OPEN && this.currentChannelId === channelId) {\r\n      console.log('WebSocket already connected to channel', channelId);\r\n      return;\r\n    }\r\n\r\n    // If connected to a different channel, disconnect first\r\n    if (this.socket?.readyState === WebSocket.OPEN && this.currentChannelId !== channelId) {\r\n      console.log('Disconnecting from channel', this.currentChannelId);\r\n      this.disconnect();\r\n    }\r\n\r\n    const token = getAuthToken();\r\n    if (!token) {\r\n      console.error('No auth token available for WebSocket connection');\r\n      return;\r\n    }\r\n\r\n    const baseWsUrl = process.env.REACT_APP_WS_URL || 'ws://localhost:8000/ws';\r\n    console.log('Base WebSocket URL:', baseWsUrl);\r\n    const wsUrl = `${baseWsUrl}/chat?token=${token}`;\r\n    console.log('Full WebSocket URL:', wsUrl);\r\n    console.log('WebSocket readyState before connection:', this.socket?.readyState);\r\n    \r\n    try {\r\n      this.socket = new WebSocket(wsUrl);\r\n      console.log('WebSocket instance created, readyState:', this.socket.readyState);\r\n      this.currentChannelId = channelId;\r\n      this.processedMessageIds.clear(); // Clear processed messages when connecting to a new channel\r\n\r\n      this.socket.onopen = () => {\r\n        console.log('WebSocket connection opened, readyState:', this.socket?.readyState);\r\n        console.log('WebSocket connected to channel', channelId);\r\n        // Join the channel immediately after connection\r\n        this.joinChannel(channelId);\r\n      };\r\n\r\n      this.socket.onmessage = this.handleMessage;\r\n\r\n      this.socket.onerror = (error) => {\r\n        console.error('WebSocket error:', error);\r\n        this.errorHandlers.forEach(handler => handler({\r\n          code: 'WEBSOCKET_ERROR',\r\n          message: 'WebSocket connection error'\r\n        }));\r\n      };\r\n\r\n      this.socket.onclose = (event) => {\r\n        console.log('WebSocket disconnected with code:', event.code);\r\n        this.socket = null;\r\n        this.currentChannelId = null;\r\n\r\n        // Handle specific close codes\r\n        switch (event.code) {\r\n          case 1003: // Unsupported\r\n            this.errorHandlers.forEach(handler => handler({\r\n              code: 'UNSUPPORTED',\r\n              message: 'WebSocket connection not supported'\r\n            }));\r\n            break;\r\n          case 4001: // Channel access denied\r\n            this.errorHandlers.forEach(handler => handler({\r\n              code: 'CHANNEL_ACCESS_DENIED',\r\n              message: 'Access to the channel was denied'\r\n            }));\r\n            break;\r\n          case 4002: // Authentication failed\r\n            this.errorHandlers.forEach(handler => handler({\r\n              code: 'AUTH_FAILED',\r\n              message: 'Authentication failed'\r\n            }));\r\n            break;\r\n          default:\r\n            // Try to reconnect for other close codes\r\n            if (channelId) {\r\n              setTimeout(() => {\r\n                console.log('Attempting to reconnect WebSocket...');\r\n                this.connect(channelId);\r\n              }, 5000);\r\n            }\r\n        }\r\n      };\r\n    } catch (error) {\r\n      console.error('Error creating WebSocket:', error);\r\n      this.errorHandlers.forEach(handler => handler({\r\n        code: 'WEBSOCKET_ERROR',\r\n        message: 'Failed to create WebSocket connection'\r\n      }));\r\n    }\r\n  }\r\n\r\n  disconnect() {\r\n    if (this.socket) {\r\n      this.socket.close();\r\n      this.socket = null;\r\n      this.currentChannelId = null;\r\n    }\r\n  }\r\n\r\n  sendMessage(channelId: string, content: string) {\r\n    // If not connected to the right channel, connect first\r\n    if (this.currentChannelId !== channelId) {\r\n      console.log('Connecting to channel before sending message');\r\n      this.connect(channelId);\r\n    }\r\n\r\n    if (this.socket?.readyState === WebSocket.OPEN) {\r\n      const message = {\r\n        type: 'message',\r\n        channel_id: channelId,\r\n        content: content\r\n      };\r\n      this.socket.send(JSON.stringify(message));\r\n    } else {\r\n      console.error('WebSocket is not connected');\r\n      this.errorHandlers.forEach(handler => handler({\r\n        code: 'NOT_CONNECTED',\r\n        message: 'WebSocket is not connected'\r\n      }));\r\n    }\r\n  }\r\n\r\n  async joinChannel(channelId: string) {\r\n    if (this.socket?.readyState === WebSocket.OPEN) {\r\n      console.log('Joining channel:', channelId);\r\n      const message = {\r\n        type: 'join_channel',\r\n        channel_id: parseInt(channelId)\r\n      };\r\n      this.socket.send(JSON.stringify(message));\r\n    } else {\r\n      console.error('WebSocket is not connected');\r\n      this.errorHandlers.forEach(handler => handler({\r\n        code: 'NOT_CONNECTED',\r\n        message: 'WebSocket is not connected'\r\n      }));\r\n    }\r\n  }\r\n\r\n  leaveChannel(channelId: string) {\r\n    if (this.socket?.readyState === WebSocket.OPEN && this.currentChannelId === channelId) {\r\n      const message = {\r\n        type: 'leave_channel',\r\n        channel_id: channelId\r\n      };\r\n      this.socket.send(JSON.stringify(message));\r\n      this.disconnect();\r\n    }\r\n  }\r\n\r\n  onMessage(handler: (message: WebSocketMessage) => void) {\r\n    this.messageHandlers.push(handler);\r\n    return () => {\r\n      this.messageHandlers = this.messageHandlers.filter(h => h !== handler);\r\n    };\r\n  }\r\n\r\n  onError(handler: (error: { code: string; message: string }) => void) {\r\n    this.errorHandlers.push(handler);\r\n    return () => {\r\n      this.errorHandlers = this.errorHandlers.filter(h => h !== handler);\r\n    };\r\n  }\r\n\r\n  getChatSocketState() {\r\n    return this.socket?.readyState || WebSocket.CLOSED;\r\n  }\r\n\r\n  getCurrentChannelId() {\r\n    return this.currentChannelId;\r\n  }\r\n\r\n  private handleMessage = (event: MessageEvent) => {\r\n    try {\r\n      const message = JSON.parse(event.data) as WebSocketMessage;\r\n      console.log('WebSocket message received:', message);\r\n\r\n      // Handle error messages\r\n      if (message.type === 'error') {\r\n        console.error('WebSocket error message:', message);\r\n        this.errorHandlers.forEach(handler => handler({\r\n          code: message.code || 'UNKNOWN_ERROR',\r\n          message: message.content || 'Unknown error occurred'\r\n        }));\r\n        return;\r\n      }\r\n\r\n      // Handle channel access errors\r\n      if (message.type === 'channel_access_denied') {\r\n        console.error('Channel access denied:', message);\r\n        this.errorHandlers.forEach(handler => handler({\r\n          code: 'CHANNEL_ACCESS_DENIED',\r\n          message: message.content || 'Access to this channel was denied'\r\n        }));\r\n        return;\r\n      }\r\n\r\n      // Filter out message_sent confirmations\r\n      if (message.type === 'message_sent') {\r\n        console.log('Ignoring message_sent confirmation');\r\n        return;\r\n      }\r\n\r\n      // Handle new messages\r\n      if (message.type === 'message' && message.message) {\r\n        const messageId = message.message.id;\r\n        if (messageId) {\r\n          if (this.processedMessageIds.has(messageId)) {\r\n            console.log('Ignoring duplicate message:', messageId);\r\n            return;\r\n          }\r\n          this.processedMessageIds.add(messageId);\r\n\r\n          // Limit the size of the Set to prevent memory growth\r\n          if (this.processedMessageIds.size > 1000) {\r\n            const idsArray = Array.from(this.processedMessageIds);\r\n            this.processedMessageIds = new Set(idsArray.slice(-500));\r\n          }\r\n\r\n          // Transform and dispatch the message to Redux store\r\n          const storeMessage = {\r\n            id: String(message.message.id),\r\n            content: message.message.content,\r\n            channelId: String(message.message.channel_id),\r\n            userId: String(message.message.sender_id),\r\n            reactions: [],\r\n            attachments: [],\r\n            createdAt: message.message.created_at,\r\n            updatedAt: message.message.created_at\r\n          };\r\n          store.dispatch(addMessage(storeMessage));\r\n        }\r\n      }\r\n\r\n      // Handle successful messages\r\n      this.messageHandlers.forEach(handler => handler(message));\r\n    } catch (error) {\r\n      console.error('Error parsing WebSocket message:', error);\r\n    }\r\n  };\r\n}\r\n\r\nconst wsService = new WebSocketService();\r\nexport default wsService; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}