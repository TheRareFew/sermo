{"ast":null,"code":"import { createSlice } from '@reduxjs/toolkit';\nconst initialState = {\n  messagesByChannel: {},\n  loading: false,\n  error: null\n};\nconst messagesSlice = createSlice({\n  name: 'messages',\n  initialState,\n  reducers: {\n    fetchMessagesStart: state => {\n      state.loading = true;\n      state.error = null;\n    },\n    fetchMessagesSuccess: (state, action) => {\n      // Sort messages by createdAt in ascending order (oldest first)\n      const sortedMessages = action.payload.messages.sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());\n      state.messagesByChannel[action.payload.channelId] = sortedMessages;\n      state.loading = false;\n      state.error = null;\n    },\n    fetchMessagesFailure: (state, action) => {\n      state.loading = false;\n      state.error = action.payload;\n    },\n    addMessage: (state, action) => {\n      const {\n        channelId\n      } = action.payload;\n      if (!state.messagesByChannel[channelId]) {\n        state.messagesByChannel[channelId] = [];\n      }\n      // Add new message at the end (it's the newest)\n      state.messagesByChannel[channelId].push(action.payload);\n    },\n    updateMessage: (state, action) => {\n      const {\n        channelId,\n        id\n      } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const index = messages.findIndex(msg => msg.id === id);\n        if (index !== -1) {\n          messages[index] = action.payload;\n        }\n      }\n    },\n    deleteMessage: (state, action) => {\n      const {\n        channelId,\n        messageId\n      } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        state.messagesByChannel[channelId] = messages.filter(msg => msg.id !== messageId);\n      }\n    },\n    addReaction: (state, action) => {\n      const {\n        channelId,\n        messageId,\n        reaction\n      } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const message = messages.find(msg => msg.id === messageId);\n        if (message) {\n          message.reactions.push(reaction);\n        }\n      }\n    },\n    removeReaction: (state, action) => {\n      const {\n        channelId,\n        messageId,\n        reactionId\n      } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const message = messages.find(msg => msg.id === messageId);\n        if (message) {\n          message.reactions = message.reactions.filter(reaction => reaction.id !== reactionId);\n        }\n      }\n    }\n  }\n});\nexport const {\n  fetchMessagesStart,\n  fetchMessagesSuccess,\n  fetchMessagesFailure,\n  addMessage,\n  updateMessage,\n  deleteMessage,\n  addReaction,\n  removeReaction\n} = messagesSlice.actions;\nexport default messagesSlice.reducer;","map":{"version":3,"names":["createSlice","initialState","messagesByChannel","loading","error","messagesSlice","name","reducers","fetchMessagesStart","state","fetchMessagesSuccess","action","sortedMessages","payload","messages","sort","a","b","Date","createdAt","getTime","channelId","fetchMessagesFailure","addMessage","push","updateMessage","id","index","findIndex","msg","deleteMessage","messageId","filter","addReaction","reaction","message","find","reactions","removeReaction","reactionId","actions","reducer"],"sources":["Z:/GAUNTLET/projects/SERMO/sermo-app/frontend/src/store/messages/messagesSlice.ts"],"sourcesContent":["import { createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { MessagesState, Message, Reaction } from '../types';\n\nconst initialState: MessagesState = {\n  messagesByChannel: {},\n  loading: false,\n  error: null,\n};\n\nconst messagesSlice = createSlice({\n  name: 'messages',\n  initialState,\n  reducers: {\n    fetchMessagesStart: (state) => {\n      state.loading = true;\n      state.error = null;\n    },\n    fetchMessagesSuccess: (state, action: PayloadAction<{ channelId: string; messages: Message[] }>) => {\n      // Sort messages by createdAt in ascending order (oldest first)\n      const sortedMessages = action.payload.messages.sort((a, b) => \n        new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()\n      );\n      state.messagesByChannel[action.payload.channelId] = sortedMessages;\n      state.loading = false;\n      state.error = null;\n    },\n    fetchMessagesFailure: (state, action: PayloadAction<string>) => {\n      state.loading = false;\n      state.error = action.payload;\n    },\n    addMessage: (state, action: PayloadAction<Message>) => {\n      const { channelId } = action.payload;\n      if (!state.messagesByChannel[channelId]) {\n        state.messagesByChannel[channelId] = [];\n      }\n      // Add new message at the end (it's the newest)\n      state.messagesByChannel[channelId].push(action.payload);\n    },\n    updateMessage: (state, action: PayloadAction<Message>) => {\n      const { channelId, id } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const index = messages.findIndex(msg => msg.id === id);\n        if (index !== -1) {\n          messages[index] = action.payload;\n        }\n      }\n    },\n    deleteMessage: (state, action: PayloadAction<{ channelId: string; messageId: string }>) => {\n      const { channelId, messageId } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        state.messagesByChannel[channelId] = messages.filter(msg => msg.id !== messageId);\n      }\n    },\n    addReaction: (state, action: PayloadAction<{ channelId: string; messageId: string; reaction: Reaction }>) => {\n      const { channelId, messageId, reaction } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const message = messages.find(msg => msg.id === messageId);\n        if (message) {\n          message.reactions.push(reaction);\n        }\n      }\n    },\n    removeReaction: (state, action: PayloadAction<{ channelId: string; messageId: string; reactionId: string }>) => {\n      const { channelId, messageId, reactionId } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const message = messages.find(msg => msg.id === messageId);\n        if (message) {\n          message.reactions = message.reactions.filter(reaction => reaction.id !== reactionId);\n        }\n      }\n    },\n  },\n});\n\nexport const {\n  fetchMessagesStart,\n  fetchMessagesSuccess,\n  fetchMessagesFailure,\n  addMessage,\n  updateMessage,\n  deleteMessage,\n  addReaction,\n  removeReaction,\n} = messagesSlice.actions;\n\nexport default messagesSlice.reducer; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}