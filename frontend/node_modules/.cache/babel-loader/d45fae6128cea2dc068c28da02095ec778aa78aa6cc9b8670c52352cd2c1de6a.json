{"ast":null,"code":"import { createSlice } from '@reduxjs/toolkit';\nconst initialState = {\n  messagesByChannel: {},\n  loading: false,\n  error: null\n};\nconst messagesSlice = createSlice({\n  name: 'messages',\n  initialState,\n  reducers: {\n    fetchMessagesStart: state => {\n      console.log('Starting message fetch');\n      state.loading = true;\n      state.error = null;\n    },\n    fetchMessagesSuccess: (state, action) => {\n      console.log('Message fetch success:', action.payload);\n      // Sort messages by createdAt in descending order (newest first)\n      const sortedMessages = action.payload.messages.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n      state.messagesByChannel[action.payload.channelId] = sortedMessages;\n      state.loading = false;\n      state.error = null;\n      console.log('Updated message state:', {\n        channelId: action.payload.channelId,\n        messageCount: sortedMessages.length,\n        messages: sortedMessages,\n        state: state\n      });\n    },\n    fetchMessagesFailure: (state, action) => {\n      console.log('Message fetch failed:', action.payload);\n      state.loading = false;\n      state.error = action.payload;\n    },\n    addMessage: (state, action) => {\n      console.log('Adding message to store:', action.payload);\n      const {\n        channelId\n      } = action.payload;\n\n      // Initialize the channel's message array if it doesn't exist\n      if (!state.messagesByChannel[channelId]) {\n        state.messagesByChannel[channelId] = [];\n      }\n\n      // Check if message already exists\n      const existingMessageIndex = state.messagesByChannel[channelId].findIndex(msg => msg.id === action.payload.id);\n      if (existingMessageIndex === -1) {\n        // Add new message at the end (it's the newest)\n        state.messagesByChannel[channelId].push(action.payload);\n        // Sort messages by createdAt in descending order (newest first)\n        state.messagesByChannel[channelId].sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n        console.log('Updated message state after add:', {\n          channelId,\n          messageCount: state.messagesByChannel[channelId].length,\n          messages: state.messagesByChannel[channelId],\n          state: state\n        });\n      } else {\n        // Update existing message\n        state.messagesByChannel[channelId][existingMessageIndex] = action.payload;\n        console.log('Updated existing message:', {\n          messageId: action.payload.id,\n          channelId,\n          messageCount: state.messagesByChannel[channelId].length,\n          messages: state.messagesByChannel[channelId],\n          state: state\n        });\n      }\n    },\n    updateMessage: (state, action) => {\n      const {\n        channelId,\n        id\n      } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const index = messages.findIndex(msg => msg.id === id);\n        if (index !== -1) {\n          messages[index] = action.payload;\n        }\n      }\n    },\n    deleteMessage: (state, action) => {\n      const {\n        channelId,\n        messageId\n      } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        state.messagesByChannel[channelId] = messages.filter(msg => msg.id !== messageId);\n      }\n    },\n    addReaction: (state, action) => {\n      const {\n        channelId,\n        messageId,\n        reaction\n      } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const message = messages.find(msg => msg.id === messageId);\n        if (message) {\n          // Check if reaction already exists\n          const existingReactionIndex = message.reactions.findIndex(r => r.id === reaction.id || r.emoji === reaction.emoji && r.userId === reaction.userId);\n          if (existingReactionIndex === -1) {\n            message.reactions.push(reaction);\n          }\n        }\n      }\n    },\n    removeReaction: (state, action) => {\n      const {\n        channelId,\n        messageId,\n        reactionId\n      } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const message = messages.find(msg => msg.id === messageId);\n        if (message) {\n          message.reactions = message.reactions.filter(reaction => reaction.id !== reactionId);\n        }\n      }\n    }\n  }\n});\nexport const {\n  fetchMessagesStart,\n  fetchMessagesSuccess,\n  fetchMessagesFailure,\n  addMessage,\n  updateMessage,\n  deleteMessage,\n  addReaction,\n  removeReaction\n} = messagesSlice.actions;\nexport default messagesSlice.reducer;","map":{"version":3,"names":["createSlice","initialState","messagesByChannel","loading","error","messagesSlice","name","reducers","fetchMessagesStart","state","console","log","fetchMessagesSuccess","action","payload","sortedMessages","messages","sort","a","b","Date","createdAt","getTime","channelId","messageCount","length","fetchMessagesFailure","addMessage","existingMessageIndex","findIndex","msg","id","push","messageId","updateMessage","index","deleteMessage","filter","addReaction","reaction","message","find","existingReactionIndex","reactions","r","emoji","userId","removeReaction","reactionId","actions","reducer"],"sources":["Z:/GAUNTLET/projects/SERMO/sermo-app/frontend/src/store/messages/messagesSlice.ts"],"sourcesContent":["import { createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { MessagesState, Reaction, StoreMessage } from '../types';\nimport { Message as ApiMessage } from '../../types';\n\nconst initialState: MessagesState = {\n  messagesByChannel: {},\n  loading: false,\n  error: null,\n};\n\nconst messagesSlice = createSlice({\n  name: 'messages',\n  initialState,\n  reducers: {\n    fetchMessagesStart: (state) => {\n      console.log('Starting message fetch');\n      state.loading = true;\n      state.error = null;\n    },\n    fetchMessagesSuccess: (state, action: PayloadAction<{ channelId: string; messages: StoreMessage[] }>) => {\n      console.log('Message fetch success:', action.payload);\n      // Sort messages by createdAt in descending order (newest first)\n      const sortedMessages = action.payload.messages.sort((a, b) => \n        new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()\n      );\n\n      state.messagesByChannel[action.payload.channelId] = sortedMessages;\n      state.loading = false;\n      state.error = null;\n      console.log('Updated message state:', {\n        channelId: action.payload.channelId,\n        messageCount: sortedMessages.length,\n        messages: sortedMessages,\n        state: state\n      });\n    },\n    fetchMessagesFailure: (state, action: PayloadAction<string>) => {\n      console.log('Message fetch failed:', action.payload);\n      state.loading = false;\n      state.error = action.payload;\n    },\n    addMessage: (state, action: PayloadAction<StoreMessage>) => {\n      console.log('Adding message to store:', action.payload);\n      const { channelId } = action.payload;\n      \n      // Initialize the channel's message array if it doesn't exist\n      if (!state.messagesByChannel[channelId]) {\n        state.messagesByChannel[channelId] = [];\n      }\n\n      // Check if message already exists\n      const existingMessageIndex = state.messagesByChannel[channelId].findIndex(\n        msg => msg.id === action.payload.id\n      );\n\n      if (existingMessageIndex === -1) {\n        // Add new message at the end (it's the newest)\n        state.messagesByChannel[channelId].push(action.payload);\n        // Sort messages by createdAt in descending order (newest first)\n        state.messagesByChannel[channelId].sort((a, b) => \n          new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()\n        );\n        console.log('Updated message state after add:', {\n          channelId,\n          messageCount: state.messagesByChannel[channelId].length,\n          messages: state.messagesByChannel[channelId],\n          state: state\n        });\n      } else {\n        // Update existing message\n        state.messagesByChannel[channelId][existingMessageIndex] = action.payload;\n        console.log('Updated existing message:', {\n          messageId: action.payload.id,\n          channelId,\n          messageCount: state.messagesByChannel[channelId].length,\n          messages: state.messagesByChannel[channelId],\n          state: state\n        });\n      }\n    },\n    updateMessage: (state, action: PayloadAction<StoreMessage>) => {\n      const { channelId, id } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const index = messages.findIndex(msg => msg.id === id);\n        if (index !== -1) {\n          messages[index] = action.payload;\n        }\n      }\n    },\n    deleteMessage: (state, action: PayloadAction<{ channelId: string; messageId: string }>) => {\n      const { channelId, messageId } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        state.messagesByChannel[channelId] = messages.filter(msg => msg.id !== messageId);\n      }\n    },\n    addReaction: (state, action: PayloadAction<{ channelId: string; messageId: string; reaction: Reaction }>) => {\n      const { channelId, messageId, reaction } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const message = messages.find(msg => msg.id === messageId);\n        if (message) {\n          // Check if reaction already exists\n          const existingReactionIndex = message.reactions.findIndex(\n            r => r.id === reaction.id || (r.emoji === reaction.emoji && r.userId === reaction.userId)\n          );\n          if (existingReactionIndex === -1) {\n            message.reactions.push(reaction);\n          }\n        }\n      }\n    },\n    removeReaction: (state, action: PayloadAction<{ channelId: string; messageId: string; reactionId: string }>) => {\n      const { channelId, messageId, reactionId } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const message = messages.find(msg => msg.id === messageId);\n        if (message) {\n          message.reactions = message.reactions.filter(reaction => reaction.id !== reactionId);\n        }\n      }\n    },\n  },\n});\n\nexport const {\n  fetchMessagesStart,\n  fetchMessagesSuccess,\n  fetchMessagesFailure,\n  addMessage,\n  updateMessage,\n  deleteMessage,\n  addReaction,\n  removeReaction,\n} = messagesSlice.actions;\n\nexport default messagesSlice.reducer; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}