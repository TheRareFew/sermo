{"ast":null,"code":"import { getAuthToken } from '../api/auth';\n\n// Add WebSocket message types\n\nclass WebSocketService {\n  constructor() {\n    this.socket = null;\n    this.messageHandlers = [];\n    this.errorHandlers = [];\n    this.currentChannelId = null;\n    this.joinedChannels = new Set();\n    this.messageQueue = [];\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectTimeout = null;\n    this.isReconnecting = false;\n    this.connectionPromise = null;\n  }\n  async connect(channelId) {\n    if (this.isReconnecting) {\n      console.log('Already attempting to reconnect...');\n      return;\n    }\n    if (this.connectionPromise) {\n      await this.connectionPromise;\n      if (this.isConnected() && this.isConnectedToChannel(channelId)) {\n        return;\n      }\n    }\n    this.currentChannelId = channelId;\n    try {\n      this.connectionPromise = new Promise((resolve, reject) => {\n        const token = getAuthToken();\n        if (!token) {\n          console.log('No authentication token found, skipping WebSocket connection');\n          resolve(); // Resolve without connecting - will retry when token is available\n          return;\n        }\n        console.log(`Connecting to WebSocket: ws://localhost:8000/ws/chat?token=${token}`);\n        this.socket = new WebSocket(`ws://localhost:8000/ws/chat?token=${token}`);\n        this.socket.onopen = async () => {\n          console.log('WebSocket connection opened');\n          this.reconnectAttempts = 0;\n          this.isReconnecting = false;\n          try {\n            await this.joinChannel(channelId);\n            resolve();\n          } catch (error) {\n            console.error('Failed to join channel:', error);\n            reject(error);\n          }\n        };\n        this.socket.onclose = event => {\n          console.log(`WebSocket disconnected with code: ${event.code}`);\n          this.socket = null;\n          this.joinedChannels.clear();\n          if (event.code !== 1000) {\n            this.attemptReconnect();\n          }\n        };\n        this.socket.onerror = () => {\n          const error = new Error('WebSocket connection error');\n          console.error('WebSocket error:', error);\n          this.handleError(error);\n        };\n        this.socket.onmessage = event => {\n          try {\n            const message = JSON.parse(event.data);\n            this.messageHandlers.forEach(handler => handler(message));\n          } catch (error) {\n            console.error('Error parsing WebSocket message:', error);\n          }\n        };\n      });\n      await this.connectionPromise;\n    } catch (error) {\n      console.error('WebSocket connection failed:', error);\n      this.handleError(error instanceof Error ? error : new Error('WebSocket connection failed'));\n      throw error;\n    } finally {\n      this.connectionPromise = null;\n    }\n  }\n  async joinChannel(channelId) {\n    const token = getAuthToken();\n    if (!token) {\n      console.log('No authentication token found, skipping channel join');\n      return;\n    }\n    if (!this.isConnected()) {\n      await this.connect(channelId);\n      return;\n    }\n    if (this.isConnectedToChannel(channelId)) {\n      return;\n    }\n    return new Promise((resolve, reject) => {\n      var _this$socket3, _this$socket4;\n      const joinMessage = {\n        type: 'join_channel',\n        channel_id: channelId\n      };\n      const timeoutId = setTimeout(() => {\n        reject(new Error('Channel join timeout'));\n      }, 5000);\n      const handleJoinResponse = event => {\n        try {\n          const response = JSON.parse(event.data);\n          if (response.type === 'channel_joined' && response.channelId === channelId) {\n            var _this$socket;\n            clearTimeout(timeoutId);\n            this.joinedChannels.add(channelId);\n            (_this$socket = this.socket) === null || _this$socket === void 0 ? void 0 : _this$socket.removeEventListener('message', handleJoinResponse);\n            resolve();\n          } else if (response.type === 'channel_join_error') {\n            var _this$socket2;\n            clearTimeout(timeoutId);\n            (_this$socket2 = this.socket) === null || _this$socket2 === void 0 ? void 0 : _this$socket2.removeEventListener('message', handleJoinResponse);\n            reject(new Error(response.error || 'Failed to join channel'));\n          }\n        } catch (error) {\n          // Ignore messages that aren't join responses\n        }\n      };\n      (_this$socket3 = this.socket) === null || _this$socket3 === void 0 ? void 0 : _this$socket3.addEventListener('message', handleJoinResponse);\n      (_this$socket4 = this.socket) === null || _this$socket4 === void 0 ? void 0 : _this$socket4.send(JSON.stringify(joinMessage));\n    });\n  }\n  handleError(error) {\n    console.error('WebSocket error:', error);\n    this.errorHandlers.forEach(handler => handler(error));\n  }\n  isConnected() {\n    return this.socket !== null && this.socket.readyState === WebSocket.OPEN;\n  }\n  isConnectedToChannel(channelId) {\n    return this.isConnected() && this.joinedChannels.has(channelId);\n  }\n  onMessage(handler) {\n    this.messageHandlers.push(handler);\n    return () => {\n      this.messageHandlers = this.messageHandlers.filter(h => h !== handler);\n    };\n  }\n  onError(handler) {\n    this.errorHandlers.push(handler);\n    return () => {\n      this.errorHandlers = this.errorHandlers.filter(h => h !== handler);\n    };\n  }\n  disconnect() {\n    if (this.socket) {\n      this.socket.close(1000);\n      this.socket = null;\n    }\n    this.joinedChannels.clear();\n    this.messageHandlers = [];\n    this.errorHandlers = [];\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n  }\n  attemptReconnect() {\n    if (this.isReconnecting || this.reconnectAttempts >= this.maxReconnectAttempts) {\n      return;\n    }\n    this.isReconnecting = true;\n    this.reconnectAttempts++;\n    console.log(`Attempting to reconnect (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})...`);\n    if (this.currentChannelId) {\n      const backoffTime = Math.min(1000 * Math.pow(2, this.reconnectAttempts - 1), 10000);\n      this.reconnectTimeout = setTimeout(() => {\n        this.connect(this.currentChannelId).catch(error => {\n          console.error('Reconnection failed:', error);\n          if (this.reconnectAttempts < this.maxReconnectAttempts) {\n            this.attemptReconnect();\n          } else {\n            this.isReconnecting = false;\n            this.handleError(new Error('Max reconnection attempts reached'));\n          }\n        });\n      }, backoffTime);\n    }\n  }\n  getChatSocketState() {\n    var _this$socket5;\n    return ((_this$socket5 = this.socket) === null || _this$socket5 === void 0 ? void 0 : _this$socket5.readyState) || WebSocket.CLOSED;\n  }\n  async sendMessage(channelId, content) {\n    // If not connected to the right channel, connect first\n    if (!this.isConnectedToChannel(channelId)) {\n      try {\n        await this.connect(channelId);\n      } catch (error) {\n        console.error('Failed to connect to channel:', error);\n        throw new Error('Failed to send message: Could not connect to channel');\n      }\n    }\n    if (!this.isConnected()) {\n      throw new Error('WebSocket is not connected');\n    }\n    const message = {\n      type: 'message',\n      channel_id: channelId,\n      content: content\n    };\n    try {\n      this.socket.send(JSON.stringify(message));\n    } catch (error) {\n      console.error('Failed to send message:', error);\n      throw new Error('Failed to send message');\n    }\n  }\n}\nconst wsService = new WebSocketService();\nexport default wsService;","map":{"version":3,"names":["getAuthToken","WebSocketService","constructor","socket","messageHandlers","errorHandlers","currentChannelId","joinedChannels","Set","messageQueue","reconnectAttempts","maxReconnectAttempts","reconnectTimeout","isReconnecting","connectionPromise","connect","channelId","console","log","isConnected","isConnectedToChannel","Promise","resolve","reject","token","WebSocket","onopen","joinChannel","error","onclose","event","code","clear","attemptReconnect","onerror","Error","handleError","onmessage","message","JSON","parse","data","forEach","handler","_this$socket3","_this$socket4","joinMessage","type","channel_id","timeoutId","setTimeout","handleJoinResponse","response","_this$socket","clearTimeout","add","removeEventListener","_this$socket2","addEventListener","send","stringify","readyState","OPEN","has","onMessage","push","filter","h","onError","disconnect","close","backoffTime","Math","min","pow","catch","getChatSocketState","_this$socket5","CLOSED","sendMessage","content","wsService"],"sources":["Z:/GAUNTLET/projects/SERMO/sermo-app/frontend/src/services/websocket/index.ts"],"sourcesContent":["import { WebSocketMessage, WebSocketChannelJoinMessage, WebSocketChannelMessage, StoreMessage } from '../../types';\r\nimport { getAuthToken } from '../api/auth';\r\nimport { store } from '../../store';\r\nimport { addMessage, setReplies } from '../../store/messages/messagesSlice';\r\n\r\n// Add WebSocket message types\r\ninterface WebSocketJoinMessage {\r\n  type: 'join_channel';\r\n  channel_id: string;\r\n}\r\n\r\ninterface WebSocketJoinResponse {\r\n  type: 'channel_joined' | 'channel_join_error';\r\n  channelId: string;\r\n  error?: string;\r\n}\r\n\r\nclass WebSocketService {\r\n  private socket: WebSocket | null = null;\r\n  private messageHandlers: ((message: WebSocketMessage) => void)[] = [];\r\n  private errorHandlers: ((error: Error) => void)[] = [];\r\n  private currentChannelId: string | null = null;\r\n  private joinedChannels: Set<string> = new Set();\r\n  private messageQueue: WebSocketMessage[] = [];\r\n  private reconnectAttempts = 0;\r\n  private maxReconnectAttempts = 5;\r\n  private reconnectTimeout: NodeJS.Timeout | null = null;\r\n  private isReconnecting = false;\r\n  private connectionPromise: Promise<void> | null = null;\r\n\r\n  public async connect(channelId: string): Promise<void> {\r\n    if (this.isReconnecting) {\r\n      console.log('Already attempting to reconnect...');\r\n      return;\r\n    }\r\n\r\n    if (this.connectionPromise) {\r\n      await this.connectionPromise;\r\n      if (this.isConnected() && this.isConnectedToChannel(channelId)) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    this.currentChannelId = channelId;\r\n    \r\n    try {\r\n      this.connectionPromise = new Promise((resolve, reject) => {\r\n        const token = getAuthToken();\r\n        if (!token) {\r\n          console.log('No authentication token found, skipping WebSocket connection');\r\n          resolve(); // Resolve without connecting - will retry when token is available\r\n          return;\r\n        }\r\n\r\n        console.log(`Connecting to WebSocket: ws://localhost:8000/ws/chat?token=${token}`);\r\n        this.socket = new WebSocket(`ws://localhost:8000/ws/chat?token=${token}`);\r\n\r\n        this.socket.onopen = async () => {\r\n          console.log('WebSocket connection opened');\r\n          this.reconnectAttempts = 0;\r\n          this.isReconnecting = false;\r\n\r\n          try {\r\n            await this.joinChannel(channelId);\r\n            resolve();\r\n          } catch (error) {\r\n            console.error('Failed to join channel:', error);\r\n            reject(error);\r\n          }\r\n        };\r\n\r\n        this.socket.onclose = (event) => {\r\n          console.log(`WebSocket disconnected with code: ${event.code}`);\r\n          this.socket = null;\r\n          this.joinedChannels.clear();\r\n\r\n          if (event.code !== 1000) {\r\n            this.attemptReconnect();\r\n          }\r\n        };\r\n\r\n        this.socket.onerror = () => {\r\n          const error = new Error('WebSocket connection error');\r\n          console.error('WebSocket error:', error);\r\n          this.handleError(error);\r\n        };\r\n\r\n        this.socket.onmessage = (event) => {\r\n          try {\r\n            const message = JSON.parse(event.data) as WebSocketMessage;\r\n            this.messageHandlers.forEach(handler => handler(message));\r\n          } catch (error) {\r\n            console.error('Error parsing WebSocket message:', error);\r\n          }\r\n        };\r\n      });\r\n\r\n      await this.connectionPromise;\r\n    } catch (error) {\r\n      console.error('WebSocket connection failed:', error);\r\n      this.handleError(error instanceof Error ? error : new Error('WebSocket connection failed'));\r\n      throw error;\r\n    } finally {\r\n      this.connectionPromise = null;\r\n    }\r\n  }\r\n\r\n  public async joinChannel(channelId: string): Promise<void> {\r\n    const token = getAuthToken();\r\n    if (!token) {\r\n      console.log('No authentication token found, skipping channel join');\r\n      return;\r\n    }\r\n\r\n    if (!this.isConnected()) {\r\n      await this.connect(channelId);\r\n      return;\r\n    }\r\n\r\n    if (this.isConnectedToChannel(channelId)) {\r\n      return;\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const joinMessage: WebSocketJoinMessage = {\r\n        type: 'join_channel',\r\n        channel_id: channelId\r\n      };\r\n\r\n      const timeoutId = setTimeout(() => {\r\n        reject(new Error('Channel join timeout'));\r\n      }, 5000);\r\n\r\n      const handleJoinResponse = (event: MessageEvent) => {\r\n        try {\r\n          const response = JSON.parse(event.data) as WebSocketJoinResponse;\r\n          \r\n          if (response.type === 'channel_joined' && response.channelId === channelId) {\r\n            clearTimeout(timeoutId);\r\n            this.joinedChannels.add(channelId);\r\n            this.socket?.removeEventListener('message', handleJoinResponse);\r\n            resolve();\r\n          } else if (response.type === 'channel_join_error') {\r\n            clearTimeout(timeoutId);\r\n            this.socket?.removeEventListener('message', handleJoinResponse);\r\n            reject(new Error(response.error || 'Failed to join channel'));\r\n          }\r\n        } catch (error) {\r\n          // Ignore messages that aren't join responses\r\n        }\r\n      };\r\n\r\n      this.socket?.addEventListener('message', handleJoinResponse);\r\n      this.socket?.send(JSON.stringify(joinMessage));\r\n    });\r\n  }\r\n\r\n  private handleError(error: Error): void {\r\n    console.error('WebSocket error:', error);\r\n    this.errorHandlers.forEach(handler => handler(error));\r\n  }\r\n\r\n  public isConnected(): boolean {\r\n    return this.socket !== null && this.socket.readyState === WebSocket.OPEN;\r\n  }\r\n\r\n  private isConnectedToChannel(channelId: string): boolean {\r\n    return this.isConnected() && this.joinedChannels.has(channelId);\r\n  }\r\n\r\n  public onMessage(handler: (message: WebSocketMessage) => void): () => void {\r\n    this.messageHandlers.push(handler);\r\n    return () => {\r\n      this.messageHandlers = this.messageHandlers.filter(h => h !== handler);\r\n    };\r\n  }\r\n\r\n  public onError(handler: (error: Error) => void): () => void {\r\n    this.errorHandlers.push(handler);\r\n    return () => {\r\n      this.errorHandlers = this.errorHandlers.filter(h => h !== handler);\r\n    };\r\n  }\r\n\r\n  public disconnect(): void {\r\n    if (this.socket) {\r\n      this.socket.close(1000);\r\n      this.socket = null;\r\n    }\r\n    this.joinedChannels.clear();\r\n    this.messageHandlers = [];\r\n    this.errorHandlers = [];\r\n    if (this.reconnectTimeout) {\r\n      clearTimeout(this.reconnectTimeout);\r\n      this.reconnectTimeout = null;\r\n    }\r\n  }\r\n\r\n  private attemptReconnect(): void {\r\n    if (this.isReconnecting || this.reconnectAttempts >= this.maxReconnectAttempts) {\r\n      return;\r\n    }\r\n\r\n    this.isReconnecting = true;\r\n    this.reconnectAttempts++;\r\n\r\n    console.log(`Attempting to reconnect (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})...`);\r\n\r\n    if (this.currentChannelId) {\r\n      const backoffTime = Math.min(1000 * Math.pow(2, this.reconnectAttempts - 1), 10000);\r\n      this.reconnectTimeout = setTimeout(() => {\r\n        this.connect(this.currentChannelId!).catch(error => {\r\n          console.error('Reconnection failed:', error);\r\n          if (this.reconnectAttempts < this.maxReconnectAttempts) {\r\n            this.attemptReconnect();\r\n          } else {\r\n            this.isReconnecting = false;\r\n            this.handleError(new Error('Max reconnection attempts reached'));\r\n          }\r\n        });\r\n      }, backoffTime);\r\n    }\r\n  }\r\n\r\n  public getChatSocketState(): number {\r\n    return this.socket?.readyState || WebSocket.CLOSED;\r\n  }\r\n\r\n  public async sendMessage(channelId: string, content: string): Promise<void> {\r\n    // If not connected to the right channel, connect first\r\n    if (!this.isConnectedToChannel(channelId)) {\r\n      try {\r\n        await this.connect(channelId);\r\n      } catch (error) {\r\n        console.error('Failed to connect to channel:', error);\r\n        throw new Error('Failed to send message: Could not connect to channel');\r\n      }\r\n    }\r\n\r\n    if (!this.isConnected()) {\r\n      throw new Error('WebSocket is not connected');\r\n    }\r\n\r\n    const message = {\r\n      type: 'message',\r\n      channel_id: channelId,\r\n      content: content\r\n    };\r\n\r\n    try {\r\n      this.socket!.send(JSON.stringify(message));\r\n    } catch (error) {\r\n      console.error('Failed to send message:', error);\r\n      throw new Error('Failed to send message');\r\n    }\r\n  }\r\n}\r\n\r\nconst wsService = new WebSocketService();\r\nexport default wsService; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}