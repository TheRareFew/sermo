{"ast":null,"code":"import { getAuthToken } from '../api/auth';\nimport { store } from '../../store';\nimport { addMessage, setReplies } from '../../store/messages/messagesSlice';\nclass WebSocketService {\n  constructor() {\n    this.socket = null;\n    this.messageHandlers = [];\n    this.errorHandlers = [];\n    this.currentChannelId = null;\n    this.joinedChannels = new Set();\n    this.processedMessageIds = new Set();\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectTimeout = null;\n    this.isReconnecting = false;\n    this.messageQueue = [];\n    this.joinChannelResolvers = new Map();\n    this.pendingChannels = new Set();\n    this.handleMessage = event => {\n      try {\n        const data = JSON.parse(event.data);\n        console.log('Received WebSocket message:', data);\n        if (data.type === 'message' || data.type === 'new_reply') {\n          if (!this.processedMessageIds.has(data.message.id.toString())) {\n            this.processedMessageIds.add(data.message.id.toString());\n            const transformedMessage = {\n              id: data.message.id.toString(),\n              content: data.message.content,\n              channelId: data.message.channel_id.toString(),\n              userId: data.message.sender_id.toString(),\n              createdAt: data.message.created_at,\n              updatedAt: data.message.created_at,\n              reactions: [],\n              attachments: [],\n              replyCount: data.message.reply_count || 0,\n              isExpanded: false,\n              ...(data.type === 'new_reply' && data.parentId ? {\n                parentId: data.parentId.toString()\n              } : {})\n            };\n            if (data.type === 'new_reply' && data.parentId) {\n              // For replies, update the parent message's replies array and replyCount\n              store.dispatch(setReplies({\n                channelId: transformedMessage.channelId,\n                messageId: data.parentId.toString(),\n                replies: [transformedMessage]\n              }));\n            } else {\n              // Only dispatch addMessage for non-reply messages\n              store.dispatch(addMessage(transformedMessage));\n            }\n          }\n        } else if (data.type === 'channel_joined') {\n          const resolvers = this.joinChannelResolvers.get(String(data.channel_id));\n          if (resolvers) {\n            console.log('Successfully joined channel:', data.channel_id);\n            this.joinedChannels.add(String(data.channel_id));\n            resolvers.resolve();\n            this.joinChannelResolvers.delete(String(data.channel_id));\n            this.processMessageQueue().catch(error => {\n              console.error('Error processing message queue after join:', error);\n            });\n          }\n        } else if (data.type === 'channel_left') {\n          const channelId = String(data.channel_id);\n          this.joinedChannels.delete(channelId);\n          if (channelId === this.currentChannelId) {\n            this.currentChannelId = null;\n          }\n        } else if (data.type === 'error') {\n          var _data$message;\n          console.error('WebSocket error message:', data);\n\n          // Handle channel-specific errors\n          if (data.code === 'channel_not_found' || (_data$message = data.message) !== null && _data$message !== void 0 && _data$message.includes('channel')) {\n            const channelId = this.currentChannelId;\n            if (channelId) {\n              const resolvers = this.joinChannelResolvers.get(channelId);\n              if (resolvers) {\n                resolvers.reject(new Error(data.message || 'Failed to join channel'));\n                this.joinChannelResolvers.delete(channelId);\n              }\n            }\n          }\n          this.handleError({\n            name: data.code || 'UNKNOWN_ERROR',\n            message: data.message || data.content || 'Unknown error occurred'\n          });\n        } else if (data.type === 'user_status' || data.type === 'presence_update') {\n          console.log('User status update:', data);\n        }\n        this.messageHandlers.forEach(handler => {\n          try {\n            handler(data);\n          } catch (error) {\n            console.error('Error in message handler:', error);\n          }\n        });\n      } catch (error) {\n        console.error('Error handling WebSocket message:', error);\n        this.handleError(error);\n      }\n    };\n  }\n  getReconnectDelay() {\n    // Exponential backoff: 1s, 2s, 4s, 8s, 16s\n    return Math.min(1000 * Math.pow(2, this.reconnectAttempts), 16000);\n  }\n  async attemptReconnect(channelId) {\n    if (this.isReconnecting) {\n      console.log('Already attempting to reconnect...');\n      return;\n    }\n    this.isReconnecting = true;\n    if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n      console.error('Max reconnection attempts reached');\n      this.errorHandlers.forEach(handler => handler({\n        code: 'MAX_RECONNECT_ATTEMPTS',\n        message: 'Unable to reconnect after multiple attempts. Please refresh the page.'\n      }));\n      this.isReconnecting = false;\n      return;\n    }\n    console.log(`Attempting to reconnect (attempt ${this.reconnectAttempts + 1}/${this.maxReconnectAttempts})...`);\n    try {\n      // Add a small delay before reconnecting\n      await new Promise(resolve => setTimeout(resolve, this.getReconnectDelay()));\n\n      // Store the current channels before reconnecting\n      const channelsToRejoin = Array.from(this.joinedChannels);\n\n      // Connect to the initial channel\n      await this.connect(channelId);\n\n      // After successful connection, join all previously joined channels\n      for (const channel of channelsToRejoin) {\n        if (channel !== channelId) {\n          try {\n            await this.joinChannel(channel);\n          } catch (error) {\n            console.error(`Failed to rejoin channel ${channel}:`, error);\n          }\n        }\n      }\n      this.reconnectAttempts = 0;\n      this.isReconnecting = false;\n    } catch (error) {\n      this.reconnectAttempts++;\n      this.isReconnecting = false;\n\n      // Schedule next reconnection attempt\n      const delay = this.getReconnectDelay();\n      console.log(`Scheduling next reconnection attempt in ${delay}ms`);\n      this.reconnectTimeout = setTimeout(() => {\n        this.attemptReconnect(channelId);\n      }, delay);\n    }\n  }\n  handleError(error) {\n    console.error('WebSocket error:', error);\n    const errorObj = {\n      code: error instanceof Error ? error.name : 'UNKNOWN_ERROR',\n      message: error instanceof Error ? error.message : String(error)\n    };\n    this.errorHandlers.forEach(handler => {\n      try {\n        handler(errorObj);\n      } catch (handlerError) {\n        console.error('Error in error handler:', handlerError);\n      }\n    });\n  }\n  connect(channelId) {\n    return new Promise((resolve, reject) => {\n      var _this$socket, _this$socket2;\n      // Clear any existing reconnection timeout\n      if (this.reconnectTimeout) {\n        clearTimeout(this.reconnectTimeout);\n        this.reconnectTimeout = null;\n      }\n\n      // If already connected to this channel, do nothing\n      if (((_this$socket = this.socket) === null || _this$socket === void 0 ? void 0 : _this$socket.readyState) === WebSocket.OPEN && this.joinedChannels.has(channelId)) {\n        console.log('WebSocket already connected to channel', channelId);\n        this.currentChannelId = channelId;\n        resolve();\n        return;\n      }\n\n      // If socket is open, just join the new channel\n      if (((_this$socket2 = this.socket) === null || _this$socket2 === void 0 ? void 0 : _this$socket2.readyState) === WebSocket.OPEN) {\n        console.log('Socket open, joining new channel:', channelId);\n        this.joinChannel(channelId).then(() => {\n          this.currentChannelId = channelId;\n          resolve();\n        }).catch(error => {\n          console.error('Failed to join channel:', error);\n          reject(error);\n        });\n        return;\n      }\n      const token = getAuthToken();\n      if (!token) {\n        const error = new Error('No auth token available for WebSocket connection');\n        this.handleError(error);\n        reject(error);\n        return;\n      }\n      const baseWsUrl = process.env.REACT_APP_WS_URL || 'ws://localhost:8000/ws';\n      const wsUrl = `${baseWsUrl}/chat?token=${token}`;\n      console.log('Connecting to WebSocket:', wsUrl);\n      try {\n        this.socket = new WebSocket(wsUrl);\n        this.currentChannelId = channelId;\n        this.processedMessageIds.clear();\n        this.pendingChannels.clear();\n        this.pendingChannels.add(channelId);\n        let hasResolved = false;\n        let connectionTimeout;\n\n        // Set a connection timeout\n        connectionTimeout = setTimeout(() => {\n          if (!hasResolved) {\n            var _this$socket3;\n            console.error('WebSocket connection timeout');\n            this.handleError('Connection timeout. Attempting to reconnect...');\n            (_this$socket3 = this.socket) === null || _this$socket3 === void 0 ? void 0 : _this$socket3.close();\n            this.attemptReconnect(channelId);\n          }\n        }, 10000);\n        this.socket.onopen = async () => {\n          clearTimeout(connectionTimeout);\n          console.log('WebSocket connection opened');\n\n          // Add a small delay before joining the channel to ensure the connection is stable\n          await new Promise(resolve => setTimeout(resolve, 500));\n          try {\n            await this.joinChannel(channelId);\n            this.joinedChannels.add(channelId);\n            this.pendingChannels.delete(channelId);\n            hasResolved = true;\n            resolve();\n            // Process any queued messages\n            this.processMessageQueue().catch(error => {\n              console.error('Error processing message queue:', error);\n            });\n          } catch (error) {\n            console.error('Failed to join channel:', error);\n            this.handleError('Failed to join channel. Attempting to reconnect...');\n            this.attemptReconnect(channelId);\n          }\n        };\n        this.socket.onmessage = this.handleMessage;\n        this.socket.onerror = event => {\n          console.error('WebSocket error:', event);\n          this.handleError('Connection error. Attempting to reconnect...');\n        };\n        this.socket.onclose = event => {\n          clearTimeout(connectionTimeout);\n          console.log('WebSocket disconnected with code:', event.code);\n          const shouldReconnect = !hasResolved || event.code !== 1000 && event.code !== 1001;\n          this.socket = null;\n          this.pendingChannels.clear();\n          switch (event.code) {\n            case 1000: // Normal closure\n            case 1001:\n              // Going away\n              this.joinedChannels.clear();\n              if (!hasResolved) {\n                resolve();\n              }\n              break;\n            case 1003:\n              // Unsupported\n              this.handleError('WebSocket connection not supported');\n              if (!hasResolved) {\n                reject(new Error('WebSocket connection not supported'));\n              }\n              break;\n            case 4001:\n              // Channel access denied\n              this.handleError('Access to the channel was denied');\n              if (!hasResolved) {\n                reject(new Error('Access to the channel was denied'));\n              }\n              break;\n            case 4002:\n              // Authentication failed\n              this.handleError('Authentication failed');\n              if (!hasResolved) {\n                reject(new Error('Authentication failed'));\n              }\n              break;\n            default:\n              if (shouldReconnect) {\n                console.log('Abnormal closure, attempting to reconnect...');\n                this.attemptReconnect(this.currentChannelId || channelId);\n              }\n          }\n        };\n      } catch (error) {\n        console.error('Error creating WebSocket:', error);\n        this.handleError(error);\n        this.attemptReconnect(channelId);\n      }\n    });\n  }\n  disconnect() {\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n    if (this.socket) {\n      // Leave all joined channels\n      Array.from(this.joinedChannels).forEach(channelId => {\n        try {\n          var _this$socket4;\n          const message = {\n            type: 'leave_channel',\n            channel_id: channelId\n          };\n          (_this$socket4 = this.socket) === null || _this$socket4 === void 0 ? void 0 : _this$socket4.send(JSON.stringify(message));\n        } catch (error) {\n          console.error(`Error leaving channel ${channelId}:`, error);\n        }\n      });\n      this.socket.close(1000); // Normal closure\n      this.socket = null;\n      this.currentChannelId = null;\n      this.joinedChannels.clear();\n      this.reconnectAttempts = 0;\n      this.isReconnecting = false;\n    }\n  }\n  async processMessageQueue() {\n    while (this.messageQueue.length > 0 && ((_this$socket5 = this.socket) === null || _this$socket5 === void 0 ? void 0 : _this$socket5.readyState) === WebSocket.OPEN) {\n      var _this$socket5;\n      const message = this.messageQueue.shift();\n      if (message) {\n        try {\n          await this.sendMessageImmediate(message.channelId, message.content);\n        } catch (error) {\n          console.error('Failed to send queued message:', error);\n        }\n      }\n    }\n  }\n  sendMessageImmediate(channelId, content) {\n    var _this$socket6;\n    if (((_this$socket6 = this.socket) === null || _this$socket6 === void 0 ? void 0 : _this$socket6.readyState) !== WebSocket.OPEN) {\n      throw new Error('WebSocket is not connected');\n    }\n    const message = {\n      type: 'message',\n      channel_id: channelId,\n      content: content\n    };\n    this.socket.send(JSON.stringify(message));\n  }\n  async sendMessage(channelId, content) {\n    var _this$socket7;\n    // If not connected to the right channel, connect first\n    if (this.currentChannelId !== channelId) {\n      console.log('Connecting to channel before sending message');\n      try {\n        await this.connect(channelId);\n      } catch (error) {\n        console.error('Failed to connect to channel:', error);\n        this.handleError('Failed to send message: Could not connect to channel');\n        return;\n      }\n    }\n    if (((_this$socket7 = this.socket) === null || _this$socket7 === void 0 ? void 0 : _this$socket7.readyState) === WebSocket.OPEN) {\n      try {\n        await this.sendMessageImmediate(channelId, content);\n      } catch (error) {\n        console.error('Failed to send message:', error);\n        // Queue the message for retry\n        this.messageQueue.push({\n          channelId,\n          content\n        });\n        this.handleError('Message will be sent when connection is restored');\n      }\n    } else {\n      // Queue the message for later\n      this.messageQueue.push({\n        channelId,\n        content\n      });\n      this.handleError('Message will be sent when connection is restored');\n    }\n  }\n  async joinChannel(channelId) {\n    return new Promise((resolve, reject) => {\n      if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {\n        reject(new Error('WebSocket is not connected'));\n        return;\n      }\n\n      // If already joined or pending, don't try to join again\n      if (this.joinedChannels.has(channelId) || this.pendingChannels.has(channelId)) {\n        console.log('Channel already joined or pending:', channelId);\n        resolve();\n        return;\n      }\n      this.pendingChannels.add(channelId);\n\n      // Set up a timeout for the join operation\n      const joinTimeout = setTimeout(() => {\n        this.joinChannelResolvers.delete(channelId);\n        this.pendingChannels.delete(channelId);\n        reject(new Error('Join channel timeout'));\n      }, 5000);\n\n      // Store the resolver\n      this.joinChannelResolvers.set(channelId, {\n        resolve: () => {\n          clearTimeout(joinTimeout);\n          this.joinChannelResolvers.delete(channelId);\n          this.pendingChannels.delete(channelId);\n          this.joinedChannels.add(channelId);\n          resolve();\n        },\n        reject: error => {\n          clearTimeout(joinTimeout);\n          this.joinChannelResolvers.delete(channelId);\n          this.pendingChannels.delete(channelId);\n          reject(error);\n        }\n      });\n      try {\n        const message = {\n          type: 'join_channel',\n          channel_id: channelId\n        };\n        this.socket.send(JSON.stringify(message));\n      } catch (error) {\n        clearTimeout(joinTimeout);\n        this.joinChannelResolvers.delete(channelId);\n        this.pendingChannels.delete(channelId);\n        reject(error);\n      }\n    });\n  }\n  leaveChannel(channelId) {\n    var _this$socket8;\n    if (((_this$socket8 = this.socket) === null || _this$socket8 === void 0 ? void 0 : _this$socket8.readyState) === WebSocket.OPEN && this.joinedChannels.has(channelId)) {\n      const message = {\n        type: 'leave_channel',\n        channel_id: channelId\n      };\n      this.socket.send(JSON.stringify(message));\n      this.joinedChannels.delete(channelId);\n\n      // If this was the current channel, set current to null\n      if (this.currentChannelId === channelId) {\n        this.currentChannelId = null;\n      }\n    }\n  }\n  isChannelJoined(channelId) {\n    return this.joinedChannels.has(channelId);\n  }\n  onMessage(handler) {\n    this.messageHandlers.push(handler);\n    return () => {\n      this.messageHandlers = this.messageHandlers.filter(h => h !== handler);\n    };\n  }\n  onError(handler) {\n    this.errorHandlers.push(handler);\n    return () => {\n      this.errorHandlers = this.errorHandlers.filter(h => h !== handler);\n    };\n  }\n  getChatSocketState() {\n    var _this$socket9;\n    return ((_this$socket9 = this.socket) === null || _this$socket9 === void 0 ? void 0 : _this$socket9.readyState) || WebSocket.CLOSED;\n  }\n  getCurrentChannelId() {\n    return this.currentChannelId;\n  }\n  // Helper method to check if connected to a channel\n  isConnectedToChannel(channelId) {\n    var _this$socket10;\n    return ((_this$socket10 = this.socket) === null || _this$socket10 === void 0 ? void 0 : _this$socket10.readyState) === WebSocket.OPEN && this.joinedChannels.has(channelId);\n  }\n\n  // Helper method to ensure connection is ready\n  ensureConnected() {\n    if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {\n      throw new Error('WebSocket is not connected');\n    }\n  }\n}\nconst wsService = new WebSocketService();\nexport default wsService;","map":{"version":3,"names":["getAuthToken","store","addMessage","setReplies","WebSocketService","constructor","socket","messageHandlers","errorHandlers","currentChannelId","joinedChannels","Set","processedMessageIds","reconnectAttempts","maxReconnectAttempts","reconnectTimeout","isReconnecting","messageQueue","joinChannelResolvers","Map","pendingChannels","handleMessage","event","data","JSON","parse","console","log","type","has","message","id","toString","add","transformedMessage","content","channelId","channel_id","userId","sender_id","createdAt","created_at","updatedAt","reactions","attachments","replyCount","reply_count","isExpanded","parentId","dispatch","messageId","replies","resolvers","get","String","resolve","delete","processMessageQueue","catch","error","_data$message","code","includes","reject","Error","handleError","name","forEach","handler","getReconnectDelay","Math","min","pow","attemptReconnect","Promise","setTimeout","channelsToRejoin","Array","from","connect","channel","joinChannel","delay","errorObj","handlerError","_this$socket","_this$socket2","clearTimeout","readyState","WebSocket","OPEN","then","token","baseWsUrl","process","env","REACT_APP_WS_URL","wsUrl","clear","hasResolved","connectionTimeout","_this$socket3","close","onopen","onmessage","onerror","onclose","shouldReconnect","disconnect","_this$socket4","send","stringify","length","_this$socket5","shift","sendMessageImmediate","_this$socket6","sendMessage","_this$socket7","push","joinTimeout","set","leaveChannel","_this$socket8","isChannelJoined","onMessage","filter","h","onError","getChatSocketState","_this$socket9","CLOSED","getCurrentChannelId","isConnectedToChannel","_this$socket10","ensureConnected","wsService"],"sources":["Z:/GAUNTLET/projects/SERMO/sermo-app/frontend/src/services/websocket/index.ts"],"sourcesContent":["import { WebSocketMessage, WebSocketChannelJoinMessage, WebSocketChannelMessage, StoreMessage } from '../../types';\r\nimport { getAuthToken } from '../api/auth';\r\nimport { store } from '../../store';\r\nimport { addMessage, setReplies } from '../../store/messages/messagesSlice';\r\n\r\nclass WebSocketService {\r\n  private socket: WebSocket | null = null;\r\n  private messageHandlers: ((message: WebSocketMessage) => void)[] = [];\r\n  private errorHandlers: ((error: { code: string; message: string }) => void)[] = [];\r\n  private currentChannelId: string | null = null;\r\n  private joinedChannels: Set<string> = new Set();\r\n  private processedMessageIds: Set<string> = new Set();\r\n  private reconnectAttempts: number = 0;\r\n  private maxReconnectAttempts: number = 5;\r\n  private reconnectTimeout: NodeJS.Timeout | null = null;\r\n  private isReconnecting: boolean = false;\r\n  private messageQueue: { channelId: string; content: string }[] = [];\r\n  private joinChannelResolvers: Map<string, { resolve: () => void; reject: (error: Error) => void }> = new Map();\r\n  private pendingChannels: Set<string> = new Set();\r\n\r\n  private getReconnectDelay(): number {\r\n    // Exponential backoff: 1s, 2s, 4s, 8s, 16s\r\n    return Math.min(1000 * Math.pow(2, this.reconnectAttempts), 16000);\r\n  }\r\n\r\n  private async attemptReconnect(channelId: string) {\r\n    if (this.isReconnecting) {\r\n      console.log('Already attempting to reconnect...');\r\n      return;\r\n    }\r\n\r\n    this.isReconnecting = true;\r\n    \r\n    if (this.reconnectAttempts >= this.maxReconnectAttempts) {\r\n      console.error('Max reconnection attempts reached');\r\n      this.errorHandlers.forEach(handler => handler({\r\n        code: 'MAX_RECONNECT_ATTEMPTS',\r\n        message: 'Unable to reconnect after multiple attempts. Please refresh the page.'\r\n      }));\r\n      this.isReconnecting = false;\r\n      return;\r\n    }\r\n\r\n    console.log(`Attempting to reconnect (attempt ${this.reconnectAttempts + 1}/${this.maxReconnectAttempts})...`);\r\n    \r\n    try {\r\n      // Add a small delay before reconnecting\r\n      await new Promise(resolve => setTimeout(resolve, this.getReconnectDelay()));\r\n      \r\n      // Store the current channels before reconnecting\r\n      const channelsToRejoin = Array.from(this.joinedChannels);\r\n      \r\n      // Connect to the initial channel\r\n      await this.connect(channelId);\r\n      \r\n      // After successful connection, join all previously joined channels\r\n      for (const channel of channelsToRejoin) {\r\n        if (channel !== channelId) {\r\n          try {\r\n            await this.joinChannel(channel);\r\n          } catch (error) {\r\n            console.error(`Failed to rejoin channel ${channel}:`, error);\r\n          }\r\n        }\r\n      }\r\n      \r\n      this.reconnectAttempts = 0;\r\n      this.isReconnecting = false;\r\n    } catch (error) {\r\n      this.reconnectAttempts++;\r\n      this.isReconnecting = false;\r\n      \r\n      // Schedule next reconnection attempt\r\n      const delay = this.getReconnectDelay();\r\n      console.log(`Scheduling next reconnection attempt in ${delay}ms`);\r\n      this.reconnectTimeout = setTimeout(() => {\r\n        this.attemptReconnect(channelId);\r\n      }, delay);\r\n    }\r\n  }\r\n\r\n  private handleError(error: unknown): void {\r\n    console.error('WebSocket error:', error);\r\n    const errorObj = {\r\n      code: error instanceof Error ? error.name : 'UNKNOWN_ERROR',\r\n      message: error instanceof Error ? error.message : String(error)\r\n    };\r\n    this.errorHandlers.forEach(handler => {\r\n      try {\r\n        handler(errorObj);\r\n      } catch (handlerError) {\r\n        console.error('Error in error handler:', handlerError);\r\n      }\r\n    });\r\n  }\r\n\r\n  connect(channelId: string) {\r\n    return new Promise<void>((resolve, reject) => {\r\n      // Clear any existing reconnection timeout\r\n      if (this.reconnectTimeout) {\r\n        clearTimeout(this.reconnectTimeout);\r\n        this.reconnectTimeout = null;\r\n      }\r\n\r\n      // If already connected to this channel, do nothing\r\n      if (this.socket?.readyState === WebSocket.OPEN && this.joinedChannels.has(channelId)) {\r\n        console.log('WebSocket already connected to channel', channelId);\r\n        this.currentChannelId = channelId;\r\n        resolve();\r\n        return;\r\n      }\r\n\r\n      // If socket is open, just join the new channel\r\n      if (this.socket?.readyState === WebSocket.OPEN) {\r\n        console.log('Socket open, joining new channel:', channelId);\r\n        this.joinChannel(channelId)\r\n          .then(() => {\r\n            this.currentChannelId = channelId;\r\n            resolve();\r\n          })\r\n          .catch(error => {\r\n            console.error('Failed to join channel:', error);\r\n            reject(error);\r\n          });\r\n        return;\r\n      }\r\n\r\n      const token = getAuthToken();\r\n      if (!token) {\r\n        const error = new Error('No auth token available for WebSocket connection');\r\n        this.handleError(error);\r\n        reject(error);\r\n        return;\r\n      }\r\n\r\n      const baseWsUrl = process.env.REACT_APP_WS_URL || 'ws://localhost:8000/ws';\r\n      const wsUrl = `${baseWsUrl}/chat?token=${token}`;\r\n      console.log('Connecting to WebSocket:', wsUrl);\r\n      \r\n      try {\r\n        this.socket = new WebSocket(wsUrl);\r\n        this.currentChannelId = channelId;\r\n        this.processedMessageIds.clear();\r\n        this.pendingChannels.clear();\r\n        this.pendingChannels.add(channelId);\r\n\r\n        let hasResolved = false;\r\n        let connectionTimeout: NodeJS.Timeout;\r\n\r\n        // Set a connection timeout\r\n        connectionTimeout = setTimeout(() => {\r\n          if (!hasResolved) {\r\n            console.error('WebSocket connection timeout');\r\n            this.handleError('Connection timeout. Attempting to reconnect...');\r\n            this.socket?.close();\r\n            this.attemptReconnect(channelId);\r\n          }\r\n        }, 10000);\r\n\r\n        this.socket.onopen = async () => {\r\n          clearTimeout(connectionTimeout);\r\n          console.log('WebSocket connection opened');\r\n          \r\n          // Add a small delay before joining the channel to ensure the connection is stable\r\n          await new Promise(resolve => setTimeout(resolve, 500));\r\n          \r\n          try {\r\n            await this.joinChannel(channelId);\r\n            this.joinedChannels.add(channelId);\r\n            this.pendingChannels.delete(channelId);\r\n            hasResolved = true;\r\n            resolve();\r\n            // Process any queued messages\r\n            this.processMessageQueue().catch(error => {\r\n              console.error('Error processing message queue:', error);\r\n            });\r\n          } catch (error) {\r\n            console.error('Failed to join channel:', error);\r\n            this.handleError('Failed to join channel. Attempting to reconnect...');\r\n            this.attemptReconnect(channelId);\r\n          }\r\n        };\r\n\r\n        this.socket.onmessage = this.handleMessage;\r\n\r\n        this.socket.onerror = (event: Event) => {\r\n          console.error('WebSocket error:', event);\r\n          this.handleError('Connection error. Attempting to reconnect...');\r\n        };\r\n\r\n        this.socket.onclose = (event: CloseEvent) => {\r\n          clearTimeout(connectionTimeout);\r\n          console.log('WebSocket disconnected with code:', event.code);\r\n          \r\n          const shouldReconnect = !hasResolved || (event.code !== 1000 && event.code !== 1001);\r\n          \r\n          this.socket = null;\r\n          this.pendingChannels.clear();\r\n          \r\n          switch (event.code) {\r\n            case 1000: // Normal closure\r\n            case 1001: // Going away\r\n              this.joinedChannels.clear();\r\n              if (!hasResolved) {\r\n                resolve();\r\n              }\r\n              break;\r\n            case 1003: // Unsupported\r\n              this.handleError('WebSocket connection not supported');\r\n              if (!hasResolved) {\r\n                reject(new Error('WebSocket connection not supported'));\r\n              }\r\n              break;\r\n            case 4001: // Channel access denied\r\n              this.handleError('Access to the channel was denied');\r\n              if (!hasResolved) {\r\n                reject(new Error('Access to the channel was denied'));\r\n              }\r\n              break;\r\n            case 4002: // Authentication failed\r\n              this.handleError('Authentication failed');\r\n              if (!hasResolved) {\r\n                reject(new Error('Authentication failed'));\r\n              }\r\n              break;\r\n            default:\r\n              if (shouldReconnect) {\r\n                console.log('Abnormal closure, attempting to reconnect...');\r\n                this.attemptReconnect(this.currentChannelId || channelId);\r\n              }\r\n          }\r\n        };\r\n      } catch (error) {\r\n        console.error('Error creating WebSocket:', error);\r\n        this.handleError(error);\r\n        this.attemptReconnect(channelId);\r\n      }\r\n    });\r\n  }\r\n\r\n  disconnect() {\r\n    if (this.reconnectTimeout) {\r\n      clearTimeout(this.reconnectTimeout);\r\n      this.reconnectTimeout = null;\r\n    }\r\n    \r\n    if (this.socket) {\r\n      // Leave all joined channels\r\n      Array.from(this.joinedChannels).forEach(channelId => {\r\n        try {\r\n          const message = {\r\n            type: 'leave_channel',\r\n            channel_id: channelId\r\n          };\r\n          this.socket?.send(JSON.stringify(message));\r\n        } catch (error) {\r\n          console.error(`Error leaving channel ${channelId}:`, error);\r\n        }\r\n      });\r\n      \r\n      this.socket.close(1000); // Normal closure\r\n      this.socket = null;\r\n      this.currentChannelId = null;\r\n      this.joinedChannels.clear();\r\n      this.reconnectAttempts = 0;\r\n      this.isReconnecting = false;\r\n    }\r\n  }\r\n\r\n  private async processMessageQueue() {\r\n    while (this.messageQueue.length > 0 && this.socket?.readyState === WebSocket.OPEN) {\r\n      const message = this.messageQueue.shift();\r\n      if (message) {\r\n        try {\r\n          await this.sendMessageImmediate(message.channelId, message.content);\r\n        } catch (error) {\r\n          console.error('Failed to send queued message:', error);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private sendMessageImmediate(channelId: string, content: string) {\r\n    if (this.socket?.readyState !== WebSocket.OPEN) {\r\n      throw new Error('WebSocket is not connected');\r\n    }\r\n\r\n    const message = {\r\n      type: 'message',\r\n      channel_id: channelId,\r\n      content: content\r\n    };\r\n    this.socket.send(JSON.stringify(message));\r\n  }\r\n\r\n  async sendMessage(channelId: string, content: string) {\r\n    // If not connected to the right channel, connect first\r\n    if (this.currentChannelId !== channelId) {\r\n      console.log('Connecting to channel before sending message');\r\n      try {\r\n        await this.connect(channelId);\r\n      } catch (error) {\r\n        console.error('Failed to connect to channel:', error);\r\n        this.handleError('Failed to send message: Could not connect to channel');\r\n        return;\r\n      }\r\n    }\r\n\r\n    if (this.socket?.readyState === WebSocket.OPEN) {\r\n      try {\r\n        await this.sendMessageImmediate(channelId, content);\r\n      } catch (error) {\r\n        console.error('Failed to send message:', error);\r\n        // Queue the message for retry\r\n        this.messageQueue.push({ channelId, content });\r\n        this.handleError('Message will be sent when connection is restored');\r\n      }\r\n    } else {\r\n      // Queue the message for later\r\n      this.messageQueue.push({ channelId, content });\r\n      this.handleError('Message will be sent when connection is restored');\r\n    }\r\n  }\r\n\r\n  async joinChannel(channelId: string): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {\r\n        reject(new Error('WebSocket is not connected'));\r\n        return;\r\n      }\r\n\r\n      // If already joined or pending, don't try to join again\r\n      if (this.joinedChannels.has(channelId) || this.pendingChannels.has(channelId)) {\r\n        console.log('Channel already joined or pending:', channelId);\r\n        resolve();\r\n        return;\r\n      }\r\n\r\n      this.pendingChannels.add(channelId);\r\n\r\n      // Set up a timeout for the join operation\r\n      const joinTimeout = setTimeout(() => {\r\n        this.joinChannelResolvers.delete(channelId);\r\n        this.pendingChannels.delete(channelId);\r\n        reject(new Error('Join channel timeout'));\r\n      }, 5000);\r\n\r\n      // Store the resolver\r\n      this.joinChannelResolvers.set(channelId, {\r\n        resolve: () => {\r\n          clearTimeout(joinTimeout);\r\n          this.joinChannelResolvers.delete(channelId);\r\n          this.pendingChannels.delete(channelId);\r\n          this.joinedChannels.add(channelId);\r\n          resolve();\r\n        },\r\n        reject: (error: Error) => {\r\n          clearTimeout(joinTimeout);\r\n          this.joinChannelResolvers.delete(channelId);\r\n          this.pendingChannels.delete(channelId);\r\n          reject(error);\r\n        }\r\n      });\r\n\r\n      try {\r\n        const message = {\r\n          type: 'join_channel',\r\n          channel_id: channelId\r\n        };\r\n        this.socket.send(JSON.stringify(message));\r\n      } catch (error) {\r\n        clearTimeout(joinTimeout);\r\n        this.joinChannelResolvers.delete(channelId);\r\n        this.pendingChannels.delete(channelId);\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  leaveChannel(channelId: string) {\r\n    if (this.socket?.readyState === WebSocket.OPEN && this.joinedChannels.has(channelId)) {\r\n      const message = {\r\n        type: 'leave_channel',\r\n        channel_id: channelId\r\n      };\r\n      this.socket.send(JSON.stringify(message));\r\n      this.joinedChannels.delete(channelId);\r\n      \r\n      // If this was the current channel, set current to null\r\n      if (this.currentChannelId === channelId) {\r\n        this.currentChannelId = null;\r\n      }\r\n    }\r\n  }\r\n\r\n  isChannelJoined(channelId: string): boolean {\r\n    return this.joinedChannels.has(channelId);\r\n  }\r\n\r\n  onMessage(handler: (message: WebSocketMessage) => void) {\r\n    this.messageHandlers.push(handler);\r\n    return () => {\r\n      this.messageHandlers = this.messageHandlers.filter(h => h !== handler);\r\n    };\r\n  }\r\n\r\n  onError(handler: (error: { code: string; message: string }) => void) {\r\n    this.errorHandlers.push(handler);\r\n    return () => {\r\n      this.errorHandlers = this.errorHandlers.filter(h => h !== handler);\r\n    };\r\n  }\r\n\r\n  getChatSocketState() {\r\n    return this.socket?.readyState || WebSocket.CLOSED;\r\n  }\r\n\r\n  getCurrentChannelId() {\r\n    return this.currentChannelId;\r\n  }\r\n\r\n  private handleMessage = (event: MessageEvent) => {\r\n    try {\r\n      const data = JSON.parse(event.data) as WebSocketMessage;\r\n      console.log('Received WebSocket message:', data);\r\n\r\n      if (data.type === 'message' || data.type === 'new_reply') {\r\n        if (!this.processedMessageIds.has(data.message.id.toString())) {\r\n          this.processedMessageIds.add(data.message.id.toString());\r\n          const transformedMessage: StoreMessage = {\r\n            id: data.message.id.toString(),\r\n            content: data.message.content,\r\n            channelId: data.message.channel_id.toString(),\r\n            userId: data.message.sender_id.toString(),\r\n            createdAt: data.message.created_at,\r\n            updatedAt: data.message.created_at,\r\n            reactions: [],\r\n            attachments: [],\r\n            replyCount: data.message.reply_count || 0,\r\n            isExpanded: false,\r\n            ...(data.type === 'new_reply' && data.parentId ? { parentId: data.parentId.toString() } : {})\r\n          };\r\n\r\n          if (data.type === 'new_reply' && data.parentId) {\r\n            // For replies, update the parent message's replies array and replyCount\r\n            store.dispatch(setReplies({\r\n              channelId: transformedMessage.channelId,\r\n              messageId: data.parentId.toString(),\r\n              replies: [transformedMessage]\r\n            }));\r\n          } else {\r\n            // Only dispatch addMessage for non-reply messages\r\n            store.dispatch(addMessage(transformedMessage));\r\n          }\r\n        }\r\n      } else if (data.type === 'channel_joined') {\r\n        const resolvers = this.joinChannelResolvers.get(String(data.channel_id));\r\n        if (resolvers) {\r\n          console.log('Successfully joined channel:', data.channel_id);\r\n          this.joinedChannels.add(String(data.channel_id));\r\n          resolvers.resolve();\r\n          this.joinChannelResolvers.delete(String(data.channel_id));\r\n          this.processMessageQueue().catch(error => {\r\n            console.error('Error processing message queue after join:', error);\r\n          });\r\n        }\r\n      } else if (data.type === 'channel_left') {\r\n        const channelId = String(data.channel_id);\r\n        this.joinedChannels.delete(channelId);\r\n        if (channelId === this.currentChannelId) {\r\n          this.currentChannelId = null;\r\n        }\r\n      } else if (data.type === 'error') {\r\n        console.error('WebSocket error message:', data);\r\n        \r\n        // Handle channel-specific errors\r\n        if (data.code === 'channel_not_found' || data.message?.includes('channel')) {\r\n          const channelId = this.currentChannelId;\r\n          if (channelId) {\r\n            const resolvers = this.joinChannelResolvers.get(channelId);\r\n            if (resolvers) {\r\n              resolvers.reject(new Error(data.message || 'Failed to join channel'));\r\n              this.joinChannelResolvers.delete(channelId);\r\n            }\r\n          }\r\n        }\r\n        \r\n        this.handleError({\r\n          name: data.code || 'UNKNOWN_ERROR',\r\n          message: data.message || data.content || 'Unknown error occurred'\r\n        });\r\n      } else if (data.type === 'user_status' || data.type === 'presence_update') {\r\n        console.log('User status update:', data);\r\n      }\r\n\r\n      this.messageHandlers.forEach(handler => {\r\n        try {\r\n          handler(data);\r\n        } catch (error) {\r\n          console.error('Error in message handler:', error);\r\n        }\r\n      });\r\n    } catch (error) {\r\n      console.error('Error handling WebSocket message:', error);\r\n      this.handleError(error);\r\n    }\r\n  };\r\n\r\n  // Helper method to check if connected to a channel\r\n  private isConnectedToChannel(channelId: string): boolean {\r\n    return (\r\n      this.socket?.readyState === WebSocket.OPEN &&\r\n      this.joinedChannels.has(channelId)\r\n    );\r\n  }\r\n\r\n  // Helper method to ensure connection is ready\r\n  private ensureConnected(): void {\r\n    if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {\r\n      throw new Error('WebSocket is not connected');\r\n    }\r\n  }\r\n}\r\n\r\nconst wsService = new WebSocketService();\r\nexport default wsService; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}