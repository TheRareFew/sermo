{"ast":null,"code":"var _WebSocketService;\nimport { store } from '../../store';\nimport { addMessage, updateMessage, addReaction, removeReaction } from '../../store/messages/messagesSlice';\nimport { updateUserStatus } from '../../store/chat/chatSlice';\nimport { transformMessage } from '../../utils/messageTransform';\n\n// Get WebSocket URL from environment variable or fallback to localhost\nconst WS_BASE_URL = process.env.REACT_APP_WS_URL || 'ws://localhost:8000/ws';\n\n// Helper function to get the correct WebSocket URL based on the current protocol\nconst getWebSocketUrl = () => {\n  // If we're on HTTPS, use WSS\n  if (window.location.protocol === 'https:' && WS_BASE_URL.startsWith('ws:')) {\n    return WS_BASE_URL.replace('ws:', 'wss:');\n  }\n  return WS_BASE_URL;\n};\nfunction isReactionAddedMessage(message) {\n  return message.type === 'reaction_added' && 'payload' in message && message.payload && 'channelId' in message.payload && 'messageId' in message.payload && 'reaction' in message.payload;\n}\nfunction isReactionRemovedMessage(message) {\n  return message.type === 'reaction_removed' && 'payload' in message && message.payload && 'channelId' in message.payload && 'messageId' in message.payload && 'userId' in message.payload && 'emoji' in message.payload;\n}\nfunction isNewMessageMessage(message) {\n  return message.type === 'new_message' && 'channelId' in message && 'message' in message;\n}\nfunction isUpdateMessageMessage(message) {\n  return message.type === 'update_message' && 'channelId' in message && 'id' in message && 'updates' in message;\n}\nfunction isUserStatusMessage(message) {\n  return message.type === 'user_status' && 'userId' in message && 'status' in message;\n}\nexport class WebSocketService {\n  constructor(store) {\n    this.ws = null;\n    this.pingInterval = null;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectTimeout = null;\n    this.channels = new Set();\n    this.store = null;\n    this.pendingChannels = new Set();\n    this.isReconnecting = false;\n    this.store = store;\n    if (WebSocketService.instance) {\n      return WebSocketService.instance;\n    }\n    WebSocketService.instance = this;\n  }\n  getAuthToken() {\n    var _state$auth;\n    const state = store.getState();\n    return ((_state$auth = state.auth) === null || _state$auth === void 0 ? void 0 : _state$auth.token) || null;\n  }\n  connect() {\n    var _this$ws;\n    if (((_this$ws = this.ws) === null || _this$ws === void 0 ? void 0 : _this$ws.readyState) === WebSocket.OPEN) {\n      console.log('WebSocket already connected');\n      return;\n    }\n    const token = this.getAuthToken();\n    if (!token) {\n      console.warn('No auth token available, skipping WebSocket connection');\n      return;\n    }\n    const wsUrl = `${getWebSocketUrl()}?token=${token}`;\n    console.log('Connecting to WebSocket:', wsUrl);\n    try {\n      this.ws = new WebSocket(wsUrl);\n      this.ws.onopen = () => {\n        console.log('WebSocket connected successfully');\n        this.reconnectAttempts = 0;\n        this.isReconnecting = false;\n        this.startPingInterval();\n\n        // Rejoin all channels\n        this.rejoinChannels();\n      };\n      this.ws.onmessage = event => {\n        console.log('Raw WebSocket message received:', event.data);\n        this.handleMessage(event);\n      };\n      this.ws.onclose = event => {\n        console.log('WebSocket disconnected with code:', event.code, 'reason:', event.reason);\n        this.stopPingInterval();\n        this.handleReconnect();\n      };\n      this.ws.onerror = error => {\n        console.error('WebSocket error:', error);\n        if (!this.isReconnecting) {\n          this.handleReconnect();\n        }\n      };\n    } catch (error) {\n      console.error('Error creating WebSocket connection:', error);\n      if (!this.isReconnecting) {\n        this.handleReconnect();\n      }\n    }\n  }\n  async rejoinChannels() {\n    console.log('Rejoining channels:', Array.from(this.channels));\n\n    // Wait a bit to ensure connection is stable\n    await new Promise(resolve => setTimeout(resolve, 1000));\n\n    // Copy channels to pendingChannels\n    this.pendingChannels = new Set(this.channels);\n\n    // Try to join each channel\n    for (const channelId of Array.from(this.channels)) {\n      try {\n        await this.joinChannel(channelId);\n        this.pendingChannels.delete(channelId);\n      } catch (error) {\n        console.error(`Failed to rejoin channel ${channelId}:`, error);\n      }\n    }\n  }\n  handleReconnect() {\n    if (this.isReconnecting || this.reconnectAttempts >= this.maxReconnectAttempts) {\n      return;\n    }\n    this.isReconnecting = true;\n    this.reconnectAttempts++;\n    console.log(`Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\n\n    // Store current channels\n    const currentChannels = new Set(this.channels);\n\n    // Clear existing timeout\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n    }\n    this.reconnectTimeout = setTimeout(() => {\n      this.connect();\n\n      // After reconnection, verify channels are rejoined\n      setTimeout(() => {\n        currentChannels.forEach(channelId => {\n          if (!this.channels.has(channelId)) {\n            console.log('Rejoining channel after reconnect:', channelId);\n            this.joinChannel(channelId);\n          }\n        });\n      }, 2000);\n    }, Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000)); // Exponential backoff with max 30s\n  }\n  startPingInterval() {\n    this.pingInterval = setInterval(() => {\n      var _this$ws2;\n      if (((_this$ws2 = this.ws) === null || _this$ws2 === void 0 ? void 0 : _this$ws2.readyState) === WebSocket.OPEN) {\n        this.ws.send(JSON.stringify({\n          type: 'PING'\n        }));\n      }\n    }, 30000);\n  }\n  stopPingInterval() {\n    if (this.pingInterval) {\n      clearInterval(this.pingInterval);\n      this.pingInterval = null;\n    }\n  }\n  disconnect() {\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n    this.stopPingInterval();\n  }\n  handleMessage(event) {\n    try {\n      const data = JSON.parse(event.data);\n      console.log('WebSocket received message:', data);\n      switch (data.type) {\n        case 'reaction_added':\n          if (isReactionAddedMessage(data)) {\n            console.log('Handling reaction_added:', data.payload);\n            if (this.store) {\n              const {\n                channelId,\n                messageId,\n                reaction\n              } = data.payload;\n              if (!this.channels.has(channelId)) {\n                console.warn('Received reaction for unsubscribed channel:', channelId);\n                return;\n              }\n              console.log('Dispatching addReaction:', {\n                channelId,\n                messageId,\n                reaction\n              });\n              this.store.dispatch(addReaction({\n                channelId,\n                messageId,\n                reaction\n              }));\n            }\n          }\n          break;\n        case 'reaction_removed':\n          if (isReactionRemovedMessage(data)) {\n            console.log('Handling reaction_removed:', data.payload);\n            if (this.store) {\n              const {\n                channelId,\n                messageId,\n                userId,\n                emoji\n              } = data.payload;\n              if (!this.channels.has(channelId)) {\n                console.warn('Received reaction for unsubscribed channel:', channelId);\n                return;\n              }\n              console.log('Dispatching removeReaction:', {\n                channelId,\n                messageId,\n                userId,\n                emoji\n              });\n              this.store.dispatch(removeReaction({\n                channelId,\n                messageId,\n                userId,\n                emoji\n              }));\n            }\n          }\n          break;\n        case 'new_message':\n          if (isNewMessageMessage(data)) {\n            if (this.store) {\n              console.log('Handling new_message:', data);\n              const transformedMessage = transformMessage(data.message);\n              if (data.isReply && data.parentId) {\n                transformedMessage.parentId = data.parentId;\n              }\n              this.store.dispatch(addMessage({\n                channelId: data.channelId,\n                message: transformedMessage\n              }));\n            }\n          }\n          break;\n        case 'update_message':\n          if (isUpdateMessageMessage(data)) {\n            if (this.store) {\n              console.log('Handling update_message:', data);\n              const baseMessage = {\n                id: data.id,\n                content: data.updates.content || '',\n                channel_id: data.channelId,\n                sender_id: data.updates.sender_id || '',\n                created_at: data.updates.created_at || new Date().toISOString(),\n                updated_at: data.updates.updated_at,\n                parent_id: data.updates.parent_id,\n                reply_count: data.updates.reply_count,\n                reactions: data.updates.reactions,\n                attachments: data.updates.attachments\n              };\n              const transformedUpdates = transformMessage(baseMessage);\n              this.store.dispatch(updateMessage({\n                channelId: data.channelId,\n                messageId: data.id,\n                message: transformedUpdates\n              }));\n            }\n          }\n          break;\n        case 'user_status':\n          if (isUserStatusMessage(data)) {\n            if (this.store) {\n              console.log('Handling user_status:', data);\n              this.store.dispatch(updateUserStatus({\n                userId: data.userId,\n                status: data.status\n              }));\n            }\n          }\n          break;\n        case 'pong':\n          break;\n        default:\n          console.warn('Unknown message type:', data.type);\n      }\n    } catch (error) {\n      console.error('Error handling WebSocket message:', error);\n    }\n  }\n  joinChannel(channelId) {\n    var _this$ws3;\n    console.log('Joining channel:', channelId);\n    if (((_this$ws3 = this.ws) === null || _this$ws3 === void 0 ? void 0 : _this$ws3.readyState) === WebSocket.OPEN) {\n      this.ws.send(JSON.stringify({\n        type: 'join_channel',\n        channelId\n      }));\n      this.channels.add(channelId);\n      console.log('Current channels:', Array.from(this.channels));\n    } else {\n      console.warn('WebSocket not connected, queueing channel join for:', channelId);\n      this.pendingChannels.add(channelId);\n      this.channels.add(channelId);\n      if (!this.ws || this.ws.readyState === WebSocket.CLOSED) {\n        this.connect();\n      }\n    }\n  }\n  leaveChannel(channelId) {\n    var _this$ws4;\n    console.log('Leaving channel:', channelId);\n    if (((_this$ws4 = this.ws) === null || _this$ws4 === void 0 ? void 0 : _this$ws4.readyState) === WebSocket.OPEN) {\n      this.ws.send(JSON.stringify({\n        type: 'leave_channel',\n        channelId\n      }));\n    } else {\n      console.warn('WebSocket not connected, skipping leave message for channel:', channelId);\n    }\n    this.channels.delete(channelId);\n    this.pendingChannels.delete(channelId);\n    console.log('Current channels:', Array.from(this.channels));\n  }\n}\n_WebSocketService = WebSocketService;\nWebSocketService.instance = null;\nexport default new WebSocketService(store);","map":{"version":3,"names":["store","addMessage","updateMessage","addReaction","removeReaction","updateUserStatus","transformMessage","WS_BASE_URL","process","env","REACT_APP_WS_URL","getWebSocketUrl","window","location","protocol","startsWith","replace","isReactionAddedMessage","message","type","payload","isReactionRemovedMessage","isNewMessageMessage","isUpdateMessageMessage","isUserStatusMessage","WebSocketService","constructor","ws","pingInterval","reconnectAttempts","maxReconnectAttempts","reconnectTimeout","channels","Set","pendingChannels","isReconnecting","instance","getAuthToken","_state$auth","state","getState","auth","token","connect","_this$ws","readyState","WebSocket","OPEN","console","log","warn","wsUrl","onopen","startPingInterval","rejoinChannels","onmessage","event","data","handleMessage","onclose","code","reason","stopPingInterval","handleReconnect","onerror","error","Array","from","Promise","resolve","setTimeout","channelId","joinChannel","delete","currentChannels","clearTimeout","forEach","has","Math","min","pow","setInterval","_this$ws2","send","JSON","stringify","clearInterval","disconnect","close","parse","messageId","reaction","dispatch","userId","emoji","transformedMessage","isReply","parentId","baseMessage","id","content","updates","channel_id","sender_id","created_at","Date","toISOString","updated_at","parent_id","reply_count","reactions","attachments","transformedUpdates","status","_this$ws3","add","CLOSED","leaveChannel","_this$ws4","_WebSocketService"],"sources":["Z:/GAUNTLET/projects/SERMO/sermo-app/frontend/src/services/websocket/index.ts"],"sourcesContent":["import { Reaction, RawMessage, UserStatus } from '../../types';\nimport { store } from '../../store';\nimport { addMessage, updateMessage, addReaction, removeReaction } from '../../store/messages/messagesSlice';\nimport { updateUserStatus } from '../../store/chat/chatSlice';\nimport { Store } from 'redux';\nimport { transformMessage } from '../../utils/messageTransform';\n\n// Get WebSocket URL from environment variable or fallback to localhost\nconst WS_BASE_URL = process.env.REACT_APP_WS_URL || 'ws://localhost:8000/ws';\n\n// Helper function to get the correct WebSocket URL based on the current protocol\nconst getWebSocketUrl = () => {\n  // If we're on HTTPS, use WSS\n  if (window.location.protocol === 'https:' && WS_BASE_URL.startsWith('ws:')) {\n    return WS_BASE_URL.replace('ws:', 'wss:');\n  }\n  return WS_BASE_URL;\n};\n\ninterface BaseWebSocketMessage {\n  type: string;\n  data?: any;\n}\n\ninterface ReactionAddedMessage extends BaseWebSocketMessage {\n  type: 'reaction_added';\n  payload: {\n    channelId: string;\n    messageId: string;\n    reaction: Reaction;\n  };\n}\n\ninterface ReactionRemovedMessage extends BaseWebSocketMessage {\n  type: 'reaction_removed';\n  payload: {\n    channelId: string;\n    messageId: string;\n    userId: string;\n    emoji: string;\n  };\n}\n\ninterface NewMessageMessage extends BaseWebSocketMessage {\n  type: 'new_message';\n  channelId: string;\n  message: RawMessage;\n  isReply?: boolean;\n  parentId?: string;\n}\n\ninterface UpdateMessageMessage extends BaseWebSocketMessage {\n  type: 'update_message';\n  channelId: string;\n  id: string;\n  updates: Partial<RawMessage>;\n}\n\ninterface UserStatusMessage extends BaseWebSocketMessage {\n  type: 'user_status';\n  userId: string;\n  status: UserStatus;\n}\n\ntype WebSocketMessage = \n  | ReactionAddedMessage \n  | ReactionRemovedMessage \n  | NewMessageMessage \n  | UpdateMessageMessage \n  | UserStatusMessage \n  | BaseWebSocketMessage;\n\nfunction isReactionAddedMessage(message: WebSocketMessage): message is ReactionAddedMessage {\n  return message.type === 'reaction_added' && \n         'payload' in message && \n         message.payload && \n         'channelId' in message.payload &&\n         'messageId' in message.payload &&\n         'reaction' in message.payload;\n}\n\nfunction isReactionRemovedMessage(message: WebSocketMessage): message is ReactionRemovedMessage {\n  return message.type === 'reaction_removed' && \n         'payload' in message && \n         message.payload && \n         'channelId' in message.payload &&\n         'messageId' in message.payload &&\n         'userId' in message.payload &&\n         'emoji' in message.payload;\n}\n\nfunction isNewMessageMessage(message: WebSocketMessage): message is NewMessageMessage {\n  return message.type === 'new_message' && \n         'channelId' in message && \n         'message' in message;\n}\n\nfunction isUpdateMessageMessage(message: WebSocketMessage): message is UpdateMessageMessage {\n  return message.type === 'update_message' && \n         'channelId' in message && \n         'id' in message && \n         'updates' in message;\n}\n\nfunction isUserStatusMessage(message: WebSocketMessage): message is UserStatusMessage {\n  return message.type === 'user_status' && \n         'userId' in message && \n         'status' in message;\n}\n\nexport class WebSocketService {\n  private static instance: WebSocketService | null = null;\n  private ws: WebSocket | null = null;\n  private pingInterval: NodeJS.Timeout | null = null;\n  private reconnectAttempts = 0;\n  private maxReconnectAttempts = 5;\n  private reconnectTimeout: NodeJS.Timeout | null = null;\n  private channels: Set<string> = new Set();\n  private store: Store | null = null;\n  private pendingChannels: Set<string> = new Set();\n  private isReconnecting = false;\n\n  constructor(store: Store) {\n    this.store = store;\n    if (WebSocketService.instance) {\n      return WebSocketService.instance;\n    }\n    WebSocketService.instance = this;\n  }\n\n  private getAuthToken(): string | null {\n    const state = store.getState();\n    return state.auth?.token || null;\n  }\n\n  public connect() {\n    if (this.ws?.readyState === WebSocket.OPEN) {\n      console.log('WebSocket already connected');\n      return;\n    }\n\n    const token = this.getAuthToken();\n    if (!token) {\n      console.warn('No auth token available, skipping WebSocket connection');\n      return;\n    }\n\n    const wsUrl = `${getWebSocketUrl()}?token=${token}`;\n    console.log('Connecting to WebSocket:', wsUrl);\n    \n    try {\n      this.ws = new WebSocket(wsUrl);\n      \n      this.ws.onopen = () => {\n        console.log('WebSocket connected successfully');\n        this.reconnectAttempts = 0;\n        this.isReconnecting = false;\n        this.startPingInterval();\n        \n        // Rejoin all channels\n        this.rejoinChannels();\n      };\n\n      this.ws.onmessage = (event) => {\n        console.log('Raw WebSocket message received:', event.data);\n        this.handleMessage(event);\n      };\n\n      this.ws.onclose = (event) => {\n        console.log('WebSocket disconnected with code:', event.code, 'reason:', event.reason);\n        this.stopPingInterval();\n        this.handleReconnect();\n      };\n\n      this.ws.onerror = (error) => {\n        console.error('WebSocket error:', error);\n        if (!this.isReconnecting) {\n          this.handleReconnect();\n        }\n      };\n    } catch (error) {\n      console.error('Error creating WebSocket connection:', error);\n      if (!this.isReconnecting) {\n        this.handleReconnect();\n      }\n    }\n  }\n\n  private async rejoinChannels() {\n    console.log('Rejoining channels:', Array.from(this.channels));\n    \n    // Wait a bit to ensure connection is stable\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    \n    // Copy channels to pendingChannels\n    this.pendingChannels = new Set(this.channels);\n    \n    // Try to join each channel\n    for (const channelId of Array.from(this.channels)) {\n      try {\n        await this.joinChannel(channelId);\n        this.pendingChannels.delete(channelId);\n      } catch (error) {\n        console.error(`Failed to rejoin channel ${channelId}:`, error);\n      }\n    }\n  }\n\n  private handleReconnect() {\n    if (this.isReconnecting || this.reconnectAttempts >= this.maxReconnectAttempts) {\n      return;\n    }\n\n    this.isReconnecting = true;\n    this.reconnectAttempts++;\n    console.log(`Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\n    \n    // Store current channels\n    const currentChannels = new Set(this.channels);\n    \n    // Clear existing timeout\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n    }\n    \n    this.reconnectTimeout = setTimeout(() => {\n      this.connect();\n      \n      // After reconnection, verify channels are rejoined\n      setTimeout(() => {\n        currentChannels.forEach(channelId => {\n          if (!this.channels.has(channelId)) {\n            console.log('Rejoining channel after reconnect:', channelId);\n            this.joinChannel(channelId);\n          }\n        });\n      }, 2000);\n    }, Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000)); // Exponential backoff with max 30s\n  }\n\n  private startPingInterval() {\n    this.pingInterval = setInterval(() => {\n      if (this.ws?.readyState === WebSocket.OPEN) {\n        this.ws.send(JSON.stringify({ type: 'PING' }));\n      }\n    }, 30000);\n  }\n\n  private stopPingInterval() {\n    if (this.pingInterval) {\n      clearInterval(this.pingInterval);\n      this.pingInterval = null;\n    }\n  }\n\n  public disconnect() {\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n    this.stopPingInterval();\n  }\n\n  private handleMessage(event: MessageEvent) {\n    try {\n      const data = JSON.parse(event.data) as WebSocketMessage;\n      console.log('WebSocket received message:', data);\n\n      switch (data.type) {\n        case 'reaction_added':\n          if (isReactionAddedMessage(data)) {\n            console.log('Handling reaction_added:', data.payload);\n            if (this.store) {\n              const { channelId, messageId, reaction } = data.payload;\n              if (!this.channels.has(channelId)) {\n                console.warn('Received reaction for unsubscribed channel:', channelId);\n                return;\n              }\n              console.log('Dispatching addReaction:', { channelId, messageId, reaction });\n              this.store.dispatch(addReaction({ channelId, messageId, reaction }));\n            }\n          }\n          break;\n\n        case 'reaction_removed':\n          if (isReactionRemovedMessage(data)) {\n            console.log('Handling reaction_removed:', data.payload);\n            if (this.store) {\n              const { channelId, messageId, userId, emoji } = data.payload;\n              if (!this.channels.has(channelId)) {\n                console.warn('Received reaction for unsubscribed channel:', channelId);\n                return;\n              }\n              console.log('Dispatching removeReaction:', { channelId, messageId, userId, emoji });\n              this.store.dispatch(removeReaction({ channelId, messageId, userId, emoji }));\n            }\n          }\n          break;\n\n        case 'new_message':\n          if (isNewMessageMessage(data)) {\n            if (this.store) {\n              console.log('Handling new_message:', data);\n              const transformedMessage = transformMessage(data.message);\n              if (data.isReply && data.parentId) {\n                transformedMessage.parentId = data.parentId;\n              }\n              this.store.dispatch(addMessage({ \n                channelId: data.channelId, \n                message: transformedMessage\n              }));\n            }\n          }\n          break;\n\n        case 'update_message':\n          if (isUpdateMessageMessage(data)) {\n            if (this.store) {\n              console.log('Handling update_message:', data);\n              const baseMessage: RawMessage = {\n                id: data.id,\n                content: data.updates.content || '',\n                channel_id: data.channelId,\n                sender_id: data.updates.sender_id || '',\n                created_at: data.updates.created_at || new Date().toISOString(),\n                updated_at: data.updates.updated_at,\n                parent_id: data.updates.parent_id,\n                reply_count: data.updates.reply_count,\n                reactions: data.updates.reactions,\n                attachments: data.updates.attachments\n              };\n              const transformedUpdates = transformMessage(baseMessage);\n              this.store.dispatch(updateMessage({ \n                channelId: data.channelId,\n                messageId: data.id,\n                message: transformedUpdates\n              }));\n            }\n          }\n          break;\n\n        case 'user_status':\n          if (isUserStatusMessage(data)) {\n            if (this.store) {\n              console.log('Handling user_status:', data);\n              this.store.dispatch(updateUserStatus({\n                userId: data.userId,\n                status: data.status\n              }));\n            }\n          }\n          break;\n\n        case 'pong':\n          break;\n\n        default:\n          console.warn('Unknown message type:', data.type);\n      }\n    } catch (error) {\n      console.error('Error handling WebSocket message:', error);\n    }\n  }\n\n  public joinChannel(channelId: string) {\n    console.log('Joining channel:', channelId);\n    if (this.ws?.readyState === WebSocket.OPEN) {\n      this.ws.send(JSON.stringify({\n        type: 'join_channel',\n        channelId\n      }));\n      this.channels.add(channelId);\n      console.log('Current channels:', Array.from(this.channels));\n    } else {\n      console.warn('WebSocket not connected, queueing channel join for:', channelId);\n      this.pendingChannels.add(channelId);\n      this.channels.add(channelId);\n      if (!this.ws || this.ws.readyState === WebSocket.CLOSED) {\n        this.connect();\n      }\n    }\n  }\n\n  public leaveChannel(channelId: string) {\n    console.log('Leaving channel:', channelId);\n    if (this.ws?.readyState === WebSocket.OPEN) {\n      this.ws.send(JSON.stringify({\n        type: 'leave_channel',\n        channelId\n      }));\n    } else {\n      console.warn('WebSocket not connected, skipping leave message for channel:', channelId);\n    }\n    this.channels.delete(channelId);\n    this.pendingChannels.delete(channelId);\n    console.log('Current channels:', Array.from(this.channels));\n  }\n}\n\nexport default new WebSocketService(store); "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}