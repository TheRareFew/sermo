{"ast":null,"code":"import { getAuthToken } from '../api/auth';\n\n// Add WebSocket message types\n\nclass WebSocketService {\n  constructor() {\n    this.socket = null;\n    this.messageHandlers = [];\n    this.errorHandlers = [];\n    this.currentChannelId = null;\n    this.joinedChannels = new Set();\n    this.messageQueue = [];\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectTimeout = null;\n    this.isReconnecting = false;\n    this.connectionPromise = null;\n    this.joinPromise = null;\n  }\n  async connect(channelId) {\n    // If already connected to the right channel, do nothing\n    if (this.isConnected() && this.isConnectedToChannel(channelId)) {\n      return;\n    }\n\n    // If there's a pending connection, wait for it\n    if (this.connectionPromise) {\n      await this.connectionPromise;\n      if (this.isConnected() && this.isConnectedToChannel(channelId)) {\n        return;\n      }\n    }\n\n    // Reset state before new connection\n    this.disconnect();\n    this.currentChannelId = channelId;\n    this.isReconnecting = false;\n    this.reconnectAttempts = 0;\n    try {\n      this.connectionPromise = new Promise((resolve, reject) => {\n        const token = getAuthToken();\n        if (!token) {\n          console.log('No authentication token found, skipping WebSocket connection');\n          reject(new Error('No authentication token found'));\n          return;\n        }\n        console.log(`Connecting to WebSocket: ws://localhost:8000/ws/chat?token=${token}`);\n        this.socket = new WebSocket(`ws://localhost:8000/ws/chat?token=${token}`);\n\n        // Set a connection timeout\n        const connectionTimeout = setTimeout(() => {\n          if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {\n            var _this$socket;\n            console.log('WebSocket connection timeout');\n            (_this$socket = this.socket) === null || _this$socket === void 0 ? void 0 : _this$socket.close();\n            reject(new Error('WebSocket connection timeout'));\n          }\n        }, 5000);\n        this.socket.onopen = () => {\n          var _this$socket2;\n          console.log('WebSocket connection opened, readyState:', (_this$socket2 = this.socket) === null || _this$socket2 === void 0 ? void 0 : _this$socket2.readyState);\n          clearTimeout(connectionTimeout);\n          this.reconnectAttempts = 0;\n          this.isReconnecting = false;\n          resolve();\n        };\n        this.socket.onclose = event => {\n          var _this$socket3;\n          console.log(`WebSocket disconnected with code: ${event.code}, readyState:`, (_this$socket3 = this.socket) === null || _this$socket3 === void 0 ? void 0 : _this$socket3.readyState);\n          clearTimeout(connectionTimeout);\n\n          // Only clear state if this wasn't triggered by disconnect()\n          if (this.socket === null) {\n            return;\n          }\n          const wasConnected = this.socket.readyState === WebSocket.OPEN;\n          this.socket = null;\n          this.joinedChannels.clear();\n          if (event.code !== 1000 && wasConnected) {\n            if (!this.isReconnecting && this.reconnectAttempts < this.maxReconnectAttempts) {\n              console.log('Connection lost, attempting to reconnect...');\n              this.attemptReconnect();\n            }\n          }\n        };\n        this.socket.onerror = error => {\n          var _this$socket4;\n          console.error('WebSocket error:', error, 'readyState:', (_this$socket4 = this.socket) === null || _this$socket4 === void 0 ? void 0 : _this$socket4.readyState);\n          clearTimeout(connectionTimeout);\n          this.handleError(new Error('WebSocket connection error'));\n          if (!this.isConnected()) {\n            reject(error);\n          }\n        };\n        this.socket.onmessage = event => {\n          try {\n            const message = JSON.parse(event.data);\n            console.log('Received WebSocket message:', message);\n            this.messageHandlers.forEach(handler => handler(message));\n          } catch (error) {\n            console.error('Error parsing WebSocket message:', error);\n          }\n        };\n      });\n\n      // Wait for connection to be established\n      await this.connectionPromise;\n\n      // Verify connection is still open\n      if (!this.isConnected()) {\n        throw new Error('WebSocket connection lost after establishment');\n      }\n\n      // After connection is established, join the channel\n      await this.joinChannel(channelId);\n    } catch (error) {\n      console.error('WebSocket connection failed:', error);\n      this.handleError(error instanceof Error ? error : new Error('WebSocket connection failed'));\n      throw error;\n    } finally {\n      this.connectionPromise = null;\n    }\n  }\n  async joinChannel(channelId) {\n    if (this.joinPromise) {\n      await this.joinPromise;\n      if (this.isConnectedToChannel(channelId)) {\n        return;\n      }\n    }\n\n    // Double check connection state\n    if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {\n      throw new Error('Cannot join channel: WebSocket is not connected');\n    }\n    if (this.isConnectedToChannel(channelId)) {\n      return;\n    }\n    this.joinPromise = new Promise((resolve, reject) => {\n      const joinMessage = {\n        type: 'join_channel',\n        channel_id: channelId\n      };\n      let joinTimeout = null;\n      let messageHandler = null;\n      const cleanup = () => {\n        if (joinTimeout) {\n          clearTimeout(joinTimeout);\n        }\n        if (messageHandler) {\n          var _this$socket5;\n          (_this$socket5 = this.socket) === null || _this$socket5 === void 0 ? void 0 : _this$socket5.removeEventListener('message', messageHandler);\n        }\n      };\n      joinTimeout = setTimeout(() => {\n        cleanup();\n        reject(new Error('Channel join timeout'));\n      }, 5000);\n      messageHandler = event => {\n        try {\n          const data = JSON.parse(event.data);\n          console.log('Received WebSocket message during join:', data);\n          if (data.type === 'channel_joined') {\n            console.log('Successfully joined channel:', channelId);\n            cleanup();\n            this.joinedChannels.add(channelId);\n            resolve();\n          } else if (data.type === 'channel_join_error') {\n            console.error('Failed to join channel:', data.error);\n            cleanup();\n            reject(new Error(data.error || 'Failed to join channel'));\n          } else if (data.type === 'error' && data.message) {\n            console.error('Received error during channel join:', data.message);\n            cleanup();\n            reject(new Error(data.message));\n          }\n        } catch (error) {\n          console.error('Error parsing WebSocket message during join:', error);\n        }\n      };\n      try {\n        var _this$socket6, _this$socket7;\n        console.log('Sending join channel message:', joinMessage);\n        (_this$socket6 = this.socket) === null || _this$socket6 === void 0 ? void 0 : _this$socket6.addEventListener('message', messageHandler);\n        (_this$socket7 = this.socket) === null || _this$socket7 === void 0 ? void 0 : _this$socket7.send(JSON.stringify(joinMessage));\n      } catch (error) {\n        console.error('Error sending join message:', error);\n        cleanup();\n        reject(error);\n      }\n    });\n    try {\n      await this.joinPromise;\n    } finally {\n      this.joinPromise = null;\n    }\n  }\n  handleError(error) {\n    console.error('WebSocket error:', error);\n    this.errorHandlers.forEach(handler => handler(error));\n  }\n  isConnected() {\n    return this.socket !== null && this.socket.readyState === WebSocket.OPEN;\n  }\n  isConnectedToChannel(channelId) {\n    return this.isConnected() && this.joinedChannels.has(channelId) && this.currentChannelId === channelId;\n  }\n  onMessage(handler) {\n    this.messageHandlers.push(handler);\n    return () => {\n      this.messageHandlers = this.messageHandlers.filter(h => h !== handler);\n    };\n  }\n  onError(handler) {\n    this.errorHandlers.push(handler);\n    return () => {\n      this.errorHandlers = this.errorHandlers.filter(h => h !== handler);\n    };\n  }\n  disconnect() {\n    this.isReconnecting = false;\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\n      this.socket.close(1000);\n    }\n    this.socket = null;\n    this.joinedChannels.clear();\n    this.messageHandlers = [];\n    this.errorHandlers = [];\n    this.reconnectAttempts = 0;\n    this.connectionPromise = null;\n    this.joinPromise = null;\n  }\n  attemptReconnect() {\n    if (this.isReconnecting || this.reconnectAttempts >= this.maxReconnectAttempts) {\n      console.log('Skipping reconnect: already reconnecting or max attempts reached');\n      return;\n    }\n    this.isReconnecting = true;\n    this.reconnectAttempts++;\n    console.log(`Attempting to reconnect (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})...`);\n    if (this.currentChannelId) {\n      const backoffTime = Math.min(1000 * Math.pow(2, this.reconnectAttempts - 1), 10000);\n      if (this.reconnectTimeout) {\n        clearTimeout(this.reconnectTimeout);\n      }\n      this.reconnectTimeout = setTimeout(async () => {\n        try {\n          await this.connect(this.currentChannelId);\n          this.isReconnecting = false;\n        } catch (error) {\n          console.error('Reconnection failed:', error);\n          if (this.reconnectAttempts < this.maxReconnectAttempts) {\n            this.isReconnecting = false; // Reset flag to allow next attempt\n            this.attemptReconnect();\n          } else {\n            console.log('Max reconnection attempts reached');\n            this.isReconnecting = false;\n            this.handleError(new Error('Failed to reconnect after maximum attempts'));\n          }\n        }\n      }, backoffTime);\n    } else {\n      this.isReconnecting = false;\n    }\n  }\n  getChatSocketState() {\n    var _this$socket8;\n    return ((_this$socket8 = this.socket) === null || _this$socket8 === void 0 ? void 0 : _this$socket8.readyState) || WebSocket.CLOSED;\n  }\n  async sendMessage(channelId, content) {\n    // Ensure we're connected to the right channel\n    if (!this.isConnectedToChannel(channelId)) {\n      console.log('Not connected to the right channel, attempting to connect...');\n      try {\n        await this.connect(channelId);\n      } catch (error) {\n        console.error('Failed to connect to channel:', error);\n        throw new Error('Failed to send message: Could not connect to channel');\n      }\n    }\n\n    // Double check connection state after potential reconnection\n    if (!this.isConnected()) {\n      console.error('WebSocket is still not connected after reconnection attempt');\n      throw new Error('WebSocket is not connected');\n    }\n    if (!this.isConnectedToChannel(channelId)) {\n      console.error('Still not connected to the correct channel after reconnection attempt');\n      throw new Error('Not connected to the correct channel');\n    }\n    const message = {\n      type: 'message',\n      channel_id: channelId,\n      content: content\n    };\n    try {\n      console.log('Sending message:', message);\n      this.socket.send(JSON.stringify(message));\n    } catch (error) {\n      console.error('Failed to send message:', error);\n      throw new Error('Failed to send message: ' + (error instanceof Error ? error.message : 'Unknown error'));\n    }\n  }\n}\nconst wsService = new WebSocketService();\nexport default wsService;","map":{"version":3,"names":["getAuthToken","WebSocketService","constructor","socket","messageHandlers","errorHandlers","currentChannelId","joinedChannels","Set","messageQueue","reconnectAttempts","maxReconnectAttempts","reconnectTimeout","isReconnecting","connectionPromise","joinPromise","connect","channelId","isConnected","isConnectedToChannel","disconnect","Promise","resolve","reject","token","console","log","Error","WebSocket","connectionTimeout","setTimeout","readyState","OPEN","_this$socket","close","onopen","_this$socket2","clearTimeout","onclose","event","_this$socket3","code","wasConnected","clear","attemptReconnect","onerror","error","_this$socket4","handleError","onmessage","message","JSON","parse","data","forEach","handler","joinChannel","joinMessage","type","channel_id","joinTimeout","messageHandler","cleanup","_this$socket5","removeEventListener","add","_this$socket6","_this$socket7","addEventListener","send","stringify","has","onMessage","push","filter","h","onError","backoffTime","Math","min","pow","getChatSocketState","_this$socket8","CLOSED","sendMessage","content","wsService"],"sources":["Z:/GAUNTLET/projects/SERMO/sermo-app/frontend/src/services/websocket/index.ts"],"sourcesContent":["import { WebSocketMessage, WebSocketChannelJoinMessage, WebSocketChannelMessage, StoreMessage } from '../../types';\r\nimport { getAuthToken } from '../api/auth';\r\nimport { store } from '../../store';\r\nimport { addMessage, setReplies } from '../../store/messages/messagesSlice';\r\n\r\n// Add WebSocket message types\r\ninterface WebSocketJoinMessage {\r\n  type: 'join_channel';\r\n  channel_id: string;\r\n}\r\n\r\ninterface WebSocketJoinResponse {\r\n  type: 'channel_joined' | 'channel_join_error';\r\n  channelId: string;\r\n  error?: string;\r\n}\r\n\r\nclass WebSocketService {\r\n  private socket: WebSocket | null = null;\r\n  private messageHandlers: ((message: WebSocketMessage) => void)[] = [];\r\n  private errorHandlers: ((error: Error) => void)[] = [];\r\n  private currentChannelId: string | null = null;\r\n  private joinedChannels: Set<string> = new Set();\r\n  private messageQueue: WebSocketMessage[] = [];\r\n  private reconnectAttempts = 0;\r\n  private maxReconnectAttempts = 5;\r\n  private reconnectTimeout: NodeJS.Timeout | null = null;\r\n  private isReconnecting = false;\r\n  private connectionPromise: Promise<void> | null = null;\r\n  private joinPromise: Promise<void> | null = null;\r\n\r\n  public async connect(channelId: string): Promise<void> {\r\n    // If already connected to the right channel, do nothing\r\n    if (this.isConnected() && this.isConnectedToChannel(channelId)) {\r\n      return;\r\n    }\r\n\r\n    // If there's a pending connection, wait for it\r\n    if (this.connectionPromise) {\r\n      await this.connectionPromise;\r\n      if (this.isConnected() && this.isConnectedToChannel(channelId)) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    // Reset state before new connection\r\n    this.disconnect();\r\n    this.currentChannelId = channelId;\r\n    this.isReconnecting = false;\r\n    this.reconnectAttempts = 0;\r\n    \r\n    try {\r\n      this.connectionPromise = new Promise((resolve, reject) => {\r\n        const token = getAuthToken();\r\n        if (!token) {\r\n          console.log('No authentication token found, skipping WebSocket connection');\r\n          reject(new Error('No authentication token found'));\r\n          return;\r\n        }\r\n\r\n        console.log(`Connecting to WebSocket: ws://localhost:8000/ws/chat?token=${token}`);\r\n        this.socket = new WebSocket(`ws://localhost:8000/ws/chat?token=${token}`);\r\n\r\n        // Set a connection timeout\r\n        const connectionTimeout = setTimeout(() => {\r\n          if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {\r\n            console.log('WebSocket connection timeout');\r\n            this.socket?.close();\r\n            reject(new Error('WebSocket connection timeout'));\r\n          }\r\n        }, 5000);\r\n\r\n        this.socket.onopen = () => {\r\n          console.log('WebSocket connection opened, readyState:', this.socket?.readyState);\r\n          clearTimeout(connectionTimeout);\r\n          this.reconnectAttempts = 0;\r\n          this.isReconnecting = false;\r\n          resolve();\r\n        };\r\n\r\n        this.socket.onclose = (event) => {\r\n          console.log(`WebSocket disconnected with code: ${event.code}, readyState:`, this.socket?.readyState);\r\n          clearTimeout(connectionTimeout);\r\n          \r\n          // Only clear state if this wasn't triggered by disconnect()\r\n          if (this.socket === null) {\r\n            return;\r\n          }\r\n          \r\n          const wasConnected = this.socket.readyState === WebSocket.OPEN;\r\n          this.socket = null;\r\n          this.joinedChannels.clear();\r\n\r\n          if (event.code !== 1000 && wasConnected) {\r\n            if (!this.isReconnecting && this.reconnectAttempts < this.maxReconnectAttempts) {\r\n              console.log('Connection lost, attempting to reconnect...');\r\n              this.attemptReconnect();\r\n            }\r\n          }\r\n        };\r\n\r\n        this.socket.onerror = (error) => {\r\n          console.error('WebSocket error:', error, 'readyState:', this.socket?.readyState);\r\n          clearTimeout(connectionTimeout);\r\n          this.handleError(new Error('WebSocket connection error'));\r\n          if (!this.isConnected()) {\r\n            reject(error);\r\n          }\r\n        };\r\n\r\n        this.socket.onmessage = (event) => {\r\n          try {\r\n            const message = JSON.parse(event.data) as WebSocketMessage;\r\n            console.log('Received WebSocket message:', message);\r\n            this.messageHandlers.forEach(handler => handler(message));\r\n          } catch (error) {\r\n            console.error('Error parsing WebSocket message:', error);\r\n          }\r\n        };\r\n      });\r\n\r\n      // Wait for connection to be established\r\n      await this.connectionPromise;\r\n      \r\n      // Verify connection is still open\r\n      if (!this.isConnected()) {\r\n        throw new Error('WebSocket connection lost after establishment');\r\n      }\r\n      \r\n      // After connection is established, join the channel\r\n      await this.joinChannel(channelId);\r\n      \r\n    } catch (error) {\r\n      console.error('WebSocket connection failed:', error);\r\n      this.handleError(error instanceof Error ? error : new Error('WebSocket connection failed'));\r\n      throw error;\r\n    } finally {\r\n      this.connectionPromise = null;\r\n    }\r\n  }\r\n\r\n  public async joinChannel(channelId: string): Promise<void> {\r\n    if (this.joinPromise) {\r\n      await this.joinPromise;\r\n      if (this.isConnectedToChannel(channelId)) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    // Double check connection state\r\n    if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {\r\n      throw new Error('Cannot join channel: WebSocket is not connected');\r\n    }\r\n\r\n    if (this.isConnectedToChannel(channelId)) {\r\n      return;\r\n    }\r\n\r\n    this.joinPromise = new Promise((resolve, reject) => {\r\n      const joinMessage: WebSocketJoinMessage = {\r\n        type: 'join_channel',\r\n        channel_id: channelId\r\n      };\r\n\r\n      let joinTimeout: NodeJS.Timeout | null = null;\r\n      let messageHandler: ((event: MessageEvent) => void) | null = null;\r\n\r\n      const cleanup = () => {\r\n        if (joinTimeout) {\r\n          clearTimeout(joinTimeout);\r\n        }\r\n        if (messageHandler) {\r\n          this.socket?.removeEventListener('message', messageHandler);\r\n        }\r\n      };\r\n\r\n      joinTimeout = setTimeout(() => {\r\n        cleanup();\r\n        reject(new Error('Channel join timeout'));\r\n      }, 5000);\r\n\r\n      messageHandler = (event: MessageEvent) => {\r\n        try {\r\n          const data = JSON.parse(event.data);\r\n          console.log('Received WebSocket message during join:', data);\r\n          \r\n          if (data.type === 'channel_joined') {\r\n            console.log('Successfully joined channel:', channelId);\r\n            cleanup();\r\n            this.joinedChannels.add(channelId);\r\n            resolve();\r\n          } else if (data.type === 'channel_join_error') {\r\n            console.error('Failed to join channel:', data.error);\r\n            cleanup();\r\n            reject(new Error(data.error || 'Failed to join channel'));\r\n          } else if (data.type === 'error' && data.message) {\r\n            console.error('Received error during channel join:', data.message);\r\n            cleanup();\r\n            reject(new Error(data.message));\r\n          }\r\n        } catch (error) {\r\n          console.error('Error parsing WebSocket message during join:', error);\r\n        }\r\n      };\r\n\r\n      try {\r\n        console.log('Sending join channel message:', joinMessage);\r\n        this.socket?.addEventListener('message', messageHandler);\r\n        this.socket?.send(JSON.stringify(joinMessage));\r\n      } catch (error) {\r\n        console.error('Error sending join message:', error);\r\n        cleanup();\r\n        reject(error);\r\n      }\r\n    });\r\n\r\n    try {\r\n      await this.joinPromise;\r\n    } finally {\r\n      this.joinPromise = null;\r\n    }\r\n  }\r\n\r\n  private handleError(error: Error): void {\r\n    console.error('WebSocket error:', error);\r\n    this.errorHandlers.forEach(handler => handler(error));\r\n  }\r\n\r\n  public isConnected(): boolean {\r\n    return this.socket !== null && this.socket.readyState === WebSocket.OPEN;\r\n  }\r\n\r\n  private isConnectedToChannel(channelId: string): boolean {\r\n    return this.isConnected() && this.joinedChannels.has(channelId) && this.currentChannelId === channelId;\r\n  }\r\n\r\n  public onMessage(handler: (message: WebSocketMessage) => void): () => void {\r\n    this.messageHandlers.push(handler);\r\n    return () => {\r\n      this.messageHandlers = this.messageHandlers.filter(h => h !== handler);\r\n    };\r\n  }\r\n\r\n  public onError(handler: (error: Error) => void): () => void {\r\n    this.errorHandlers.push(handler);\r\n    return () => {\r\n      this.errorHandlers = this.errorHandlers.filter(h => h !== handler);\r\n    };\r\n  }\r\n\r\n  public disconnect(): void {\r\n    this.isReconnecting = false;\r\n    if (this.reconnectTimeout) {\r\n      clearTimeout(this.reconnectTimeout);\r\n      this.reconnectTimeout = null;\r\n    }\r\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\r\n      this.socket.close(1000);\r\n    }\r\n    this.socket = null;\r\n    this.joinedChannels.clear();\r\n    this.messageHandlers = [];\r\n    this.errorHandlers = [];\r\n    this.reconnectAttempts = 0;\r\n    this.connectionPromise = null;\r\n    this.joinPromise = null;\r\n  }\r\n\r\n  private attemptReconnect(): void {\r\n    if (this.isReconnecting || this.reconnectAttempts >= this.maxReconnectAttempts) {\r\n      console.log('Skipping reconnect: already reconnecting or max attempts reached');\r\n      return;\r\n    }\r\n\r\n    this.isReconnecting = true;\r\n    this.reconnectAttempts++;\r\n\r\n    console.log(`Attempting to reconnect (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})...`);\r\n\r\n    if (this.currentChannelId) {\r\n      const backoffTime = Math.min(1000 * Math.pow(2, this.reconnectAttempts - 1), 10000);\r\n      \r\n      if (this.reconnectTimeout) {\r\n        clearTimeout(this.reconnectTimeout);\r\n      }\r\n\r\n      this.reconnectTimeout = setTimeout(async () => {\r\n        try {\r\n          await this.connect(this.currentChannelId!);\r\n          this.isReconnecting = false;\r\n        } catch (error) {\r\n          console.error('Reconnection failed:', error);\r\n          if (this.reconnectAttempts < this.maxReconnectAttempts) {\r\n            this.isReconnecting = false; // Reset flag to allow next attempt\r\n            this.attemptReconnect();\r\n          } else {\r\n            console.log('Max reconnection attempts reached');\r\n            this.isReconnecting = false;\r\n            this.handleError(new Error('Failed to reconnect after maximum attempts'));\r\n          }\r\n        }\r\n      }, backoffTime);\r\n    } else {\r\n      this.isReconnecting = false;\r\n    }\r\n  }\r\n\r\n  public getChatSocketState(): number {\r\n    return this.socket?.readyState || WebSocket.CLOSED;\r\n  }\r\n\r\n  public async sendMessage(channelId: string, content: string): Promise<void> {\r\n    // Ensure we're connected to the right channel\r\n    if (!this.isConnectedToChannel(channelId)) {\r\n      console.log('Not connected to the right channel, attempting to connect...');\r\n      try {\r\n        await this.connect(channelId);\r\n      } catch (error) {\r\n        console.error('Failed to connect to channel:', error);\r\n        throw new Error('Failed to send message: Could not connect to channel');\r\n      }\r\n    }\r\n\r\n    // Double check connection state after potential reconnection\r\n    if (!this.isConnected()) {\r\n      console.error('WebSocket is still not connected after reconnection attempt');\r\n      throw new Error('WebSocket is not connected');\r\n    }\r\n\r\n    if (!this.isConnectedToChannel(channelId)) {\r\n      console.error('Still not connected to the correct channel after reconnection attempt');\r\n      throw new Error('Not connected to the correct channel');\r\n    }\r\n\r\n    const message = {\r\n      type: 'message',\r\n      channel_id: channelId,\r\n      content: content\r\n    };\r\n\r\n    try {\r\n      console.log('Sending message:', message);\r\n      this.socket!.send(JSON.stringify(message));\r\n    } catch (error) {\r\n      console.error('Failed to send message:', error);\r\n      throw new Error('Failed to send message: ' + (error instanceof Error ? error.message : 'Unknown error'));\r\n    }\r\n  }\r\n}\r\n\r\nconst wsService = new WebSocketService();\r\nexport default wsService; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}