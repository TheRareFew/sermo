{"ast":null,"code":"import { getAuthToken } from '../api/auth';\nimport { store } from '../../store';\nimport { updateMessage } from '../../store/messages/messagesSlice';\nimport messageQueue from './messageQueue';\nimport { transformMessage } from '../../utils/messageTransform';\n\n// Constants\nconst INITIAL_RECONNECT_DELAY = 1000;\nconst MAX_RECONNECT_DELAY = 30000;\nconst HEARTBEAT_INTERVAL = 15000;\nconst HEARTBEAT_TIMEOUT = 30000;\nconst CONNECTION_TIMEOUT = 5000;\nclass WebSocketService {\n  constructor() {\n    this.socket = null;\n    this.messageHandlers = [];\n    this.errorHandlers = [];\n    this.currentChannelId = null;\n    this.joinedChannels = new Set();\n    this.reconnectAttempts = 0;\n    this.reconnectTimeout = null;\n    this.isReconnecting = false;\n    this.connectionPromise = null;\n    this.joinPromise = null;\n    this.lastMessageId = null;\n    this.processingQueue = false;\n    this.heartbeatInterval = null;\n    this.lastHeartbeatResponse = Date.now();\n    this.connectionStartTime = 0;\n    this.handleClose = event => {\n      console.error(`[DEBUG] WebSocket closed with code ${event.code}`);\n      this.handleReconnect();\n    };\n    this.handleWebSocketMessage = event => {\n      try {\n        var _message$data, _message$data2;\n        const message = JSON.parse(event.data);\n\n        // Update heartbeat timestamp for any message\n        this.lastHeartbeatResponse = Date.now();\n        if (message.type === 'pong') {\n          return;\n        }\n\n        // Handle message acknowledgments and update message ID\n        if (message.type === 'message_sent' && (_message$data = message.data) !== null && _message$data !== void 0 && _message$data.message) {\n          var _message$data$channel;\n          const channelId = (_message$data$channel = message.data.channel_id) === null || _message$data$channel === void 0 ? void 0 : _message$data$channel.toString();\n          const messageId = message.data.message.id.toString();\n          const tempMessageId = message.data.message.content;\n          if (channelId && messageId) {\n            messageQueue.markMessageSent(channelId, messageId);\n\n            // Update message ID in store if needed\n            if (tempMessageId !== messageId) {\n              const storeMessage = transformMessage(message.data.message);\n              store.dispatch(updateMessage({\n                channelId,\n                id: tempMessageId,\n                message: storeMessage\n              }));\n            }\n          }\n        } else if (message.type === 'error' && (_message$data2 = message.data) !== null && _message$data2 !== void 0 && _message$data2.error) {\n          console.error('[DEBUG] Message send error:', message.data.error);\n          this.handleError(new Error(message.data.error));\n        } else {\n          // Broadcast other messages to all handlers immediately\n          this.messageHandlers.forEach(handler => {\n            try {\n              handler(message);\n            } catch (error) {\n              console.error('[DEBUG] Error in message handler:', error);\n            }\n          });\n        }\n      } catch (error) {\n        console.error('[DEBUG] Error handling WebSocket message:', error);\n      }\n    };\n  }\n  async connect(channelId) {\n    if (this.isConnected() && this.isConnectedToChannel(channelId)) {\n      return;\n    }\n\n    // Always disconnect before connecting to ensure clean state\n    this.disconnect();\n    this.currentChannelId = channelId;\n    this.isReconnecting = false;\n    this.reconnectAttempts = 0;\n    this.connectionStartTime = Date.now();\n    try {\n      const token = getAuthToken();\n      if (!token) {\n        throw new Error('No authentication token found');\n      }\n      this.socket = new WebSocket(`ws://localhost:8000/ws/chat?token=${token}`);\n\n      // Set up socket event handlers immediately\n      this.socket.onclose = () => {\n        console.error('[DEBUG] WebSocket closed unexpectedly');\n        this.handleReconnect();\n      };\n      this.socket.onerror = error => {\n        console.error('[DEBUG] WebSocket error:', error);\n        this.handleError(error instanceof Error ? error : new Error('WebSocket error'));\n      };\n      await this.waitForConnection();\n      if (this.socket) {\n        this.socket.onmessage = this.handleWebSocketMessage;\n        await this.joinChannel(channelId);\n\n        // Start heartbeat after successful connection\n        this.startHeartbeat();\n\n        // Process any queued messages after successful connection\n        await this.processMessageQueue();\n      }\n    } catch (error) {\n      console.error('[DEBUG] WebSocket connection failed:', error);\n      this.handleError(error instanceof Error ? error : new Error('WebSocket connection failed'));\n      throw error;\n    }\n  }\n  async waitForConnection() {\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error('WebSocket connection timeout'));\n      }, CONNECTION_TIMEOUT);\n      if (this.socket) {\n        this.socket.onopen = () => {\n          console.log('[DEBUG] WebSocket connection opened');\n          clearTimeout(timeout);\n          this.startHeartbeat();\n          resolve();\n        };\n        this.socket.onerror = error => {\n          console.error('[DEBUG] WebSocket connection error:', error);\n          clearTimeout(timeout);\n          reject(error);\n        };\n        this.socket.onclose = this.handleClose;\n      }\n    });\n  }\n  startHeartbeat() {\n    if (this.heartbeatInterval) {\n      clearInterval(this.heartbeatInterval);\n    }\n    this.heartbeatInterval = setInterval(() => {\n      var _this$socket;\n      if (((_this$socket = this.socket) === null || _this$socket === void 0 ? void 0 : _this$socket.readyState) === WebSocket.OPEN) {\n        this.socket.send(JSON.stringify({\n          type: 'ping'\n        }));\n\n        // Check if we haven't received a response in too long\n        if (Date.now() - this.lastHeartbeatResponse > HEARTBEAT_TIMEOUT) {\n          console.error('[DEBUG] Heartbeat timeout, reconnecting...');\n          this.handleReconnect();\n        }\n      }\n    }, HEARTBEAT_INTERVAL);\n  }\n  async handleReconnect() {\n    if (this.isReconnecting || !this.currentChannelId) return;\n    this.isReconnecting = true;\n    const delay = Math.min(INITIAL_RECONNECT_DELAY * Math.pow(2, this.reconnectAttempts), MAX_RECONNECT_DELAY);\n    console.log(`[DEBUG] Attempting to reconnect in ${delay}ms (attempt ${this.reconnectAttempts + 1})`);\n    this.reconnectTimeout = setTimeout(async () => {\n      try {\n        this.reconnectAttempts++;\n        await this.connect(this.currentChannelId);\n        this.isReconnecting = false;\n        this.reconnectAttempts = 0;\n        console.log('[DEBUG] Reconnection successful');\n      } catch (error) {\n        console.error('[DEBUG] Reconnection failed:', error);\n        this.handleReconnect();\n      }\n    }, delay);\n  }\n  async processMessageQueue() {\n    if (this.processingQueue) return;\n    this.processingQueue = true;\n    try {\n      while (this.isConnected()) {\n        const channelId = this.currentChannelId;\n        if (!channelId) break;\n        const queuedMessage = messageQueue.getNextMessage(channelId);\n        if (!queuedMessage) break;\n        try {\n          var _this$socket2;\n          const message = {\n            type: queuedMessage.type,\n            data: {\n              channel_id: parseInt(queuedMessage.channelId),\n              content: queuedMessage.content,\n              parent_id: queuedMessage.parentId\n            }\n          };\n          if (((_this$socket2 = this.socket) === null || _this$socket2 === void 0 ? void 0 : _this$socket2.readyState) === WebSocket.OPEN) {\n            messageQueue.markMessageAttempted(channelId, queuedMessage.id);\n            this.socket.send(JSON.stringify(message));\n            // Don't wait for acknowledgment, let the message handler deal with it\n          } else {\n            break;\n          }\n        } catch (error) {\n          console.error('[DEBUG] Error sending queued message:', error);\n          break;\n        }\n      }\n    } finally {\n      this.processingQueue = false;\n    }\n  }\n  async sendMessage(channelId, content, parentId) {\n    var _store$getState$auth$, _this$socket3;\n    // Always queue the message first\n    const messageId = messageQueue.addMessage(channelId, content, parentId ? 'reply' : 'message', parentId);\n    const userId = (_store$getState$auth$ = store.getState().auth.user) === null || _store$getState$auth$ === void 0 ? void 0 : _store$getState$auth$.id;\n    if (!userId) {\n      throw new Error('User not authenticated');\n    }\n\n    // Create the raw message\n    const rawMessage = {\n      id: messageId,\n      content: content,\n      channel_id: parseInt(channelId),\n      sender_id: userId,\n      created_at: new Date().toISOString(),\n      updated_at: new Date().toISOString(),\n      parent_id: parentId\n    };\n\n    // Create the message data\n    const messageData = {\n      channel_id: parseInt(channelId),\n      content: content,\n      parent_id: parentId,\n      message: rawMessage\n    };\n\n    // Transform to store message for immediate display\n    const storeMessage = transformMessage(rawMessage);\n\n    // Broadcast the message immediately to all handlers\n    this.messageHandlers.forEach(handler => {\n      try {\n        handler({\n          type: 'new_message',\n          data: messageData\n        });\n      } catch (error) {\n        console.error('[DEBUG] Error in message handler:', error);\n      }\n    });\n\n    // Connect if not connected\n    if (!this.isConnectedToChannel(channelId)) {\n      try {\n        await this.connect(channelId);\n      } catch (error) {\n        console.error('[DEBUG] Failed to connect:', error);\n        return; // Message is already queued and displayed, will be sent after reconnection\n      }\n    }\n\n    // Send the message if connected\n    if (((_this$socket3 = this.socket) === null || _this$socket3 === void 0 ? void 0 : _this$socket3.readyState) === WebSocket.OPEN) {\n      try {\n        messageQueue.markMessageAttempted(channelId, messageId);\n        this.socket.send(JSON.stringify({\n          type: parentId ? 'reply' : 'message',\n          data: messageData\n        }));\n      } catch (error) {\n        console.error('[DEBUG] Error sending message:', error);\n      }\n    }\n  }\n  async joinChannel(channelId) {\n    if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {\n      throw new Error('Cannot join channel: WebSocket is not connected');\n    }\n    if (this.isConnectedToChannel(channelId)) {\n      console.log('[DEBUG] Already joined channel:', channelId);\n      return;\n    }\n    return new Promise((resolve, reject) => {\n      const joinMessage = {\n        type: 'join',\n        data: {\n          channel_id: parseInt(channelId)\n        }\n      };\n      const joinTimeout = setTimeout(() => {\n        var _this$socket4;\n        (_this$socket4 = this.socket) === null || _this$socket4 === void 0 ? void 0 : _this$socket4.removeEventListener('message', handleJoinResponse);\n        reject(new Error('Channel join timeout'));\n      }, 10000);\n      const handleJoinResponse = event => {\n        try {\n          var _data$data, _data$data$channel_id;\n          const data = JSON.parse(event.data);\n          console.log('[DEBUG] Received join response:', data);\n          if (data.type === 'joined' && ((_data$data = data.data) === null || _data$data === void 0 ? void 0 : (_data$data$channel_id = _data$data.channel_id) === null || _data$data$channel_id === void 0 ? void 0 : _data$data$channel_id.toString()) === channelId) {\n            var _this$socket5;\n            clearTimeout(joinTimeout);\n            (_this$socket5 = this.socket) === null || _this$socket5 === void 0 ? void 0 : _this$socket5.removeEventListener('message', handleJoinResponse);\n            this.joinedChannels.add(channelId);\n            console.log('[DEBUG] Successfully joined channel:', channelId);\n            resolve();\n          } else if (data.type === 'error') {\n            var _this$socket6;\n            clearTimeout(joinTimeout);\n            (_this$socket6 = this.socket) === null || _this$socket6 === void 0 ? void 0 : _this$socket6.removeEventListener('message', handleJoinResponse);\n            console.error('[DEBUG] Error joining channel:', data.message);\n            reject(new Error(data.message));\n          }\n        } catch (error) {\n          console.error('[DEBUG] Error handling join response:', error);\n        }\n      };\n      if (this.socket) {\n        this.socket.addEventListener('message', handleJoinResponse);\n        console.log('[DEBUG] Sending join message:', joinMessage);\n        this.socket.send(JSON.stringify(joinMessage));\n      } else {\n        clearTimeout(joinTimeout);\n        reject(new Error('WebSocket not available'));\n      }\n    });\n  }\n  handleError(error) {\n    console.error('WebSocket error:', error);\n    this.errorHandlers.forEach(handler => handler(error));\n  }\n  isConnected() {\n    return this.socket !== null && this.socket.readyState === WebSocket.OPEN;\n  }\n  isConnectedToChannel(channelId) {\n    return this.isConnected() && this.joinedChannels.has(channelId) && this.currentChannelId === channelId;\n  }\n  onMessage(handler) {\n    this.messageHandlers.push(handler);\n    return () => {\n      this.messageHandlers = this.messageHandlers.filter(h => h !== handler);\n    };\n  }\n  onError(handler) {\n    this.errorHandlers.push(handler);\n    return () => {\n      this.errorHandlers = this.errorHandlers.filter(h => h !== handler);\n    };\n  }\n  disconnect() {\n    console.log('[DEBUG] Disconnecting WebSocket...');\n    this.isReconnecting = false;\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n    if (this.heartbeatInterval) {\n      clearInterval(this.heartbeatInterval);\n      this.heartbeatInterval = null;\n    }\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\n      this.socket.close(1000);\n    }\n    this.socket = null;\n    this.joinedChannels.clear();\n    this.messageHandlers = [];\n    this.errorHandlers = [];\n    this.reconnectAttempts = 0;\n    this.connectionPromise = null;\n    this.joinPromise = null;\n    this.currentChannelId = null;\n    console.log('[DEBUG] WebSocket disconnected and state cleared');\n  }\n  offMessage(handler) {\n    this.messageHandlers = this.messageHandlers.filter(h => h !== handler);\n  }\n  offError(handler) {\n    this.errorHandlers = this.errorHandlers.filter(h => h !== handler);\n  }\n  getChatSocketState() {\n    var _this$socket7;\n    return ((_this$socket7 = this.socket) === null || _this$socket7 === void 0 ? void 0 : _this$socket7.readyState) || WebSocket.CLOSED;\n  }\n}\nconst wsService = new WebSocketService();\nexport default wsService;","map":{"version":3,"names":["getAuthToken","store","updateMessage","messageQueue","transformMessage","INITIAL_RECONNECT_DELAY","MAX_RECONNECT_DELAY","HEARTBEAT_INTERVAL","HEARTBEAT_TIMEOUT","CONNECTION_TIMEOUT","WebSocketService","constructor","socket","messageHandlers","errorHandlers","currentChannelId","joinedChannels","Set","reconnectAttempts","reconnectTimeout","isReconnecting","connectionPromise","joinPromise","lastMessageId","processingQueue","heartbeatInterval","lastHeartbeatResponse","Date","now","connectionStartTime","handleClose","event","console","error","code","handleReconnect","handleWebSocketMessage","_message$data","_message$data2","message","JSON","parse","data","type","_message$data$channel","channelId","channel_id","toString","messageId","id","tempMessageId","content","markMessageSent","storeMessage","dispatch","handleError","Error","forEach","handler","connect","isConnected","isConnectedToChannel","disconnect","token","WebSocket","onclose","onerror","waitForConnection","onmessage","joinChannel","startHeartbeat","processMessageQueue","Promise","resolve","reject","timeout","setTimeout","onopen","log","clearTimeout","clearInterval","setInterval","_this$socket","readyState","OPEN","send","stringify","delay","Math","min","pow","queuedMessage","getNextMessage","_this$socket2","parseInt","parent_id","parentId","markMessageAttempted","sendMessage","_store$getState$auth$","_this$socket3","addMessage","userId","getState","auth","user","rawMessage","sender_id","created_at","toISOString","updated_at","messageData","joinMessage","joinTimeout","_this$socket4","removeEventListener","handleJoinResponse","_data$data","_data$data$channel_id","_this$socket5","add","_this$socket6","addEventListener","has","onMessage","push","filter","h","onError","close","clear","offMessage","offError","getChatSocketState","_this$socket7","CLOSED","wsService"],"sources":["Z:/GAUNTLET/projects/SERMO/sermo-app/frontend/src/services/websocket/index.ts"],"sourcesContent":["import { WebSocketMessage, WebSocketMessageData, RawMessage, StoreMessage } from '../../types';\nimport { getAuthToken } from '../api/auth';\nimport { store } from '../../store';\nimport { addMessage, updateMessage } from '../../store/messages/messagesSlice';\nimport messageQueue from './messageQueue';\nimport { transformMessage } from '../../utils/messageTransform';\n\n// Constants\nconst INITIAL_RECONNECT_DELAY = 1000;\nconst MAX_RECONNECT_DELAY = 30000;\nconst HEARTBEAT_INTERVAL = 15000;\nconst HEARTBEAT_TIMEOUT = 30000;\nconst CONNECTION_TIMEOUT = 5000;\n\nclass WebSocketService {\n  private socket: WebSocket | null = null;\n  private messageHandlers: ((message: WebSocketMessage) => void)[] = [];\n  private errorHandlers: ((error: Error) => void)[] = [];\n  private currentChannelId: string | null = null;\n  private joinedChannels: Set<string> = new Set();\n  private reconnectAttempts = 0;\n  private reconnectTimeout: NodeJS.Timeout | null = null;\n  private isReconnecting = false;\n  private connectionPromise: Promise<void> | null = null;\n  private joinPromise: Promise<void> | null = null;\n  private lastMessageId: string | null = null;\n  private processingQueue = false;\n  private heartbeatInterval: NodeJS.Timeout | null = null;\n  private lastHeartbeatResponse: number = Date.now();\n  private connectionStartTime: number = 0;\n\n  public async connect(channelId: string): Promise<void> {\n    if (this.isConnected() && this.isConnectedToChannel(channelId)) {\n      return;\n    }\n\n    // Always disconnect before connecting to ensure clean state\n    this.disconnect();\n    this.currentChannelId = channelId;\n    this.isReconnecting = false;\n    this.reconnectAttempts = 0;\n    this.connectionStartTime = Date.now();\n    \n    try {\n      const token = getAuthToken();\n      if (!token) {\n        throw new Error('No authentication token found');\n      }\n\n      this.socket = new WebSocket(`ws://localhost:8000/ws/chat?token=${token}`);\n      \n      // Set up socket event handlers immediately\n      this.socket.onclose = () => {\n        console.error('[DEBUG] WebSocket closed unexpectedly');\n        this.handleReconnect();\n      };\n\n      this.socket.onerror = (error) => {\n        console.error('[DEBUG] WebSocket error:', error);\n        this.handleError(error instanceof Error ? error : new Error('WebSocket error'));\n      };\n\n      await this.waitForConnection();\n\n      if (this.socket) {\n        this.socket.onmessage = this.handleWebSocketMessage;\n        await this.joinChannel(channelId);\n        \n        // Start heartbeat after successful connection\n        this.startHeartbeat();\n        \n        // Process any queued messages after successful connection\n        await this.processMessageQueue();\n      }\n      \n    } catch (error) {\n      console.error('[DEBUG] WebSocket connection failed:', error);\n      this.handleError(error instanceof Error ? error : new Error('WebSocket connection failed'));\n      throw error;\n    }\n  }\n\n  private async waitForConnection(): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error('WebSocket connection timeout'));\n      }, CONNECTION_TIMEOUT);\n\n      if (this.socket) {\n        this.socket.onopen = () => {\n          console.log('[DEBUG] WebSocket connection opened');\n          clearTimeout(timeout);\n          this.startHeartbeat();\n          resolve();\n        };\n\n        this.socket.onerror = (error) => {\n          console.error('[DEBUG] WebSocket connection error:', error);\n          clearTimeout(timeout);\n          reject(error);\n        };\n\n        this.socket.onclose = this.handleClose;\n      }\n    });\n  }\n\n  private startHeartbeat(): void {\n    if (this.heartbeatInterval) {\n      clearInterval(this.heartbeatInterval);\n    }\n\n    this.heartbeatInterval = setInterval(() => {\n      if (this.socket?.readyState === WebSocket.OPEN) {\n        this.socket.send(JSON.stringify({ type: 'ping' }));\n        \n        // Check if we haven't received a response in too long\n        if (Date.now() - this.lastHeartbeatResponse > HEARTBEAT_TIMEOUT) {\n          console.error('[DEBUG] Heartbeat timeout, reconnecting...');\n          this.handleReconnect();\n        }\n      }\n    }, HEARTBEAT_INTERVAL);\n  }\n\n  private async handleReconnect(): Promise<void> {\n    if (this.isReconnecting || !this.currentChannelId) return;\n\n    this.isReconnecting = true;\n    const delay = Math.min(INITIAL_RECONNECT_DELAY * Math.pow(2, this.reconnectAttempts), MAX_RECONNECT_DELAY);\n    \n    console.log(`[DEBUG] Attempting to reconnect in ${delay}ms (attempt ${this.reconnectAttempts + 1})`);\n    \n    this.reconnectTimeout = setTimeout(async () => {\n      try {\n        this.reconnectAttempts++;\n        await this.connect(this.currentChannelId!);\n        this.isReconnecting = false;\n        this.reconnectAttempts = 0;\n        console.log('[DEBUG] Reconnection successful');\n      } catch (error) {\n        console.error('[DEBUG] Reconnection failed:', error);\n        this.handleReconnect();\n      }\n    }, delay);\n  }\n\n  private async processMessageQueue(): Promise<void> {\n    if (this.processingQueue) return;\n\n    this.processingQueue = true;\n    try {\n      while (this.isConnected()) {\n        const channelId = this.currentChannelId;\n        if (!channelId) break;\n\n        const queuedMessage = messageQueue.getNextMessage(channelId);\n        if (!queuedMessage) break;\n\n        try {\n          const message = {\n            type: queuedMessage.type,\n            data: {\n              channel_id: parseInt(queuedMessage.channelId),\n              content: queuedMessage.content,\n              parent_id: queuedMessage.parentId\n            }\n          };\n\n          if (this.socket?.readyState === WebSocket.OPEN) {\n            messageQueue.markMessageAttempted(channelId, queuedMessage.id);\n            this.socket.send(JSON.stringify(message));\n            // Don't wait for acknowledgment, let the message handler deal with it\n          } else {\n            break;\n          }\n        } catch (error) {\n          console.error('[DEBUG] Error sending queued message:', error);\n          break;\n        }\n      }\n    } finally {\n      this.processingQueue = false;\n    }\n  }\n\n  private handleClose = (event: CloseEvent) => {\n    console.error(`[DEBUG] WebSocket closed with code ${event.code}`);\n    this.handleReconnect();\n  };\n\n  public async sendMessage(channelId: string, content: string, parentId?: string): Promise<void> {\n    // Always queue the message first\n    const messageId = messageQueue.addMessage(channelId, content, parentId ? 'reply' : 'message', parentId);\n\n    const userId = store.getState().auth.user?.id;\n    if (!userId) {\n      throw new Error('User not authenticated');\n    }\n\n    // Create the raw message\n    const rawMessage: RawMessage = {\n      id: messageId,\n      content: content,\n      channel_id: parseInt(channelId),\n      sender_id: userId,\n      created_at: new Date().toISOString(),\n      updated_at: new Date().toISOString(),\n      parent_id: parentId\n    };\n\n    // Create the message data\n    const messageData: WebSocketMessageData = {\n      channel_id: parseInt(channelId),\n      content: content,\n      parent_id: parentId,\n      message: rawMessage\n    };\n\n    // Transform to store message for immediate display\n    const storeMessage = transformMessage(rawMessage);\n\n    // Broadcast the message immediately to all handlers\n    this.messageHandlers.forEach(handler => {\n      try {\n        handler({\n          type: 'new_message',\n          data: messageData\n        });\n      } catch (error) {\n        console.error('[DEBUG] Error in message handler:', error);\n      }\n    });\n\n    // Connect if not connected\n    if (!this.isConnectedToChannel(channelId)) {\n      try {\n        await this.connect(channelId);\n      } catch (error) {\n        console.error('[DEBUG] Failed to connect:', error);\n        return; // Message is already queued and displayed, will be sent after reconnection\n      }\n    }\n\n    // Send the message if connected\n    if (this.socket?.readyState === WebSocket.OPEN) {\n      try {\n        messageQueue.markMessageAttempted(channelId, messageId);\n        this.socket.send(JSON.stringify({\n          type: parentId ? 'reply' : 'message',\n          data: messageData\n        }));\n      } catch (error) {\n        console.error('[DEBUG] Error sending message:', error);\n      }\n    }\n  }\n\n  public async joinChannel(channelId: string): Promise<void> {\n    if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {\n      throw new Error('Cannot join channel: WebSocket is not connected');\n    }\n\n    if (this.isConnectedToChannel(channelId)) {\n      console.log('[DEBUG] Already joined channel:', channelId);\n      return;\n    }\n\n    return new Promise((resolve, reject) => {\n      const joinMessage = {\n        type: 'join',\n        data: {\n          channel_id: parseInt(channelId)\n        }\n      };\n      \n      const joinTimeout = setTimeout(() => {\n        this.socket?.removeEventListener('message', handleJoinResponse);\n        reject(new Error('Channel join timeout'));\n      }, 10000);\n      \n      const handleJoinResponse = (event: MessageEvent) => {\n        try {\n          const data = JSON.parse(event.data);\n          console.log('[DEBUG] Received join response:', data);\n          \n          if (data.type === 'joined' && data.data?.channel_id?.toString() === channelId) {\n            clearTimeout(joinTimeout);\n            this.socket?.removeEventListener('message', handleJoinResponse);\n            this.joinedChannels.add(channelId);\n            console.log('[DEBUG] Successfully joined channel:', channelId);\n            resolve();\n          } else if (data.type === 'error') {\n            clearTimeout(joinTimeout);\n            this.socket?.removeEventListener('message', handleJoinResponse);\n            console.error('[DEBUG] Error joining channel:', data.message);\n            reject(new Error(data.message));\n          }\n        } catch (error) {\n          console.error('[DEBUG] Error handling join response:', error);\n        }\n      };\n\n      if (this.socket) {\n        this.socket.addEventListener('message', handleJoinResponse);\n        console.log('[DEBUG] Sending join message:', joinMessage);\n        this.socket.send(JSON.stringify(joinMessage));\n      } else {\n        clearTimeout(joinTimeout);\n        reject(new Error('WebSocket not available'));\n      }\n    });\n  }\n\n  private handleError(error: Error): void {\n    console.error('WebSocket error:', error);\n    this.errorHandlers.forEach(handler => handler(error));\n  }\n\n  public isConnected(): boolean {\n    return this.socket !== null && this.socket.readyState === WebSocket.OPEN;\n  }\n\n  private isConnectedToChannel(channelId: string): boolean {\n    return this.isConnected() && this.joinedChannels.has(channelId) && this.currentChannelId === channelId;\n  }\n\n  public onMessage(handler: (message: WebSocketMessage) => void): () => void {\n    this.messageHandlers.push(handler);\n    return () => {\n      this.messageHandlers = this.messageHandlers.filter(h => h !== handler);\n    };\n  }\n\n  public onError(handler: (error: Error) => void): () => void {\n    this.errorHandlers.push(handler);\n    return () => {\n      this.errorHandlers = this.errorHandlers.filter(h => h !== handler);\n    };\n  }\n\n  public disconnect(): void {\n    console.log('[DEBUG] Disconnecting WebSocket...');\n    this.isReconnecting = false;\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n    if (this.heartbeatInterval) {\n      clearInterval(this.heartbeatInterval);\n      this.heartbeatInterval = null;\n    }\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\n      this.socket.close(1000);\n    }\n    this.socket = null;\n    this.joinedChannels.clear();\n    this.messageHandlers = [];\n    this.errorHandlers = [];\n    this.reconnectAttempts = 0;\n    this.connectionPromise = null;\n    this.joinPromise = null;\n    this.currentChannelId = null;\n    console.log('[DEBUG] WebSocket disconnected and state cleared');\n  }\n\n  private handleWebSocketMessage = (event: MessageEvent) => {\n    try {\n      const message = JSON.parse(event.data) as WebSocketMessage;\n      \n      // Update heartbeat timestamp for any message\n      this.lastHeartbeatResponse = Date.now();\n\n      if (message.type === 'pong') {\n        return;\n      }\n\n      // Handle message acknowledgments and update message ID\n      if (message.type === 'message_sent' && message.data?.message) {\n        const channelId = message.data.channel_id?.toString();\n        const messageId = message.data.message.id.toString();\n        const tempMessageId = message.data.message.content;\n        \n        if (channelId && messageId) {\n          messageQueue.markMessageSent(channelId, messageId);\n          \n          // Update message ID in store if needed\n          if (tempMessageId !== messageId) {\n            const storeMessage = transformMessage(message.data.message);\n            store.dispatch(updateMessage({\n              channelId,\n              id: tempMessageId,\n              message: storeMessage\n            }));\n          }\n        }\n      } else if (message.type === 'error' && message.data?.error) {\n        console.error('[DEBUG] Message send error:', message.data.error);\n        this.handleError(new Error(message.data.error));\n      } else {\n        // Broadcast other messages to all handlers immediately\n        this.messageHandlers.forEach(handler => {\n          try {\n            handler(message);\n          } catch (error) {\n            console.error('[DEBUG] Error in message handler:', error);\n          }\n        });\n      }\n    } catch (error) {\n      console.error('[DEBUG] Error handling WebSocket message:', error);\n    }\n  };\n\n  public offMessage(handler: (message: WebSocketMessage) => void): void {\n    this.messageHandlers = this.messageHandlers.filter(h => h !== handler);\n  }\n\n  public offError(handler: (error: Error) => void): void {\n    this.errorHandlers = this.errorHandlers.filter(h => h !== handler);\n  }\n\n  public getChatSocketState(): number {\n    return this.socket?.readyState || WebSocket.CLOSED;\n  }\n}\n\nconst wsService = new WebSocketService();\nexport default wsService; "],"mappings":"AACA,SAASA,YAAY,QAAQ,aAAa;AAC1C,SAASC,KAAK,QAAQ,aAAa;AACnC,SAAqBC,aAAa,QAAQ,oCAAoC;AAC9E,OAAOC,YAAY,MAAM,gBAAgB;AACzC,SAASC,gBAAgB,QAAQ,8BAA8B;;AAE/D;AACA,MAAMC,uBAAuB,GAAG,IAAI;AACpC,MAAMC,mBAAmB,GAAG,KAAK;AACjC,MAAMC,kBAAkB,GAAG,KAAK;AAChC,MAAMC,iBAAiB,GAAG,KAAK;AAC/B,MAAMC,kBAAkB,GAAG,IAAI;AAE/B,MAAMC,gBAAgB,CAAC;EAAAC,YAAA;IAAA,KACbC,MAAM,GAAqB,IAAI;IAAA,KAC/BC,eAAe,GAA4C,EAAE;IAAA,KAC7DC,aAAa,GAA+B,EAAE;IAAA,KAC9CC,gBAAgB,GAAkB,IAAI;IAAA,KACtCC,cAAc,GAAgB,IAAIC,GAAG,CAAC,CAAC;IAAA,KACvCC,iBAAiB,GAAG,CAAC;IAAA,KACrBC,gBAAgB,GAA0B,IAAI;IAAA,KAC9CC,cAAc,GAAG,KAAK;IAAA,KACtBC,iBAAiB,GAAyB,IAAI;IAAA,KAC9CC,WAAW,GAAyB,IAAI;IAAA,KACxCC,aAAa,GAAkB,IAAI;IAAA,KACnCC,eAAe,GAAG,KAAK;IAAA,KACvBC,iBAAiB,GAA0B,IAAI;IAAA,KAC/CC,qBAAqB,GAAWC,IAAI,CAACC,GAAG,CAAC,CAAC;IAAA,KAC1CC,mBAAmB,GAAW,CAAC;IAAA,KA6J/BC,WAAW,GAAIC,KAAiB,IAAK;MAC3CC,OAAO,CAACC,KAAK,CAAC,sCAAsCF,KAAK,CAACG,IAAI,EAAE,CAAC;MACjE,IAAI,CAACC,eAAe,CAAC,CAAC;IACxB,CAAC;IAAA,KAiLOC,sBAAsB,GAAIL,KAAmB,IAAK;MACxD,IAAI;QAAA,IAAAM,aAAA,EAAAC,cAAA;QACF,MAAMC,OAAO,GAAGC,IAAI,CAACC,KAAK,CAACV,KAAK,CAACW,IAAI,CAAqB;;QAE1D;QACA,IAAI,CAAChB,qBAAqB,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC;QAEvC,IAAIW,OAAO,CAACI,IAAI,KAAK,MAAM,EAAE;UAC3B;QACF;;QAEA;QACA,IAAIJ,OAAO,CAACI,IAAI,KAAK,cAAc,KAAAN,aAAA,GAAIE,OAAO,CAACG,IAAI,cAAAL,aAAA,eAAZA,aAAA,CAAcE,OAAO,EAAE;UAAA,IAAAK,qBAAA;UAC5D,MAAMC,SAAS,IAAAD,qBAAA,GAAGL,OAAO,CAACG,IAAI,CAACI,UAAU,cAAAF,qBAAA,uBAAvBA,qBAAA,CAAyBG,QAAQ,CAAC,CAAC;UACrD,MAAMC,SAAS,GAAGT,OAAO,CAACG,IAAI,CAACH,OAAO,CAACU,EAAE,CAACF,QAAQ,CAAC,CAAC;UACpD,MAAMG,aAAa,GAAGX,OAAO,CAACG,IAAI,CAACH,OAAO,CAACY,OAAO;UAElD,IAAIN,SAAS,IAAIG,SAAS,EAAE;YAC1B7C,YAAY,CAACiD,eAAe,CAACP,SAAS,EAAEG,SAAS,CAAC;;YAElD;YACA,IAAIE,aAAa,KAAKF,SAAS,EAAE;cAC/B,MAAMK,YAAY,GAAGjD,gBAAgB,CAACmC,OAAO,CAACG,IAAI,CAACH,OAAO,CAAC;cAC3DtC,KAAK,CAACqD,QAAQ,CAACpD,aAAa,CAAC;gBAC3B2C,SAAS;gBACTI,EAAE,EAAEC,aAAa;gBACjBX,OAAO,EAAEc;cACX,CAAC,CAAC,CAAC;YACL;UACF;QACF,CAAC,MAAM,IAAId,OAAO,CAACI,IAAI,KAAK,OAAO,KAAAL,cAAA,GAAIC,OAAO,CAACG,IAAI,cAAAJ,cAAA,eAAZA,cAAA,CAAcL,KAAK,EAAE;UAC1DD,OAAO,CAACC,KAAK,CAAC,6BAA6B,EAAEM,OAAO,CAACG,IAAI,CAACT,KAAK,CAAC;UAChE,IAAI,CAACsB,WAAW,CAAC,IAAIC,KAAK,CAACjB,OAAO,CAACG,IAAI,CAACT,KAAK,CAAC,CAAC;QACjD,CAAC,MAAM;UACL;UACA,IAAI,CAACpB,eAAe,CAAC4C,OAAO,CAACC,OAAO,IAAI;YACtC,IAAI;cACFA,OAAO,CAACnB,OAAO,CAAC;YAClB,CAAC,CAAC,OAAON,KAAK,EAAE;cACdD,OAAO,CAACC,KAAK,CAAC,mCAAmC,EAAEA,KAAK,CAAC;YAC3D;UACF,CAAC,CAAC;QACJ;MACF,CAAC,CAAC,OAAOA,KAAK,EAAE;QACdD,OAAO,CAACC,KAAK,CAAC,2CAA2C,EAAEA,KAAK,CAAC;MACnE;IACF,CAAC;EAAA;EA7XD,MAAa0B,OAAOA,CAACd,SAAiB,EAAiB;IACrD,IAAI,IAAI,CAACe,WAAW,CAAC,CAAC,IAAI,IAAI,CAACC,oBAAoB,CAAChB,SAAS,CAAC,EAAE;MAC9D;IACF;;IAEA;IACA,IAAI,CAACiB,UAAU,CAAC,CAAC;IACjB,IAAI,CAAC/C,gBAAgB,GAAG8B,SAAS;IACjC,IAAI,CAACzB,cAAc,GAAG,KAAK;IAC3B,IAAI,CAACF,iBAAiB,GAAG,CAAC;IAC1B,IAAI,CAACW,mBAAmB,GAAGF,IAAI,CAACC,GAAG,CAAC,CAAC;IAErC,IAAI;MACF,MAAMmC,KAAK,GAAG/D,YAAY,CAAC,CAAC;MAC5B,IAAI,CAAC+D,KAAK,EAAE;QACV,MAAM,IAAIP,KAAK,CAAC,+BAA+B,CAAC;MAClD;MAEA,IAAI,CAAC5C,MAAM,GAAG,IAAIoD,SAAS,CAAC,qCAAqCD,KAAK,EAAE,CAAC;;MAEzE;MACA,IAAI,CAACnD,MAAM,CAACqD,OAAO,GAAG,MAAM;QAC1BjC,OAAO,CAACC,KAAK,CAAC,uCAAuC,CAAC;QACtD,IAAI,CAACE,eAAe,CAAC,CAAC;MACxB,CAAC;MAED,IAAI,CAACvB,MAAM,CAACsD,OAAO,GAAIjC,KAAK,IAAK;QAC/BD,OAAO,CAACC,KAAK,CAAC,0BAA0B,EAAEA,KAAK,CAAC;QAChD,IAAI,CAACsB,WAAW,CAACtB,KAAK,YAAYuB,KAAK,GAAGvB,KAAK,GAAG,IAAIuB,KAAK,CAAC,iBAAiB,CAAC,CAAC;MACjF,CAAC;MAED,MAAM,IAAI,CAACW,iBAAiB,CAAC,CAAC;MAE9B,IAAI,IAAI,CAACvD,MAAM,EAAE;QACf,IAAI,CAACA,MAAM,CAACwD,SAAS,GAAG,IAAI,CAAChC,sBAAsB;QACnD,MAAM,IAAI,CAACiC,WAAW,CAACxB,SAAS,CAAC;;QAEjC;QACA,IAAI,CAACyB,cAAc,CAAC,CAAC;;QAErB;QACA,MAAM,IAAI,CAACC,mBAAmB,CAAC,CAAC;MAClC;IAEF,CAAC,CAAC,OAAOtC,KAAK,EAAE;MACdD,OAAO,CAACC,KAAK,CAAC,sCAAsC,EAAEA,KAAK,CAAC;MAC5D,IAAI,CAACsB,WAAW,CAACtB,KAAK,YAAYuB,KAAK,GAAGvB,KAAK,GAAG,IAAIuB,KAAK,CAAC,6BAA6B,CAAC,CAAC;MAC3F,MAAMvB,KAAK;IACb;EACF;EAEA,MAAckC,iBAAiBA,CAAA,EAAkB;IAC/C,OAAO,IAAIK,OAAO,CAAO,CAACC,OAAO,EAAEC,MAAM,KAAK;MAC5C,MAAMC,OAAO,GAAGC,UAAU,CAAC,MAAM;QAC/BF,MAAM,CAAC,IAAIlB,KAAK,CAAC,8BAA8B,CAAC,CAAC;MACnD,CAAC,EAAE/C,kBAAkB,CAAC;MAEtB,IAAI,IAAI,CAACG,MAAM,EAAE;QACf,IAAI,CAACA,MAAM,CAACiE,MAAM,GAAG,MAAM;UACzB7C,OAAO,CAAC8C,GAAG,CAAC,qCAAqC,CAAC;UAClDC,YAAY,CAACJ,OAAO,CAAC;UACrB,IAAI,CAACL,cAAc,CAAC,CAAC;UACrBG,OAAO,CAAC,CAAC;QACX,CAAC;QAED,IAAI,CAAC7D,MAAM,CAACsD,OAAO,GAAIjC,KAAK,IAAK;UAC/BD,OAAO,CAACC,KAAK,CAAC,qCAAqC,EAAEA,KAAK,CAAC;UAC3D8C,YAAY,CAACJ,OAAO,CAAC;UACrBD,MAAM,CAACzC,KAAK,CAAC;QACf,CAAC;QAED,IAAI,CAACrB,MAAM,CAACqD,OAAO,GAAG,IAAI,CAACnC,WAAW;MACxC;IACF,CAAC,CAAC;EACJ;EAEQwC,cAAcA,CAAA,EAAS;IAC7B,IAAI,IAAI,CAAC7C,iBAAiB,EAAE;MAC1BuD,aAAa,CAAC,IAAI,CAACvD,iBAAiB,CAAC;IACvC;IAEA,IAAI,CAACA,iBAAiB,GAAGwD,WAAW,CAAC,MAAM;MAAA,IAAAC,YAAA;MACzC,IAAI,EAAAA,YAAA,OAAI,CAACtE,MAAM,cAAAsE,YAAA,uBAAXA,YAAA,CAAaC,UAAU,MAAKnB,SAAS,CAACoB,IAAI,EAAE;QAC9C,IAAI,CAACxE,MAAM,CAACyE,IAAI,CAAC7C,IAAI,CAAC8C,SAAS,CAAC;UAAE3C,IAAI,EAAE;QAAO,CAAC,CAAC,CAAC;;QAElD;QACA,IAAIhB,IAAI,CAACC,GAAG,CAAC,CAAC,GAAG,IAAI,CAACF,qBAAqB,GAAGlB,iBAAiB,EAAE;UAC/DwB,OAAO,CAACC,KAAK,CAAC,4CAA4C,CAAC;UAC3D,IAAI,CAACE,eAAe,CAAC,CAAC;QACxB;MACF;IACF,CAAC,EAAE5B,kBAAkB,CAAC;EACxB;EAEA,MAAc4B,eAAeA,CAAA,EAAkB;IAC7C,IAAI,IAAI,CAACf,cAAc,IAAI,CAAC,IAAI,CAACL,gBAAgB,EAAE;IAEnD,IAAI,CAACK,cAAc,GAAG,IAAI;IAC1B,MAAMmE,KAAK,GAAGC,IAAI,CAACC,GAAG,CAACpF,uBAAuB,GAAGmF,IAAI,CAACE,GAAG,CAAC,CAAC,EAAE,IAAI,CAACxE,iBAAiB,CAAC,EAAEZ,mBAAmB,CAAC;IAE1G0B,OAAO,CAAC8C,GAAG,CAAC,sCAAsCS,KAAK,eAAe,IAAI,CAACrE,iBAAiB,GAAG,CAAC,GAAG,CAAC;IAEpG,IAAI,CAACC,gBAAgB,GAAGyD,UAAU,CAAC,YAAY;MAC7C,IAAI;QACF,IAAI,CAAC1D,iBAAiB,EAAE;QACxB,MAAM,IAAI,CAACyC,OAAO,CAAC,IAAI,CAAC5C,gBAAiB,CAAC;QAC1C,IAAI,CAACK,cAAc,GAAG,KAAK;QAC3B,IAAI,CAACF,iBAAiB,GAAG,CAAC;QAC1Bc,OAAO,CAAC8C,GAAG,CAAC,iCAAiC,CAAC;MAChD,CAAC,CAAC,OAAO7C,KAAK,EAAE;QACdD,OAAO,CAACC,KAAK,CAAC,8BAA8B,EAAEA,KAAK,CAAC;QACpD,IAAI,CAACE,eAAe,CAAC,CAAC;MACxB;IACF,CAAC,EAAEoD,KAAK,CAAC;EACX;EAEA,MAAchB,mBAAmBA,CAAA,EAAkB;IACjD,IAAI,IAAI,CAAC/C,eAAe,EAAE;IAE1B,IAAI,CAACA,eAAe,GAAG,IAAI;IAC3B,IAAI;MACF,OAAO,IAAI,CAACoC,WAAW,CAAC,CAAC,EAAE;QACzB,MAAMf,SAAS,GAAG,IAAI,CAAC9B,gBAAgB;QACvC,IAAI,CAAC8B,SAAS,EAAE;QAEhB,MAAM8C,aAAa,GAAGxF,YAAY,CAACyF,cAAc,CAAC/C,SAAS,CAAC;QAC5D,IAAI,CAAC8C,aAAa,EAAE;QAEpB,IAAI;UAAA,IAAAE,aAAA;UACF,MAAMtD,OAAO,GAAG;YACdI,IAAI,EAAEgD,aAAa,CAAChD,IAAI;YACxBD,IAAI,EAAE;cACJI,UAAU,EAAEgD,QAAQ,CAACH,aAAa,CAAC9C,SAAS,CAAC;cAC7CM,OAAO,EAAEwC,aAAa,CAACxC,OAAO;cAC9B4C,SAAS,EAAEJ,aAAa,CAACK;YAC3B;UACF,CAAC;UAED,IAAI,EAAAH,aAAA,OAAI,CAACjF,MAAM,cAAAiF,aAAA,uBAAXA,aAAA,CAAaV,UAAU,MAAKnB,SAAS,CAACoB,IAAI,EAAE;YAC9CjF,YAAY,CAAC8F,oBAAoB,CAACpD,SAAS,EAAE8C,aAAa,CAAC1C,EAAE,CAAC;YAC9D,IAAI,CAACrC,MAAM,CAACyE,IAAI,CAAC7C,IAAI,CAAC8C,SAAS,CAAC/C,OAAO,CAAC,CAAC;YACzC;UACF,CAAC,MAAM;YACL;UACF;QACF,CAAC,CAAC,OAAON,KAAK,EAAE;UACdD,OAAO,CAACC,KAAK,CAAC,uCAAuC,EAAEA,KAAK,CAAC;UAC7D;QACF;MACF;IACF,CAAC,SAAS;MACR,IAAI,CAACT,eAAe,GAAG,KAAK;IAC9B;EACF;EAOA,MAAa0E,WAAWA,CAACrD,SAAiB,EAAEM,OAAe,EAAE6C,QAAiB,EAAiB;IAAA,IAAAG,qBAAA,EAAAC,aAAA;IAC7F;IACA,MAAMpD,SAAS,GAAG7C,YAAY,CAACkG,UAAU,CAACxD,SAAS,EAAEM,OAAO,EAAE6C,QAAQ,GAAG,OAAO,GAAG,SAAS,EAAEA,QAAQ,CAAC;IAEvG,MAAMM,MAAM,IAAAH,qBAAA,GAAGlG,KAAK,CAACsG,QAAQ,CAAC,CAAC,CAACC,IAAI,CAACC,IAAI,cAAAN,qBAAA,uBAA1BA,qBAAA,CAA4BlD,EAAE;IAC7C,IAAI,CAACqD,MAAM,EAAE;MACX,MAAM,IAAI9C,KAAK,CAAC,wBAAwB,CAAC;IAC3C;;IAEA;IACA,MAAMkD,UAAsB,GAAG;MAC7BzD,EAAE,EAAED,SAAS;MACbG,OAAO,EAAEA,OAAO;MAChBL,UAAU,EAAEgD,QAAQ,CAACjD,SAAS,CAAC;MAC/B8D,SAAS,EAAEL,MAAM;MACjBM,UAAU,EAAE,IAAIjF,IAAI,CAAC,CAAC,CAACkF,WAAW,CAAC,CAAC;MACpCC,UAAU,EAAE,IAAInF,IAAI,CAAC,CAAC,CAACkF,WAAW,CAAC,CAAC;MACpCd,SAAS,EAAEC;IACb,CAAC;;IAED;IACA,MAAMe,WAAiC,GAAG;MACxCjE,UAAU,EAAEgD,QAAQ,CAACjD,SAAS,CAAC;MAC/BM,OAAO,EAAEA,OAAO;MAChB4C,SAAS,EAAEC,QAAQ;MACnBzD,OAAO,EAAEmE;IACX,CAAC;;IAED;IACA,MAAMrD,YAAY,GAAGjD,gBAAgB,CAACsG,UAAU,CAAC;;IAEjD;IACA,IAAI,CAAC7F,eAAe,CAAC4C,OAAO,CAACC,OAAO,IAAI;MACtC,IAAI;QACFA,OAAO,CAAC;UACNf,IAAI,EAAE,aAAa;UACnBD,IAAI,EAAEqE;QACR,CAAC,CAAC;MACJ,CAAC,CAAC,OAAO9E,KAAK,EAAE;QACdD,OAAO,CAACC,KAAK,CAAC,mCAAmC,EAAEA,KAAK,CAAC;MAC3D;IACF,CAAC,CAAC;;IAEF;IACA,IAAI,CAAC,IAAI,CAAC4B,oBAAoB,CAAChB,SAAS,CAAC,EAAE;MACzC,IAAI;QACF,MAAM,IAAI,CAACc,OAAO,CAACd,SAAS,CAAC;MAC/B,CAAC,CAAC,OAAOZ,KAAK,EAAE;QACdD,OAAO,CAACC,KAAK,CAAC,4BAA4B,EAAEA,KAAK,CAAC;QAClD,OAAO,CAAC;MACV;IACF;;IAEA;IACA,IAAI,EAAAmE,aAAA,OAAI,CAACxF,MAAM,cAAAwF,aAAA,uBAAXA,aAAA,CAAajB,UAAU,MAAKnB,SAAS,CAACoB,IAAI,EAAE;MAC9C,IAAI;QACFjF,YAAY,CAAC8F,oBAAoB,CAACpD,SAAS,EAAEG,SAAS,CAAC;QACvD,IAAI,CAACpC,MAAM,CAACyE,IAAI,CAAC7C,IAAI,CAAC8C,SAAS,CAAC;UAC9B3C,IAAI,EAAEqD,QAAQ,GAAG,OAAO,GAAG,SAAS;UACpCtD,IAAI,EAAEqE;QACR,CAAC,CAAC,CAAC;MACL,CAAC,CAAC,OAAO9E,KAAK,EAAE;QACdD,OAAO,CAACC,KAAK,CAAC,gCAAgC,EAAEA,KAAK,CAAC;MACxD;IACF;EACF;EAEA,MAAaoC,WAAWA,CAACxB,SAAiB,EAAiB;IACzD,IAAI,CAAC,IAAI,CAACjC,MAAM,IAAI,IAAI,CAACA,MAAM,CAACuE,UAAU,KAAKnB,SAAS,CAACoB,IAAI,EAAE;MAC7D,MAAM,IAAI5B,KAAK,CAAC,iDAAiD,CAAC;IACpE;IAEA,IAAI,IAAI,CAACK,oBAAoB,CAAChB,SAAS,CAAC,EAAE;MACxCb,OAAO,CAAC8C,GAAG,CAAC,iCAAiC,EAAEjC,SAAS,CAAC;MACzD;IACF;IAEA,OAAO,IAAI2B,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACtC,MAAMsC,WAAW,GAAG;QAClBrE,IAAI,EAAE,MAAM;QACZD,IAAI,EAAE;UACJI,UAAU,EAAEgD,QAAQ,CAACjD,SAAS;QAChC;MACF,CAAC;MAED,MAAMoE,WAAW,GAAGrC,UAAU,CAAC,MAAM;QAAA,IAAAsC,aAAA;QACnC,CAAAA,aAAA,OAAI,CAACtG,MAAM,cAAAsG,aAAA,uBAAXA,aAAA,CAAaC,mBAAmB,CAAC,SAAS,EAAEC,kBAAkB,CAAC;QAC/D1C,MAAM,CAAC,IAAIlB,KAAK,CAAC,sBAAsB,CAAC,CAAC;MAC3C,CAAC,EAAE,KAAK,CAAC;MAET,MAAM4D,kBAAkB,GAAIrF,KAAmB,IAAK;QAClD,IAAI;UAAA,IAAAsF,UAAA,EAAAC,qBAAA;UACF,MAAM5E,IAAI,GAAGF,IAAI,CAACC,KAAK,CAACV,KAAK,CAACW,IAAI,CAAC;UACnCV,OAAO,CAAC8C,GAAG,CAAC,iCAAiC,EAAEpC,IAAI,CAAC;UAEpD,IAAIA,IAAI,CAACC,IAAI,KAAK,QAAQ,IAAI,EAAA0E,UAAA,GAAA3E,IAAI,CAACA,IAAI,cAAA2E,UAAA,wBAAAC,qBAAA,GAATD,UAAA,CAAWvE,UAAU,cAAAwE,qBAAA,uBAArBA,qBAAA,CAAuBvE,QAAQ,CAAC,CAAC,MAAKF,SAAS,EAAE;YAAA,IAAA0E,aAAA;YAC7ExC,YAAY,CAACkC,WAAW,CAAC;YACzB,CAAAM,aAAA,OAAI,CAAC3G,MAAM,cAAA2G,aAAA,uBAAXA,aAAA,CAAaJ,mBAAmB,CAAC,SAAS,EAAEC,kBAAkB,CAAC;YAC/D,IAAI,CAACpG,cAAc,CAACwG,GAAG,CAAC3E,SAAS,CAAC;YAClCb,OAAO,CAAC8C,GAAG,CAAC,sCAAsC,EAAEjC,SAAS,CAAC;YAC9D4B,OAAO,CAAC,CAAC;UACX,CAAC,MAAM,IAAI/B,IAAI,CAACC,IAAI,KAAK,OAAO,EAAE;YAAA,IAAA8E,aAAA;YAChC1C,YAAY,CAACkC,WAAW,CAAC;YACzB,CAAAQ,aAAA,OAAI,CAAC7G,MAAM,cAAA6G,aAAA,uBAAXA,aAAA,CAAaN,mBAAmB,CAAC,SAAS,EAAEC,kBAAkB,CAAC;YAC/DpF,OAAO,CAACC,KAAK,CAAC,gCAAgC,EAAES,IAAI,CAACH,OAAO,CAAC;YAC7DmC,MAAM,CAAC,IAAIlB,KAAK,CAACd,IAAI,CAACH,OAAO,CAAC,CAAC;UACjC;QACF,CAAC,CAAC,OAAON,KAAK,EAAE;UACdD,OAAO,CAACC,KAAK,CAAC,uCAAuC,EAAEA,KAAK,CAAC;QAC/D;MACF,CAAC;MAED,IAAI,IAAI,CAACrB,MAAM,EAAE;QACf,IAAI,CAACA,MAAM,CAAC8G,gBAAgB,CAAC,SAAS,EAAEN,kBAAkB,CAAC;QAC3DpF,OAAO,CAAC8C,GAAG,CAAC,+BAA+B,EAAEkC,WAAW,CAAC;QACzD,IAAI,CAACpG,MAAM,CAACyE,IAAI,CAAC7C,IAAI,CAAC8C,SAAS,CAAC0B,WAAW,CAAC,CAAC;MAC/C,CAAC,MAAM;QACLjC,YAAY,CAACkC,WAAW,CAAC;QACzBvC,MAAM,CAAC,IAAIlB,KAAK,CAAC,yBAAyB,CAAC,CAAC;MAC9C;IACF,CAAC,CAAC;EACJ;EAEQD,WAAWA,CAACtB,KAAY,EAAQ;IACtCD,OAAO,CAACC,KAAK,CAAC,kBAAkB,EAAEA,KAAK,CAAC;IACxC,IAAI,CAACnB,aAAa,CAAC2C,OAAO,CAACC,OAAO,IAAIA,OAAO,CAACzB,KAAK,CAAC,CAAC;EACvD;EAEO2B,WAAWA,CAAA,EAAY;IAC5B,OAAO,IAAI,CAAChD,MAAM,KAAK,IAAI,IAAI,IAAI,CAACA,MAAM,CAACuE,UAAU,KAAKnB,SAAS,CAACoB,IAAI;EAC1E;EAEQvB,oBAAoBA,CAAChB,SAAiB,EAAW;IACvD,OAAO,IAAI,CAACe,WAAW,CAAC,CAAC,IAAI,IAAI,CAAC5C,cAAc,CAAC2G,GAAG,CAAC9E,SAAS,CAAC,IAAI,IAAI,CAAC9B,gBAAgB,KAAK8B,SAAS;EACxG;EAEO+E,SAASA,CAAClE,OAA4C,EAAc;IACzE,IAAI,CAAC7C,eAAe,CAACgH,IAAI,CAACnE,OAAO,CAAC;IAClC,OAAO,MAAM;MACX,IAAI,CAAC7C,eAAe,GAAG,IAAI,CAACA,eAAe,CAACiH,MAAM,CAACC,CAAC,IAAIA,CAAC,KAAKrE,OAAO,CAAC;IACxE,CAAC;EACH;EAEOsE,OAAOA,CAACtE,OAA+B,EAAc;IAC1D,IAAI,CAAC5C,aAAa,CAAC+G,IAAI,CAACnE,OAAO,CAAC;IAChC,OAAO,MAAM;MACX,IAAI,CAAC5C,aAAa,GAAG,IAAI,CAACA,aAAa,CAACgH,MAAM,CAACC,CAAC,IAAIA,CAAC,KAAKrE,OAAO,CAAC;IACpE,CAAC;EACH;EAEOI,UAAUA,CAAA,EAAS;IACxB9B,OAAO,CAAC8C,GAAG,CAAC,oCAAoC,CAAC;IACjD,IAAI,CAAC1D,cAAc,GAAG,KAAK;IAC3B,IAAI,IAAI,CAACD,gBAAgB,EAAE;MACzB4D,YAAY,CAAC,IAAI,CAAC5D,gBAAgB,CAAC;MACnC,IAAI,CAACA,gBAAgB,GAAG,IAAI;IAC9B;IACA,IAAI,IAAI,CAACM,iBAAiB,EAAE;MAC1BuD,aAAa,CAAC,IAAI,CAACvD,iBAAiB,CAAC;MACrC,IAAI,CAACA,iBAAiB,GAAG,IAAI;IAC/B;IACA,IAAI,IAAI,CAACb,MAAM,IAAI,IAAI,CAACA,MAAM,CAACuE,UAAU,KAAKnB,SAAS,CAACoB,IAAI,EAAE;MAC5D,IAAI,CAACxE,MAAM,CAACqH,KAAK,CAAC,IAAI,CAAC;IACzB;IACA,IAAI,CAACrH,MAAM,GAAG,IAAI;IAClB,IAAI,CAACI,cAAc,CAACkH,KAAK,CAAC,CAAC;IAC3B,IAAI,CAACrH,eAAe,GAAG,EAAE;IACzB,IAAI,CAACC,aAAa,GAAG,EAAE;IACvB,IAAI,CAACI,iBAAiB,GAAG,CAAC;IAC1B,IAAI,CAACG,iBAAiB,GAAG,IAAI;IAC7B,IAAI,CAACC,WAAW,GAAG,IAAI;IACvB,IAAI,CAACP,gBAAgB,GAAG,IAAI;IAC5BiB,OAAO,CAAC8C,GAAG,CAAC,kDAAkD,CAAC;EACjE;EAkDOqD,UAAUA,CAACzE,OAA4C,EAAQ;IACpE,IAAI,CAAC7C,eAAe,GAAG,IAAI,CAACA,eAAe,CAACiH,MAAM,CAACC,CAAC,IAAIA,CAAC,KAAKrE,OAAO,CAAC;EACxE;EAEO0E,QAAQA,CAAC1E,OAA+B,EAAQ;IACrD,IAAI,CAAC5C,aAAa,GAAG,IAAI,CAACA,aAAa,CAACgH,MAAM,CAACC,CAAC,IAAIA,CAAC,KAAKrE,OAAO,CAAC;EACpE;EAEO2E,kBAAkBA,CAAA,EAAW;IAAA,IAAAC,aAAA;IAClC,OAAO,EAAAA,aAAA,OAAI,CAAC1H,MAAM,cAAA0H,aAAA,uBAAXA,aAAA,CAAanD,UAAU,KAAInB,SAAS,CAACuE,MAAM;EACpD;AACF;AAEA,MAAMC,SAAS,GAAG,IAAI9H,gBAAgB,CAAC,CAAC;AACxC,eAAe8H,SAAS","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}