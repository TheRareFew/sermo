{"ast":null,"code":"import { getAuthToken } from '../api/auth';\nimport { store } from '../../store';\nimport { addMessage } from '../../store/messages/messagesSlice';\nclass WebSocketService {\n  constructor() {\n    this.socket = null;\n    this.messageHandlers = [];\n    this.errorHandlers = [];\n    this.currentChannelId = null;\n    this.processedMessageIds = new Set();\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectTimeout = null;\n    this.isReconnecting = false;\n    this.handleMessage = event => {\n      try {\n        const message = JSON.parse(event.data);\n        console.log('WebSocket message received:', message);\n\n        // Handle error messages\n        if (message.type === 'error') {\n          console.error('WebSocket error message:', message);\n          this.errorHandlers.forEach(handler => handler({\n            code: message.code || 'UNKNOWN_ERROR',\n            message: message.content || 'Unknown error occurred'\n          }));\n          return;\n        }\n\n        // Handle channel access errors\n        if (message.type === 'channel_access_denied') {\n          console.error('Channel access denied:', message);\n          this.errorHandlers.forEach(handler => handler({\n            code: 'CHANNEL_ACCESS_DENIED',\n            message: message.content || 'Access to this channel was denied'\n          }));\n          return;\n        }\n\n        // Filter out message_sent confirmations\n        if (message.type === 'message_sent') {\n          console.log('Ignoring message_sent confirmation');\n          return;\n        }\n\n        // Handle new messages\n        if (message.type === 'message' && message.message) {\n          const messageId = message.message.id;\n          if (messageId) {\n            if (this.processedMessageIds.has(messageId)) {\n              console.log('Ignoring duplicate message:', messageId);\n              return;\n            }\n            this.processedMessageIds.add(messageId);\n\n            // Limit the size of the Set to prevent memory growth\n            if (this.processedMessageIds.size > 1000) {\n              const idsArray = Array.from(this.processedMessageIds);\n              this.processedMessageIds = new Set(idsArray.slice(-500));\n            }\n\n            // Transform and dispatch the message to Redux store\n            const storeMessage = {\n              id: String(message.message.id),\n              content: message.message.content,\n              channelId: String(message.message.channel_id),\n              userId: String(message.message.sender_id),\n              reactions: [],\n              attachments: [],\n              createdAt: message.message.created_at,\n              updatedAt: message.message.created_at\n            };\n            store.dispatch(addMessage(storeMessage));\n          }\n        }\n\n        // Handle successful messages\n        this.messageHandlers.forEach(handler => handler(message));\n      } catch (error) {\n        console.error('Error parsing WebSocket message:', error);\n      }\n    };\n  }\n  getReconnectDelay() {\n    // Exponential backoff: 1s, 2s, 4s, 8s, 16s\n    return Math.min(1000 * Math.pow(2, this.reconnectAttempts), 16000);\n  }\n  async attemptReconnect(channelId) {\n    if (this.isReconnecting) {\n      console.log('Already attempting to reconnect...');\n      return;\n    }\n    this.isReconnecting = true;\n    if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n      console.error('Max reconnection attempts reached');\n      this.errorHandlers.forEach(handler => handler({\n        code: 'MAX_RECONNECT_ATTEMPTS',\n        message: 'Unable to reconnect after multiple attempts. Please refresh the page.'\n      }));\n      this.isReconnecting = false;\n      return;\n    }\n    console.log(`Attempting to reconnect (attempt ${this.reconnectAttempts + 1}/${this.maxReconnectAttempts})...`);\n    try {\n      await this.connect(channelId);\n      this.reconnectAttempts = 0;\n      this.isReconnecting = false;\n    } catch (error) {\n      this.reconnectAttempts++;\n      this.isReconnecting = false;\n\n      // Schedule next reconnection attempt\n      const delay = this.getReconnectDelay();\n      console.log(`Scheduling next reconnection attempt in ${delay}ms`);\n      this.reconnectTimeout = setTimeout(() => {\n        this.attemptReconnect(channelId);\n      }, delay);\n    }\n  }\n  handleError(error) {\n    let errorMessage = 'WebSocket connection error';\n    if (error instanceof Error) {\n      errorMessage = error.message;\n    } else if (typeof error === 'string') {\n      errorMessage = error;\n    }\n    console.error('WebSocket error:', error);\n    this.errorHandlers.forEach(handler => handler({\n      code: 'WEBSOCKET_ERROR',\n      message: errorMessage\n    }));\n  }\n  connect(channelId) {\n    return new Promise((resolve, reject) => {\n      var _this$socket, _this$socket2;\n      // Clear any existing reconnection timeout\n      if (this.reconnectTimeout) {\n        clearTimeout(this.reconnectTimeout);\n        this.reconnectTimeout = null;\n      }\n\n      // If already connected to this channel, do nothing\n      if (((_this$socket = this.socket) === null || _this$socket === void 0 ? void 0 : _this$socket.readyState) === WebSocket.OPEN && this.currentChannelId === channelId) {\n        console.log('WebSocket already connected to channel', channelId);\n        resolve();\n        return;\n      }\n\n      // If connected to a different channel, disconnect first\n      if (((_this$socket2 = this.socket) === null || _this$socket2 === void 0 ? void 0 : _this$socket2.readyState) === WebSocket.OPEN && this.currentChannelId !== channelId) {\n        console.log('Disconnecting from channel', this.currentChannelId);\n        this.disconnect();\n      }\n      const token = getAuthToken();\n      if (!token) {\n        const error = new Error('No auth token available for WebSocket connection');\n        this.handleError(error);\n        reject(error);\n        return;\n      }\n      const baseWsUrl = process.env.REACT_APP_WS_URL || 'ws://localhost:8000/ws';\n      const wsUrl = `${baseWsUrl}/chat?token=${token}`;\n      console.log('Connecting to WebSocket:', wsUrl);\n      try {\n        this.socket = new WebSocket(wsUrl);\n        this.currentChannelId = channelId;\n        this.processedMessageIds.clear();\n\n        // Set a connection timeout\n        const connectionTimeout = setTimeout(() => {\n          var _this$socket3;\n          if (((_this$socket3 = this.socket) === null || _this$socket3 === void 0 ? void 0 : _this$socket3.readyState) !== WebSocket.OPEN) {\n            var _this$socket4;\n            const error = new Error('WebSocket connection timeout');\n            this.handleError(error);\n            (_this$socket4 = this.socket) === null || _this$socket4 === void 0 ? void 0 : _this$socket4.close();\n            reject(error);\n          }\n        }, 10000);\n        this.socket.onopen = () => {\n          clearTimeout(connectionTimeout);\n          console.log('WebSocket connection opened');\n          this.joinChannel(channelId).then(resolve).catch(error => {\n            this.handleError(error);\n            reject(error);\n          });\n        };\n        this.socket.onmessage = this.handleMessage;\n        this.socket.onerror = event => {\n          this.handleError(event);\n          reject(new Error('WebSocket connection error'));\n        };\n        this.socket.onclose = event => {\n          clearTimeout(connectionTimeout);\n          console.log('WebSocket disconnected with code:', event.code);\n          this.socket = null;\n\n          // Handle specific close codes\n          switch (event.code) {\n            case 1000:\n              // Normal closure\n              this.currentChannelId = null;\n              break;\n            case 1003:\n              // Unsupported\n              this.handleError('WebSocket connection not supported');\n              break;\n            case 4001:\n              // Channel access denied\n              this.handleError('Access to the channel was denied');\n              break;\n            case 4002:\n              // Authentication failed\n              this.handleError('Authentication failed');\n              break;\n            default:\n              // Attempt to reconnect for unexpected closures\n              if (this.currentChannelId) {\n                this.attemptReconnect(this.currentChannelId);\n              }\n          }\n        };\n      } catch (error) {\n        console.error('Error creating WebSocket:', error);\n        this.handleError(error);\n        reject(error);\n      }\n    });\n  }\n  disconnect() {\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n    if (this.socket) {\n      if (this.currentChannelId && this.socket.readyState === WebSocket.OPEN) {\n        const message = {\n          type: 'leave_channel',\n          channel_id: this.currentChannelId\n        };\n        this.socket.send(JSON.stringify(message));\n      }\n      this.socket.close(1000); // Normal closure\n      this.socket = null;\n      this.currentChannelId = null;\n      this.reconnectAttempts = 0;\n      this.isReconnecting = false;\n    }\n  }\n  sendMessage(channelId, content) {\n    var _this$socket5;\n    // If not connected to the right channel, connect first\n    if (this.currentChannelId !== channelId) {\n      console.log('Connecting to channel before sending message');\n      this.connect(channelId);\n    }\n    if (((_this$socket5 = this.socket) === null || _this$socket5 === void 0 ? void 0 : _this$socket5.readyState) === WebSocket.OPEN) {\n      const message = {\n        type: 'message',\n        channel_id: channelId,\n        content: content\n      };\n      this.socket.send(JSON.stringify(message));\n    } else {\n      console.error('WebSocket is not connected');\n      this.errorHandlers.forEach(handler => handler({\n        code: 'NOT_CONNECTED',\n        message: 'WebSocket is not connected'\n      }));\n    }\n  }\n  async joinChannel(channelId) {\n    var _this$socket6;\n    if (((_this$socket6 = this.socket) === null || _this$socket6 === void 0 ? void 0 : _this$socket6.readyState) === WebSocket.OPEN) {\n      console.log('Joining channel:', channelId);\n      const message = {\n        type: 'join_channel',\n        channel_id: parseInt(channelId)\n      };\n      this.socket.send(JSON.stringify(message));\n    } else {\n      console.error('WebSocket is not connected');\n      this.errorHandlers.forEach(handler => handler({\n        code: 'NOT_CONNECTED',\n        message: 'WebSocket is not connected'\n      }));\n    }\n  }\n  leaveChannel(channelId) {\n    var _this$socket7;\n    if (((_this$socket7 = this.socket) === null || _this$socket7 === void 0 ? void 0 : _this$socket7.readyState) === WebSocket.OPEN && this.currentChannelId === channelId) {\n      const message = {\n        type: 'leave_channel',\n        channel_id: channelId\n      };\n      this.socket.send(JSON.stringify(message));\n      this.disconnect();\n    }\n  }\n  onMessage(handler) {\n    this.messageHandlers.push(handler);\n    return () => {\n      this.messageHandlers = this.messageHandlers.filter(h => h !== handler);\n    };\n  }\n  onError(handler) {\n    this.errorHandlers.push(handler);\n    return () => {\n      this.errorHandlers = this.errorHandlers.filter(h => h !== handler);\n    };\n  }\n  getChatSocketState() {\n    var _this$socket8;\n    return ((_this$socket8 = this.socket) === null || _this$socket8 === void 0 ? void 0 : _this$socket8.readyState) || WebSocket.CLOSED;\n  }\n  getCurrentChannelId() {\n    return this.currentChannelId;\n  }\n}\nconst wsService = new WebSocketService();\nexport default wsService;","map":{"version":3,"names":["getAuthToken","store","addMessage","WebSocketService","constructor","socket","messageHandlers","errorHandlers","currentChannelId","processedMessageIds","Set","reconnectAttempts","maxReconnectAttempts","reconnectTimeout","isReconnecting","handleMessage","event","message","JSON","parse","data","console","log","type","error","forEach","handler","code","content","messageId","id","has","add","size","idsArray","Array","from","slice","storeMessage","String","channelId","channel_id","userId","sender_id","reactions","attachments","createdAt","created_at","updatedAt","dispatch","getReconnectDelay","Math","min","pow","attemptReconnect","connect","delay","setTimeout","handleError","errorMessage","Error","Promise","resolve","reject","_this$socket","_this$socket2","clearTimeout","readyState","WebSocket","OPEN","disconnect","token","baseWsUrl","process","env","REACT_APP_WS_URL","wsUrl","clear","connectionTimeout","_this$socket3","_this$socket4","close","onopen","joinChannel","then","catch","onmessage","onerror","onclose","send","stringify","sendMessage","_this$socket5","_this$socket6","parseInt","leaveChannel","_this$socket7","onMessage","push","filter","h","onError","getChatSocketState","_this$socket8","CLOSED","getCurrentChannelId","wsService"],"sources":["Z:/GAUNTLET/projects/SERMO/sermo-app/frontend/src/services/websocket/index.ts"],"sourcesContent":["import { WebSocketMessage } from '../../types';\r\nimport { getAuthToken } from '../api/auth';\r\nimport { store } from '../../store';\r\nimport { addMessage } from '../../store/messages/messagesSlice';\r\n\r\nclass WebSocketService {\r\n  private socket: WebSocket | null = null;\r\n  private messageHandlers: ((message: WebSocketMessage) => void)[] = [];\r\n  private errorHandlers: ((error: { code: string; message: string }) => void)[] = [];\r\n  private currentChannelId: string | null = null;\r\n  private processedMessageIds: Set<string> = new Set();\r\n  private reconnectAttempts: number = 0;\r\n  private maxReconnectAttempts: number = 5;\r\n  private reconnectTimeout: NodeJS.Timeout | null = null;\r\n  private isReconnecting: boolean = false;\r\n\r\n  private getReconnectDelay(): number {\r\n    // Exponential backoff: 1s, 2s, 4s, 8s, 16s\r\n    return Math.min(1000 * Math.pow(2, this.reconnectAttempts), 16000);\r\n  }\r\n\r\n  private async attemptReconnect(channelId: string) {\r\n    if (this.isReconnecting) {\r\n      console.log('Already attempting to reconnect...');\r\n      return;\r\n    }\r\n\r\n    this.isReconnecting = true;\r\n    \r\n    if (this.reconnectAttempts >= this.maxReconnectAttempts) {\r\n      console.error('Max reconnection attempts reached');\r\n      this.errorHandlers.forEach(handler => handler({\r\n        code: 'MAX_RECONNECT_ATTEMPTS',\r\n        message: 'Unable to reconnect after multiple attempts. Please refresh the page.'\r\n      }));\r\n      this.isReconnecting = false;\r\n      return;\r\n    }\r\n\r\n    console.log(`Attempting to reconnect (attempt ${this.reconnectAttempts + 1}/${this.maxReconnectAttempts})...`);\r\n    \r\n    try {\r\n      await this.connect(channelId);\r\n      this.reconnectAttempts = 0;\r\n      this.isReconnecting = false;\r\n    } catch (error) {\r\n      this.reconnectAttempts++;\r\n      this.isReconnecting = false;\r\n      \r\n      // Schedule next reconnection attempt\r\n      const delay = this.getReconnectDelay();\r\n      console.log(`Scheduling next reconnection attempt in ${delay}ms`);\r\n      this.reconnectTimeout = setTimeout(() => {\r\n        this.attemptReconnect(channelId);\r\n      }, delay);\r\n    }\r\n  }\r\n\r\n  private handleError(error: Event | Error | string | unknown) {\r\n    let errorMessage = 'WebSocket connection error';\r\n    if (error instanceof Error) {\r\n      errorMessage = error.message;\r\n    } else if (typeof error === 'string') {\r\n      errorMessage = error;\r\n    }\r\n    console.error('WebSocket error:', error);\r\n    this.errorHandlers.forEach(handler => handler({\r\n      code: 'WEBSOCKET_ERROR',\r\n      message: errorMessage\r\n    }));\r\n  }\r\n\r\n  connect(channelId: string) {\r\n    return new Promise<void>((resolve, reject) => {\r\n      // Clear any existing reconnection timeout\r\n      if (this.reconnectTimeout) {\r\n        clearTimeout(this.reconnectTimeout);\r\n        this.reconnectTimeout = null;\r\n      }\r\n\r\n      // If already connected to this channel, do nothing\r\n      if (this.socket?.readyState === WebSocket.OPEN && this.currentChannelId === channelId) {\r\n        console.log('WebSocket already connected to channel', channelId);\r\n        resolve();\r\n        return;\r\n      }\r\n\r\n      // If connected to a different channel, disconnect first\r\n      if (this.socket?.readyState === WebSocket.OPEN && this.currentChannelId !== channelId) {\r\n        console.log('Disconnecting from channel', this.currentChannelId);\r\n        this.disconnect();\r\n      }\r\n\r\n      const token = getAuthToken();\r\n      if (!token) {\r\n        const error = new Error('No auth token available for WebSocket connection');\r\n        this.handleError(error);\r\n        reject(error);\r\n        return;\r\n      }\r\n\r\n      const baseWsUrl = process.env.REACT_APP_WS_URL || 'ws://localhost:8000/ws';\r\n      const wsUrl = `${baseWsUrl}/chat?token=${token}`;\r\n      console.log('Connecting to WebSocket:', wsUrl);\r\n      \r\n      try {\r\n        this.socket = new WebSocket(wsUrl);\r\n        this.currentChannelId = channelId;\r\n        this.processedMessageIds.clear();\r\n\r\n        // Set a connection timeout\r\n        const connectionTimeout = setTimeout(() => {\r\n          if (this.socket?.readyState !== WebSocket.OPEN) {\r\n            const error = new Error('WebSocket connection timeout');\r\n            this.handleError(error);\r\n            this.socket?.close();\r\n            reject(error);\r\n          }\r\n        }, 10000);\r\n\r\n        this.socket.onopen = () => {\r\n          clearTimeout(connectionTimeout);\r\n          console.log('WebSocket connection opened');\r\n          this.joinChannel(channelId).then(resolve).catch(error => {\r\n            this.handleError(error);\r\n            reject(error);\r\n          });\r\n        };\r\n\r\n        this.socket.onmessage = this.handleMessage;\r\n\r\n        this.socket.onerror = (event: Event) => {\r\n          this.handleError(event);\r\n          reject(new Error('WebSocket connection error'));\r\n        };\r\n\r\n        this.socket.onclose = (event: CloseEvent) => {\r\n          clearTimeout(connectionTimeout);\r\n          console.log('WebSocket disconnected with code:', event.code);\r\n          this.socket = null;\r\n\r\n          // Handle specific close codes\r\n          switch (event.code) {\r\n            case 1000: // Normal closure\r\n              this.currentChannelId = null;\r\n              break;\r\n            case 1003: // Unsupported\r\n              this.handleError('WebSocket connection not supported');\r\n              break;\r\n            case 4001: // Channel access denied\r\n              this.handleError('Access to the channel was denied');\r\n              break;\r\n            case 4002: // Authentication failed\r\n              this.handleError('Authentication failed');\r\n              break;\r\n            default:\r\n              // Attempt to reconnect for unexpected closures\r\n              if (this.currentChannelId) {\r\n                this.attemptReconnect(this.currentChannelId);\r\n              }\r\n          }\r\n        };\r\n      } catch (error) {\r\n        console.error('Error creating WebSocket:', error);\r\n        this.handleError(error);\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  disconnect() {\r\n    if (this.reconnectTimeout) {\r\n      clearTimeout(this.reconnectTimeout);\r\n      this.reconnectTimeout = null;\r\n    }\r\n    \r\n    if (this.socket) {\r\n      if (this.currentChannelId && this.socket.readyState === WebSocket.OPEN) {\r\n        const message = {\r\n          type: 'leave_channel',\r\n          channel_id: this.currentChannelId\r\n        };\r\n        this.socket.send(JSON.stringify(message));\r\n      }\r\n      this.socket.close(1000); // Normal closure\r\n      this.socket = null;\r\n      this.currentChannelId = null;\r\n      this.reconnectAttempts = 0;\r\n      this.isReconnecting = false;\r\n    }\r\n  }\r\n\r\n  sendMessage(channelId: string, content: string) {\r\n    // If not connected to the right channel, connect first\r\n    if (this.currentChannelId !== channelId) {\r\n      console.log('Connecting to channel before sending message');\r\n      this.connect(channelId);\r\n    }\r\n\r\n    if (this.socket?.readyState === WebSocket.OPEN) {\r\n      const message = {\r\n        type: 'message',\r\n        channel_id: channelId,\r\n        content: content\r\n      };\r\n      this.socket.send(JSON.stringify(message));\r\n    } else {\r\n      console.error('WebSocket is not connected');\r\n      this.errorHandlers.forEach(handler => handler({\r\n        code: 'NOT_CONNECTED',\r\n        message: 'WebSocket is not connected'\r\n      }));\r\n    }\r\n  }\r\n\r\n  async joinChannel(channelId: string) {\r\n    if (this.socket?.readyState === WebSocket.OPEN) {\r\n      console.log('Joining channel:', channelId);\r\n      const message = {\r\n        type: 'join_channel',\r\n        channel_id: parseInt(channelId)\r\n      };\r\n      this.socket.send(JSON.stringify(message));\r\n    } else {\r\n      console.error('WebSocket is not connected');\r\n      this.errorHandlers.forEach(handler => handler({\r\n        code: 'NOT_CONNECTED',\r\n        message: 'WebSocket is not connected'\r\n      }));\r\n    }\r\n  }\r\n\r\n  leaveChannel(channelId: string) {\r\n    if (this.socket?.readyState === WebSocket.OPEN && this.currentChannelId === channelId) {\r\n      const message = {\r\n        type: 'leave_channel',\r\n        channel_id: channelId\r\n      };\r\n      this.socket.send(JSON.stringify(message));\r\n      this.disconnect();\r\n    }\r\n  }\r\n\r\n  onMessage(handler: (message: WebSocketMessage) => void) {\r\n    this.messageHandlers.push(handler);\r\n    return () => {\r\n      this.messageHandlers = this.messageHandlers.filter(h => h !== handler);\r\n    };\r\n  }\r\n\r\n  onError(handler: (error: { code: string; message: string }) => void) {\r\n    this.errorHandlers.push(handler);\r\n    return () => {\r\n      this.errorHandlers = this.errorHandlers.filter(h => h !== handler);\r\n    };\r\n  }\r\n\r\n  getChatSocketState() {\r\n    return this.socket?.readyState || WebSocket.CLOSED;\r\n  }\r\n\r\n  getCurrentChannelId() {\r\n    return this.currentChannelId;\r\n  }\r\n\r\n  private handleMessage = (event: MessageEvent) => {\r\n    try {\r\n      const message = JSON.parse(event.data) as WebSocketMessage;\r\n      console.log('WebSocket message received:', message);\r\n\r\n      // Handle error messages\r\n      if (message.type === 'error') {\r\n        console.error('WebSocket error message:', message);\r\n        this.errorHandlers.forEach(handler => handler({\r\n          code: message.code || 'UNKNOWN_ERROR',\r\n          message: message.content || 'Unknown error occurred'\r\n        }));\r\n        return;\r\n      }\r\n\r\n      // Handle channel access errors\r\n      if (message.type === 'channel_access_denied') {\r\n        console.error('Channel access denied:', message);\r\n        this.errorHandlers.forEach(handler => handler({\r\n          code: 'CHANNEL_ACCESS_DENIED',\r\n          message: message.content || 'Access to this channel was denied'\r\n        }));\r\n        return;\r\n      }\r\n\r\n      // Filter out message_sent confirmations\r\n      if (message.type === 'message_sent') {\r\n        console.log('Ignoring message_sent confirmation');\r\n        return;\r\n      }\r\n\r\n      // Handle new messages\r\n      if (message.type === 'message' && message.message) {\r\n        const messageId = message.message.id;\r\n        if (messageId) {\r\n          if (this.processedMessageIds.has(messageId)) {\r\n            console.log('Ignoring duplicate message:', messageId);\r\n            return;\r\n          }\r\n          this.processedMessageIds.add(messageId);\r\n\r\n          // Limit the size of the Set to prevent memory growth\r\n          if (this.processedMessageIds.size > 1000) {\r\n            const idsArray = Array.from(this.processedMessageIds);\r\n            this.processedMessageIds = new Set(idsArray.slice(-500));\r\n          }\r\n\r\n          // Transform and dispatch the message to Redux store\r\n          const storeMessage = {\r\n            id: String(message.message.id),\r\n            content: message.message.content,\r\n            channelId: String(message.message.channel_id),\r\n            userId: String(message.message.sender_id),\r\n            reactions: [],\r\n            attachments: [],\r\n            createdAt: message.message.created_at,\r\n            updatedAt: message.message.created_at\r\n          };\r\n          store.dispatch(addMessage(storeMessage));\r\n        }\r\n      }\r\n\r\n      // Handle successful messages\r\n      this.messageHandlers.forEach(handler => handler(message));\r\n    } catch (error) {\r\n      console.error('Error parsing WebSocket message:', error);\r\n    }\r\n  };\r\n}\r\n\r\nconst wsService = new WebSocketService();\r\nexport default wsService; "],"mappings":"AACA,SAASA,YAAY,QAAQ,aAAa;AAC1C,SAASC,KAAK,QAAQ,aAAa;AACnC,SAASC,UAAU,QAAQ,oCAAoC;AAE/D,MAAMC,gBAAgB,CAAC;EAAAC,YAAA;IAAA,KACbC,MAAM,GAAqB,IAAI;IAAA,KAC/BC,eAAe,GAA4C,EAAE;IAAA,KAC7DC,aAAa,GAA2D,EAAE;IAAA,KAC1EC,gBAAgB,GAAkB,IAAI;IAAA,KACtCC,mBAAmB,GAAgB,IAAIC,GAAG,CAAC,CAAC;IAAA,KAC5CC,iBAAiB,GAAW,CAAC;IAAA,KAC7BC,oBAAoB,GAAW,CAAC;IAAA,KAChCC,gBAAgB,GAA0B,IAAI;IAAA,KAC9CC,cAAc,GAAY,KAAK;IAAA,KA2P/BC,aAAa,GAAIC,KAAmB,IAAK;MAC/C,IAAI;QACF,MAAMC,OAAO,GAAGC,IAAI,CAACC,KAAK,CAACH,KAAK,CAACI,IAAI,CAAqB;QAC1DC,OAAO,CAACC,GAAG,CAAC,6BAA6B,EAAEL,OAAO,CAAC;;QAEnD;QACA,IAAIA,OAAO,CAACM,IAAI,KAAK,OAAO,EAAE;UAC5BF,OAAO,CAACG,KAAK,CAAC,0BAA0B,EAAEP,OAAO,CAAC;UAClD,IAAI,CAACV,aAAa,CAACkB,OAAO,CAACC,OAAO,IAAIA,OAAO,CAAC;YAC5CC,IAAI,EAAEV,OAAO,CAACU,IAAI,IAAI,eAAe;YACrCV,OAAO,EAAEA,OAAO,CAACW,OAAO,IAAI;UAC9B,CAAC,CAAC,CAAC;UACH;QACF;;QAEA;QACA,IAAIX,OAAO,CAACM,IAAI,KAAK,uBAAuB,EAAE;UAC5CF,OAAO,CAACG,KAAK,CAAC,wBAAwB,EAAEP,OAAO,CAAC;UAChD,IAAI,CAACV,aAAa,CAACkB,OAAO,CAACC,OAAO,IAAIA,OAAO,CAAC;YAC5CC,IAAI,EAAE,uBAAuB;YAC7BV,OAAO,EAAEA,OAAO,CAACW,OAAO,IAAI;UAC9B,CAAC,CAAC,CAAC;UACH;QACF;;QAEA;QACA,IAAIX,OAAO,CAACM,IAAI,KAAK,cAAc,EAAE;UACnCF,OAAO,CAACC,GAAG,CAAC,oCAAoC,CAAC;UACjD;QACF;;QAEA;QACA,IAAIL,OAAO,CAACM,IAAI,KAAK,SAAS,IAAIN,OAAO,CAACA,OAAO,EAAE;UACjD,MAAMY,SAAS,GAAGZ,OAAO,CAACA,OAAO,CAACa,EAAE;UACpC,IAAID,SAAS,EAAE;YACb,IAAI,IAAI,CAACpB,mBAAmB,CAACsB,GAAG,CAACF,SAAS,CAAC,EAAE;cAC3CR,OAAO,CAACC,GAAG,CAAC,6BAA6B,EAAEO,SAAS,CAAC;cACrD;YACF;YACA,IAAI,CAACpB,mBAAmB,CAACuB,GAAG,CAACH,SAAS,CAAC;;YAEvC;YACA,IAAI,IAAI,CAACpB,mBAAmB,CAACwB,IAAI,GAAG,IAAI,EAAE;cACxC,MAAMC,QAAQ,GAAGC,KAAK,CAACC,IAAI,CAAC,IAAI,CAAC3B,mBAAmB,CAAC;cACrD,IAAI,CAACA,mBAAmB,GAAG,IAAIC,GAAG,CAACwB,QAAQ,CAACG,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC;YAC1D;;YAEA;YACA,MAAMC,YAAY,GAAG;cACnBR,EAAE,EAAES,MAAM,CAACtB,OAAO,CAACA,OAAO,CAACa,EAAE,CAAC;cAC9BF,OAAO,EAAEX,OAAO,CAACA,OAAO,CAACW,OAAO;cAChCY,SAAS,EAAED,MAAM,CAACtB,OAAO,CAACA,OAAO,CAACwB,UAAU,CAAC;cAC7CC,MAAM,EAAEH,MAAM,CAACtB,OAAO,CAACA,OAAO,CAAC0B,SAAS,CAAC;cACzCC,SAAS,EAAE,EAAE;cACbC,WAAW,EAAE,EAAE;cACfC,SAAS,EAAE7B,OAAO,CAACA,OAAO,CAAC8B,UAAU;cACrCC,SAAS,EAAE/B,OAAO,CAACA,OAAO,CAAC8B;YAC7B,CAAC;YACD9C,KAAK,CAACgD,QAAQ,CAAC/C,UAAU,CAACoC,YAAY,CAAC,CAAC;UAC1C;QACF;;QAEA;QACA,IAAI,CAAChC,eAAe,CAACmB,OAAO,CAACC,OAAO,IAAIA,OAAO,CAACT,OAAO,CAAC,CAAC;MAC3D,CAAC,CAAC,OAAOO,KAAK,EAAE;QACdH,OAAO,CAACG,KAAK,CAAC,kCAAkC,EAAEA,KAAK,CAAC;MAC1D;IACF,CAAC;EAAA;EA5TO0B,iBAAiBA,CAAA,EAAW;IAClC;IACA,OAAOC,IAAI,CAACC,GAAG,CAAC,IAAI,GAAGD,IAAI,CAACE,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC1C,iBAAiB,CAAC,EAAE,KAAK,CAAC;EACpE;EAEA,MAAc2C,gBAAgBA,CAACd,SAAiB,EAAE;IAChD,IAAI,IAAI,CAAC1B,cAAc,EAAE;MACvBO,OAAO,CAACC,GAAG,CAAC,oCAAoC,CAAC;MACjD;IACF;IAEA,IAAI,CAACR,cAAc,GAAG,IAAI;IAE1B,IAAI,IAAI,CAACH,iBAAiB,IAAI,IAAI,CAACC,oBAAoB,EAAE;MACvDS,OAAO,CAACG,KAAK,CAAC,mCAAmC,CAAC;MAClD,IAAI,CAACjB,aAAa,CAACkB,OAAO,CAACC,OAAO,IAAIA,OAAO,CAAC;QAC5CC,IAAI,EAAE,wBAAwB;QAC9BV,OAAO,EAAE;MACX,CAAC,CAAC,CAAC;MACH,IAAI,CAACH,cAAc,GAAG,KAAK;MAC3B;IACF;IAEAO,OAAO,CAACC,GAAG,CAAC,oCAAoC,IAAI,CAACX,iBAAiB,GAAG,CAAC,IAAI,IAAI,CAACC,oBAAoB,MAAM,CAAC;IAE9G,IAAI;MACF,MAAM,IAAI,CAAC2C,OAAO,CAACf,SAAS,CAAC;MAC7B,IAAI,CAAC7B,iBAAiB,GAAG,CAAC;MAC1B,IAAI,CAACG,cAAc,GAAG,KAAK;IAC7B,CAAC,CAAC,OAAOU,KAAK,EAAE;MACd,IAAI,CAACb,iBAAiB,EAAE;MACxB,IAAI,CAACG,cAAc,GAAG,KAAK;;MAE3B;MACA,MAAM0C,KAAK,GAAG,IAAI,CAACN,iBAAiB,CAAC,CAAC;MACtC7B,OAAO,CAACC,GAAG,CAAC,2CAA2CkC,KAAK,IAAI,CAAC;MACjE,IAAI,CAAC3C,gBAAgB,GAAG4C,UAAU,CAAC,MAAM;QACvC,IAAI,CAACH,gBAAgB,CAACd,SAAS,CAAC;MAClC,CAAC,EAAEgB,KAAK,CAAC;IACX;EACF;EAEQE,WAAWA,CAAClC,KAAuC,EAAE;IAC3D,IAAImC,YAAY,GAAG,4BAA4B;IAC/C,IAAInC,KAAK,YAAYoC,KAAK,EAAE;MAC1BD,YAAY,GAAGnC,KAAK,CAACP,OAAO;IAC9B,CAAC,MAAM,IAAI,OAAOO,KAAK,KAAK,QAAQ,EAAE;MACpCmC,YAAY,GAAGnC,KAAK;IACtB;IACAH,OAAO,CAACG,KAAK,CAAC,kBAAkB,EAAEA,KAAK,CAAC;IACxC,IAAI,CAACjB,aAAa,CAACkB,OAAO,CAACC,OAAO,IAAIA,OAAO,CAAC;MAC5CC,IAAI,EAAE,iBAAiB;MACvBV,OAAO,EAAE0C;IACX,CAAC,CAAC,CAAC;EACL;EAEAJ,OAAOA,CAACf,SAAiB,EAAE;IACzB,OAAO,IAAIqB,OAAO,CAAO,CAACC,OAAO,EAAEC,MAAM,KAAK;MAAA,IAAAC,YAAA,EAAAC,aAAA;MAC5C;MACA,IAAI,IAAI,CAACpD,gBAAgB,EAAE;QACzBqD,YAAY,CAAC,IAAI,CAACrD,gBAAgB,CAAC;QACnC,IAAI,CAACA,gBAAgB,GAAG,IAAI;MAC9B;;MAEA;MACA,IAAI,EAAAmD,YAAA,OAAI,CAAC3D,MAAM,cAAA2D,YAAA,uBAAXA,YAAA,CAAaG,UAAU,MAAKC,SAAS,CAACC,IAAI,IAAI,IAAI,CAAC7D,gBAAgB,KAAKgC,SAAS,EAAE;QACrFnB,OAAO,CAACC,GAAG,CAAC,wCAAwC,EAAEkB,SAAS,CAAC;QAChEsB,OAAO,CAAC,CAAC;QACT;MACF;;MAEA;MACA,IAAI,EAAAG,aAAA,OAAI,CAAC5D,MAAM,cAAA4D,aAAA,uBAAXA,aAAA,CAAaE,UAAU,MAAKC,SAAS,CAACC,IAAI,IAAI,IAAI,CAAC7D,gBAAgB,KAAKgC,SAAS,EAAE;QACrFnB,OAAO,CAACC,GAAG,CAAC,4BAA4B,EAAE,IAAI,CAACd,gBAAgB,CAAC;QAChE,IAAI,CAAC8D,UAAU,CAAC,CAAC;MACnB;MAEA,MAAMC,KAAK,GAAGvE,YAAY,CAAC,CAAC;MAC5B,IAAI,CAACuE,KAAK,EAAE;QACV,MAAM/C,KAAK,GAAG,IAAIoC,KAAK,CAAC,kDAAkD,CAAC;QAC3E,IAAI,CAACF,WAAW,CAAClC,KAAK,CAAC;QACvBuC,MAAM,CAACvC,KAAK,CAAC;QACb;MACF;MAEA,MAAMgD,SAAS,GAAGC,OAAO,CAACC,GAAG,CAACC,gBAAgB,IAAI,wBAAwB;MAC1E,MAAMC,KAAK,GAAG,GAAGJ,SAAS,eAAeD,KAAK,EAAE;MAChDlD,OAAO,CAACC,GAAG,CAAC,0BAA0B,EAAEsD,KAAK,CAAC;MAE9C,IAAI;QACF,IAAI,CAACvE,MAAM,GAAG,IAAI+D,SAAS,CAACQ,KAAK,CAAC;QAClC,IAAI,CAACpE,gBAAgB,GAAGgC,SAAS;QACjC,IAAI,CAAC/B,mBAAmB,CAACoE,KAAK,CAAC,CAAC;;QAEhC;QACA,MAAMC,iBAAiB,GAAGrB,UAAU,CAAC,MAAM;UAAA,IAAAsB,aAAA;UACzC,IAAI,EAAAA,aAAA,OAAI,CAAC1E,MAAM,cAAA0E,aAAA,uBAAXA,aAAA,CAAaZ,UAAU,MAAKC,SAAS,CAACC,IAAI,EAAE;YAAA,IAAAW,aAAA;YAC9C,MAAMxD,KAAK,GAAG,IAAIoC,KAAK,CAAC,8BAA8B,CAAC;YACvD,IAAI,CAACF,WAAW,CAAClC,KAAK,CAAC;YACvB,CAAAwD,aAAA,OAAI,CAAC3E,MAAM,cAAA2E,aAAA,uBAAXA,aAAA,CAAaC,KAAK,CAAC,CAAC;YACpBlB,MAAM,CAACvC,KAAK,CAAC;UACf;QACF,CAAC,EAAE,KAAK,CAAC;QAET,IAAI,CAACnB,MAAM,CAAC6E,MAAM,GAAG,MAAM;UACzBhB,YAAY,CAACY,iBAAiB,CAAC;UAC/BzD,OAAO,CAACC,GAAG,CAAC,6BAA6B,CAAC;UAC1C,IAAI,CAAC6D,WAAW,CAAC3C,SAAS,CAAC,CAAC4C,IAAI,CAACtB,OAAO,CAAC,CAACuB,KAAK,CAAC7D,KAAK,IAAI;YACvD,IAAI,CAACkC,WAAW,CAAClC,KAAK,CAAC;YACvBuC,MAAM,CAACvC,KAAK,CAAC;UACf,CAAC,CAAC;QACJ,CAAC;QAED,IAAI,CAACnB,MAAM,CAACiF,SAAS,GAAG,IAAI,CAACvE,aAAa;QAE1C,IAAI,CAACV,MAAM,CAACkF,OAAO,GAAIvE,KAAY,IAAK;UACtC,IAAI,CAAC0C,WAAW,CAAC1C,KAAK,CAAC;UACvB+C,MAAM,CAAC,IAAIH,KAAK,CAAC,4BAA4B,CAAC,CAAC;QACjD,CAAC;QAED,IAAI,CAACvD,MAAM,CAACmF,OAAO,GAAIxE,KAAiB,IAAK;UAC3CkD,YAAY,CAACY,iBAAiB,CAAC;UAC/BzD,OAAO,CAACC,GAAG,CAAC,mCAAmC,EAAEN,KAAK,CAACW,IAAI,CAAC;UAC5D,IAAI,CAACtB,MAAM,GAAG,IAAI;;UAElB;UACA,QAAQW,KAAK,CAACW,IAAI;YAChB,KAAK,IAAI;cAAE;cACT,IAAI,CAACnB,gBAAgB,GAAG,IAAI;cAC5B;YACF,KAAK,IAAI;cAAE;cACT,IAAI,CAACkD,WAAW,CAAC,oCAAoC,CAAC;cACtD;YACF,KAAK,IAAI;cAAE;cACT,IAAI,CAACA,WAAW,CAAC,kCAAkC,CAAC;cACpD;YACF,KAAK,IAAI;cAAE;cACT,IAAI,CAACA,WAAW,CAAC,uBAAuB,CAAC;cACzC;YACF;cACE;cACA,IAAI,IAAI,CAAClD,gBAAgB,EAAE;gBACzB,IAAI,CAAC8C,gBAAgB,CAAC,IAAI,CAAC9C,gBAAgB,CAAC;cAC9C;UACJ;QACF,CAAC;MACH,CAAC,CAAC,OAAOgB,KAAK,EAAE;QACdH,OAAO,CAACG,KAAK,CAAC,2BAA2B,EAAEA,KAAK,CAAC;QACjD,IAAI,CAACkC,WAAW,CAAClC,KAAK,CAAC;QACvBuC,MAAM,CAACvC,KAAK,CAAC;MACf;IACF,CAAC,CAAC;EACJ;EAEA8C,UAAUA,CAAA,EAAG;IACX,IAAI,IAAI,CAACzD,gBAAgB,EAAE;MACzBqD,YAAY,CAAC,IAAI,CAACrD,gBAAgB,CAAC;MACnC,IAAI,CAACA,gBAAgB,GAAG,IAAI;IAC9B;IAEA,IAAI,IAAI,CAACR,MAAM,EAAE;MACf,IAAI,IAAI,CAACG,gBAAgB,IAAI,IAAI,CAACH,MAAM,CAAC8D,UAAU,KAAKC,SAAS,CAACC,IAAI,EAAE;QACtE,MAAMpD,OAAO,GAAG;UACdM,IAAI,EAAE,eAAe;UACrBkB,UAAU,EAAE,IAAI,CAACjC;QACnB,CAAC;QACD,IAAI,CAACH,MAAM,CAACoF,IAAI,CAACvE,IAAI,CAACwE,SAAS,CAACzE,OAAO,CAAC,CAAC;MAC3C;MACA,IAAI,CAACZ,MAAM,CAAC4E,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;MACzB,IAAI,CAAC5E,MAAM,GAAG,IAAI;MAClB,IAAI,CAACG,gBAAgB,GAAG,IAAI;MAC5B,IAAI,CAACG,iBAAiB,GAAG,CAAC;MAC1B,IAAI,CAACG,cAAc,GAAG,KAAK;IAC7B;EACF;EAEA6E,WAAWA,CAACnD,SAAiB,EAAEZ,OAAe,EAAE;IAAA,IAAAgE,aAAA;IAC9C;IACA,IAAI,IAAI,CAACpF,gBAAgB,KAAKgC,SAAS,EAAE;MACvCnB,OAAO,CAACC,GAAG,CAAC,8CAA8C,CAAC;MAC3D,IAAI,CAACiC,OAAO,CAACf,SAAS,CAAC;IACzB;IAEA,IAAI,EAAAoD,aAAA,OAAI,CAACvF,MAAM,cAAAuF,aAAA,uBAAXA,aAAA,CAAazB,UAAU,MAAKC,SAAS,CAACC,IAAI,EAAE;MAC9C,MAAMpD,OAAO,GAAG;QACdM,IAAI,EAAE,SAAS;QACfkB,UAAU,EAAED,SAAS;QACrBZ,OAAO,EAAEA;MACX,CAAC;MACD,IAAI,CAACvB,MAAM,CAACoF,IAAI,CAACvE,IAAI,CAACwE,SAAS,CAACzE,OAAO,CAAC,CAAC;IAC3C,CAAC,MAAM;MACLI,OAAO,CAACG,KAAK,CAAC,4BAA4B,CAAC;MAC3C,IAAI,CAACjB,aAAa,CAACkB,OAAO,CAACC,OAAO,IAAIA,OAAO,CAAC;QAC5CC,IAAI,EAAE,eAAe;QACrBV,OAAO,EAAE;MACX,CAAC,CAAC,CAAC;IACL;EACF;EAEA,MAAMkE,WAAWA,CAAC3C,SAAiB,EAAE;IAAA,IAAAqD,aAAA;IACnC,IAAI,EAAAA,aAAA,OAAI,CAACxF,MAAM,cAAAwF,aAAA,uBAAXA,aAAA,CAAa1B,UAAU,MAAKC,SAAS,CAACC,IAAI,EAAE;MAC9ChD,OAAO,CAACC,GAAG,CAAC,kBAAkB,EAAEkB,SAAS,CAAC;MAC1C,MAAMvB,OAAO,GAAG;QACdM,IAAI,EAAE,cAAc;QACpBkB,UAAU,EAAEqD,QAAQ,CAACtD,SAAS;MAChC,CAAC;MACD,IAAI,CAACnC,MAAM,CAACoF,IAAI,CAACvE,IAAI,CAACwE,SAAS,CAACzE,OAAO,CAAC,CAAC;IAC3C,CAAC,MAAM;MACLI,OAAO,CAACG,KAAK,CAAC,4BAA4B,CAAC;MAC3C,IAAI,CAACjB,aAAa,CAACkB,OAAO,CAACC,OAAO,IAAIA,OAAO,CAAC;QAC5CC,IAAI,EAAE,eAAe;QACrBV,OAAO,EAAE;MACX,CAAC,CAAC,CAAC;IACL;EACF;EAEA8E,YAAYA,CAACvD,SAAiB,EAAE;IAAA,IAAAwD,aAAA;IAC9B,IAAI,EAAAA,aAAA,OAAI,CAAC3F,MAAM,cAAA2F,aAAA,uBAAXA,aAAA,CAAa7B,UAAU,MAAKC,SAAS,CAACC,IAAI,IAAI,IAAI,CAAC7D,gBAAgB,KAAKgC,SAAS,EAAE;MACrF,MAAMvB,OAAO,GAAG;QACdM,IAAI,EAAE,eAAe;QACrBkB,UAAU,EAAED;MACd,CAAC;MACD,IAAI,CAACnC,MAAM,CAACoF,IAAI,CAACvE,IAAI,CAACwE,SAAS,CAACzE,OAAO,CAAC,CAAC;MACzC,IAAI,CAACqD,UAAU,CAAC,CAAC;IACnB;EACF;EAEA2B,SAASA,CAACvE,OAA4C,EAAE;IACtD,IAAI,CAACpB,eAAe,CAAC4F,IAAI,CAACxE,OAAO,CAAC;IAClC,OAAO,MAAM;MACX,IAAI,CAACpB,eAAe,GAAG,IAAI,CAACA,eAAe,CAAC6F,MAAM,CAACC,CAAC,IAAIA,CAAC,KAAK1E,OAAO,CAAC;IACxE,CAAC;EACH;EAEA2E,OAAOA,CAAC3E,OAA2D,EAAE;IACnE,IAAI,CAACnB,aAAa,CAAC2F,IAAI,CAACxE,OAAO,CAAC;IAChC,OAAO,MAAM;MACX,IAAI,CAACnB,aAAa,GAAG,IAAI,CAACA,aAAa,CAAC4F,MAAM,CAACC,CAAC,IAAIA,CAAC,KAAK1E,OAAO,CAAC;IACpE,CAAC;EACH;EAEA4E,kBAAkBA,CAAA,EAAG;IAAA,IAAAC,aAAA;IACnB,OAAO,EAAAA,aAAA,OAAI,CAAClG,MAAM,cAAAkG,aAAA,uBAAXA,aAAA,CAAapC,UAAU,KAAIC,SAAS,CAACoC,MAAM;EACpD;EAEAC,mBAAmBA,CAAA,EAAG;IACpB,OAAO,IAAI,CAACjG,gBAAgB;EAC9B;AAsEF;AAEA,MAAMkG,SAAS,GAAG,IAAIvG,gBAAgB,CAAC,CAAC;AACxC,eAAeuG,SAAS","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}