{"ast":null,"code":"import { createSlice } from '@reduxjs/toolkit';\nconst initialState = {\n  messagesByChannel: {},\n  loading: false,\n  error: null\n};\nconst messagesSlice = createSlice({\n  name: 'messages',\n  initialState,\n  reducers: {\n    setMessages: (state, action) => {\n      const {\n        channelId,\n        messages\n      } = action.payload;\n      state.messagesByChannel[channelId] = messages;\n      state.loading = false;\n      state.error = null;\n    },\n    addMessage: (state, action) => {\n      const {\n        channelId\n      } = action.payload;\n\n      // Initialize channel messages array if it doesn't exist\n      if (!state.messagesByChannel[channelId]) {\n        state.messagesByChannel[channelId] = [];\n      }\n\n      // Check if message already exists by ID\n      const existingMessageIndex = state.messagesByChannel[channelId].findIndex(msg => msg.id === action.payload.id);\n      if (existingMessageIndex === -1) {\n        // Add new message and sort by timestamp\n        state.messagesByChannel[channelId].push(action.payload);\n        state.messagesByChannel[channelId].sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());\n      } else {\n        // Update existing message if needed\n        const existingMessage = state.messagesByChannel[channelId][existingMessageIndex];\n        if (existingMessage.updatedAt !== action.payload.updatedAt) {\n          state.messagesByChannel[channelId][existingMessageIndex] = action.payload;\n        }\n      }\n    },\n    updateMessage: (state, action) => {\n      const {\n        channelId,\n        id\n      } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const index = messages.findIndex(msg => msg.id === id);\n        if (index !== -1) {\n          messages[index] = action.payload.message;\n        }\n      }\n    },\n    deleteMessage: (state, action) => {\n      const {\n        channelId,\n        messageId\n      } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        state.messagesByChannel[channelId] = messages.filter(msg => msg.id !== messageId);\n      }\n    },\n    addReaction: (state, action) => {\n      const {\n        channelId,\n        messageId,\n        reaction\n      } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const message = messages.find(msg => msg.id === messageId);\n        if (message) {\n          // Check if reaction already exists\n          const existingReactionIndex = message.reactions.findIndex(r => r.id === reaction.id || r.emoji === reaction.emoji && r.userId === reaction.userId);\n          if (existingReactionIndex === -1) {\n            message.reactions.push(reaction);\n          }\n        }\n      }\n    },\n    removeReaction: (state, action) => {\n      const {\n        channelId,\n        messageId,\n        reactionId\n      } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const message = messages.find(msg => msg.id === messageId);\n        if (message) {\n          message.reactions = message.reactions.filter(reaction => reaction.id !== reactionId);\n        }\n      }\n    },\n    setReplies: (state, action) => {\n      const {\n        channelId,\n        messageId,\n        replies\n      } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const message = messages.find(msg => msg.id === messageId);\n        if (message) {\n          // Add replies to the channel's messages\n          state.messagesByChannel[channelId] = [...messages, ...replies.filter(reply => !messages.some(msg => msg.id === reply.id))].sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());\n\n          // Update reply count\n          message.replyCount = replies.length;\n        }\n      }\n    },\n    toggleExpanded: (state, action) => {\n      const {\n        channelId,\n        messageId\n      } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const message = messages.find(msg => msg.id === messageId);\n        if (message) {\n          message.isExpanded = !message.isExpanded;\n        }\n      }\n    }\n  }\n});\nexport const {\n  setMessages,\n  addMessage,\n  updateMessage,\n  deleteMessage,\n  addReaction,\n  removeReaction,\n  setReplies,\n  toggleExpanded\n} = messagesSlice.actions;\nexport default messagesSlice.reducer;","map":{"version":3,"names":["createSlice","initialState","messagesByChannel","loading","error","messagesSlice","name","reducers","setMessages","state","action","channelId","messages","payload","addMessage","existingMessageIndex","findIndex","msg","id","push","sort","a","b","Date","createdAt","getTime","existingMessage","updatedAt","updateMessage","index","message","deleteMessage","messageId","filter","addReaction","reaction","find","existingReactionIndex","reactions","r","emoji","userId","removeReaction","reactionId","setReplies","replies","reply","some","replyCount","length","toggleExpanded","isExpanded","actions","reducer"],"sources":["Z:/GAUNTLET/projects/SERMO/sermo-app/frontend/src/store/messages/messagesSlice.ts"],"sourcesContent":["import { createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { MessagesState, Reaction, StoreMessage } from '../../types';\n\nconst initialState: MessagesState = {\n  messagesByChannel: {},\n  loading: false,\n  error: null,\n};\n\nconst messagesSlice = createSlice({\n  name: 'messages',\n  initialState,\n  reducers: {\n    setMessages: (state, action: PayloadAction<{ channelId: string; messages: StoreMessage[] }>) => {\n      const { channelId, messages } = action.payload;\n      state.messagesByChannel[channelId] = messages;\n      state.loading = false;\n      state.error = null;\n    },\n    addMessage: (state, action: PayloadAction<StoreMessage>) => {\n      const { channelId } = action.payload;\n      \n      // Initialize channel messages array if it doesn't exist\n      if (!state.messagesByChannel[channelId]) {\n        state.messagesByChannel[channelId] = [];\n      }\n\n      // Check if message already exists by ID\n      const existingMessageIndex = state.messagesByChannel[channelId].findIndex(\n        (msg: StoreMessage) => msg.id === action.payload.id\n      );\n\n      if (existingMessageIndex === -1) {\n        // Add new message and sort by timestamp\n        state.messagesByChannel[channelId].push(action.payload);\n        state.messagesByChannel[channelId].sort((a, b) => \n          new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()\n        );\n      } else {\n        // Update existing message if needed\n        const existingMessage = state.messagesByChannel[channelId][existingMessageIndex];\n        if (existingMessage.updatedAt !== action.payload.updatedAt) {\n          state.messagesByChannel[channelId][existingMessageIndex] = action.payload;\n        }\n      }\n    },\n    updateMessage: (state, action: PayloadAction<{ channelId: string; id: string; message: StoreMessage }>) => {\n      const { channelId, id } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const index = messages.findIndex((msg: StoreMessage) => msg.id === id);\n        if (index !== -1) {\n          messages[index] = action.payload.message;\n        }\n      }\n    },\n    deleteMessage: (state, action: PayloadAction<{ channelId: string; messageId: string }>) => {\n      const { channelId, messageId } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        state.messagesByChannel[channelId] = messages.filter((msg: StoreMessage) => msg.id !== messageId);\n      }\n    },\n    addReaction: (state, action: PayloadAction<{ channelId: string; messageId: string; reaction: Reaction }>) => {\n      const { channelId, messageId, reaction } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const message = messages.find((msg: StoreMessage) => msg.id === messageId);\n        if (message) {\n          // Check if reaction already exists\n          const existingReactionIndex = message.reactions.findIndex(\n            (r: Reaction) => r.id === reaction.id || (r.emoji === reaction.emoji && r.userId === reaction.userId)\n          );\n          if (existingReactionIndex === -1) {\n            message.reactions.push(reaction);\n          }\n        }\n      }\n    },\n    removeReaction: (state, action: PayloadAction<{ channelId: string; messageId: string; reactionId: string }>) => {\n      const { channelId, messageId, reactionId } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const message = messages.find((msg: StoreMessage) => msg.id === messageId);\n        if (message) {\n          message.reactions = message.reactions.filter((reaction: Reaction) => reaction.id !== reactionId);\n        }\n      }\n    },\n    setReplies: (state, action: PayloadAction<{ channelId: string; messageId: string; replies: StoreMessage[] }>) => {\n      const { channelId, messageId, replies } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const message = messages.find((msg: StoreMessage) => msg.id === messageId);\n        if (message) {\n          // Add replies to the channel's messages\n          state.messagesByChannel[channelId] = [\n            ...messages,\n            ...replies.filter(reply => !messages.some(msg => msg.id === reply.id))\n          ].sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());\n          \n          // Update reply count\n          message.replyCount = replies.length;\n        }\n      }\n    },\n    toggleExpanded: (state, action: PayloadAction<{ channelId: string; messageId: string }>) => {\n      const { channelId, messageId } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const message = messages.find((msg: StoreMessage) => msg.id === messageId);\n        if (message) {\n          message.isExpanded = !message.isExpanded;\n        }\n      }\n    },\n  },\n});\n\nexport const {\n  setMessages,\n  addMessage,\n  updateMessage,\n  deleteMessage,\n  addReaction,\n  removeReaction,\n  setReplies,\n  toggleExpanded\n} = messagesSlice.actions;\n\nexport default messagesSlice.reducer; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}