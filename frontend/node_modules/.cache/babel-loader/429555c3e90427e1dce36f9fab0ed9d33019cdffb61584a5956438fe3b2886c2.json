{"ast":null,"code":"var _WebSocketService;\nimport { store } from '../../store';\nimport { addMessage, updateMessage, addReaction, removeReaction } from '../../store/messages/messagesSlice';\nimport { updateUserStatus } from '../../store/chat/chatSlice';\n\n// Get WebSocket URL from environment variable or fallback to localhost\nconst WS_BASE_URL = process.env.REACT_APP_WS_URL || 'ws://localhost:8000/ws';\n\n// Helper function to get the correct WebSocket URL based on the current protocol\nconst getWebSocketUrl = () => {\n  // If we're on HTTPS, use WSS\n  if (window.location.protocol === 'https:' && WS_BASE_URL.startsWith('ws:')) {\n    return WS_BASE_URL.replace('ws:', 'wss:');\n  }\n  return WS_BASE_URL;\n};\nexport class WebSocketService {\n  constructor() {\n    this.ws = null;\n    this.pingInterval = null;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectTimeout = null;\n    this.channels = new Set();\n    if (WebSocketService.instance) {\n      return WebSocketService.instance;\n    }\n    WebSocketService.instance = this;\n  }\n  getAuthToken() {\n    var _state$auth;\n    const state = store.getState();\n    return ((_state$auth = state.auth) === null || _state$auth === void 0 ? void 0 : _state$auth.token) || null;\n  }\n  connect() {\n    var _this$ws;\n    if (((_this$ws = this.ws) === null || _this$ws === void 0 ? void 0 : _this$ws.readyState) === WebSocket.OPEN) {\n      console.log('WebSocket already connected');\n      return;\n    }\n    const token = this.getAuthToken();\n    if (!token) {\n      console.warn('No auth token available, skipping WebSocket connection');\n      return;\n    }\n    const wsUrl = `${getWebSocketUrl()}?token=${token}`;\n    console.log('Connecting to WebSocket:', wsUrl);\n    try {\n      this.ws = new WebSocket(wsUrl);\n      this.ws.onopen = () => {\n        console.log('WebSocket connected successfully');\n        this.reconnectAttempts = 0;\n        this.startPingInterval();\n\n        // Rejoin all channels with a small delay to ensure connection is stable\n        setTimeout(() => {\n          console.log('Rejoining channels after connection:', Array.from(this.channels));\n          this.channels.forEach(channelId => {\n            console.log('Rejoining channel:', channelId);\n            this.joinChannel(channelId);\n          });\n        }, 1000);\n      };\n      this.ws.onmessage = event => {\n        console.log('Raw WebSocket message received:', event.data);\n        this.handleMessage(event);\n      };\n      this.ws.onclose = event => {\n        console.log('WebSocket disconnected with code:', event.code, 'reason:', event.reason);\n        this.stopPingInterval();\n        this.handleReconnect();\n      };\n      this.ws.onerror = error => {\n        console.error('WebSocket error:', error);\n      };\n    } catch (error) {\n      console.error('Error creating WebSocket connection:', error);\n    }\n  }\n  handleReconnect() {\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n      this.reconnectAttempts++;\n      console.log(`Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\n\n      // Store current channels before reconnecting\n      const currentChannels = new Set(this.channels);\n      this.reconnectTimeout = setTimeout(() => {\n        this.connect();\n\n        // After reconnection, verify channels are rejoined\n        setTimeout(() => {\n          currentChannels.forEach(channelId => {\n            if (!this.channels.has(channelId)) {\n              console.log('Rejoining channel after reconnect:', channelId);\n              this.joinChannel(channelId);\n            }\n          });\n        }, 2000);\n      }, 5000);\n    }\n  }\n  startPingInterval() {\n    this.pingInterval = setInterval(() => {\n      var _this$ws2;\n      if (((_this$ws2 = this.ws) === null || _this$ws2 === void 0 ? void 0 : _this$ws2.readyState) === WebSocket.OPEN) {\n        this.ws.send(JSON.stringify({\n          type: 'PING'\n        }));\n      }\n    }, 30000);\n  }\n  stopPingInterval() {\n    if (this.pingInterval) {\n      clearInterval(this.pingInterval);\n      this.pingInterval = null;\n    }\n  }\n  disconnect() {\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n    this.stopPingInterval();\n  }\n  handleMessage(event) {\n    try {\n      const data = JSON.parse(event.data);\n      console.log('WebSocket received message:', data);\n      switch (data.type) {\n        case 'reaction_added':\n          console.log('Handling reaction_added:', data.payload);\n          if (this.store) {\n            const {\n              channelId,\n              messageId,\n              reaction\n            } = data.payload;\n            if (!channelId || !messageId || !reaction) {\n              console.warn('Invalid reaction_added payload:', data.payload);\n              return;\n            }\n            this.store.dispatch(addReaction({\n              channelId,\n              messageId,\n              reaction\n            }));\n          }\n          break;\n        case 'reaction_removed':\n          console.log('Handling reaction_removed:', data.payload);\n          if (this.store) {\n            const {\n              channelId,\n              messageId,\n              userId,\n              emoji\n            } = data.payload;\n            if (!channelId || !messageId || !userId || !emoji) {\n              console.warn('Invalid reaction_removed payload:', data.payload);\n              return;\n            }\n            this.store.dispatch(removeReaction({\n              channelId,\n              messageId,\n              userId,\n              emoji\n            }));\n          }\n          break;\n        case 'new_message':\n          if (data.channelId && data.message) {\n            if (data.isReply && data.parentId) {\n              store.dispatch(addMessage({\n                channelId: data.channelId,\n                message: {\n                  ...data.message,\n                  parentId: data.parentId\n                }\n              }));\n            } else {\n              store.dispatch(addMessage({\n                channelId: data.channelId,\n                message: data.message\n              }));\n            }\n          }\n          break;\n        case 'update_message':\n          if (data.channelId && data.id && data.updates) {\n            store.dispatch(updateMessage({\n              channelId: data.channelId,\n              messageId: data.id,\n              message: data.updates\n            }));\n          }\n          break;\n        case 'user_status':\n          if (data.userId && data.status) {\n            store.dispatch(updateUserStatus({\n              userId: data.userId,\n              status: data.status\n            }));\n          }\n          break;\n        case 'pong':\n          // Handle pong response\n          break;\n        default:\n          console.warn('Unknown message type:', data.type, 'original type:', data.type);\n      }\n    } catch (error) {\n      console.error('Error handling WebSocket message:', error);\n      console.error('Raw message data:', event.data);\n    }\n  }\n  joinChannel(channelId) {\n    var _this$ws3;\n    console.log('Joining channel:', channelId);\n    if (((_this$ws3 = this.ws) === null || _this$ws3 === void 0 ? void 0 : _this$ws3.readyState) === WebSocket.OPEN) {\n      this.ws.send(JSON.stringify({\n        type: 'join_channel',\n        channelId\n      }));\n      this.channels.add(channelId);\n      console.log('Current channels:', Array.from(this.channels));\n    } else {\n      console.warn('WebSocket not connected, queueing channel join for:', channelId);\n      // Add to channels set anyway, will be joined when connection is established\n      this.channels.add(channelId);\n      // Try to reconnect if not already connected\n      if (!this.ws || this.ws.readyState === WebSocket.CLOSED) {\n        this.connect();\n      }\n    }\n  }\n  leaveChannel(channelId) {\n    var _this$ws4;\n    console.log('Leaving channel:', channelId);\n    if (((_this$ws4 = this.ws) === null || _this$ws4 === void 0 ? void 0 : _this$ws4.readyState) === WebSocket.OPEN) {\n      this.ws.send(JSON.stringify({\n        type: 'leave_channel',\n        channelId\n      }));\n    } else {\n      console.warn('WebSocket not connected, skipping leave message for channel:', channelId);\n    }\n    // Always remove from channels set\n    this.channels.delete(channelId);\n    console.log('Current channels:', Array.from(this.channels));\n  }\n}\n_WebSocketService = WebSocketService;\nWebSocketService.instance = null;\nexport default new WebSocketService();","map":{"version":3,"names":["store","addMessage","updateMessage","addReaction","removeReaction","updateUserStatus","WS_BASE_URL","process","env","REACT_APP_WS_URL","getWebSocketUrl","window","location","protocol","startsWith","replace","WebSocketService","constructor","ws","pingInterval","reconnectAttempts","maxReconnectAttempts","reconnectTimeout","channels","Set","instance","getAuthToken","_state$auth","state","getState","auth","token","connect","_this$ws","readyState","WebSocket","OPEN","console","log","warn","wsUrl","onopen","startPingInterval","setTimeout","Array","from","forEach","channelId","joinChannel","onmessage","event","data","handleMessage","onclose","code","reason","stopPingInterval","handleReconnect","onerror","error","currentChannels","has","setInterval","_this$ws2","send","JSON","stringify","type","clearInterval","disconnect","close","clearTimeout","parse","payload","messageId","reaction","dispatch","userId","emoji","message","isReply","parentId","id","updates","status","_this$ws3","add","CLOSED","leaveChannel","_this$ws4","delete","_WebSocketService"],"sources":["Z:/GAUNTLET/projects/SERMO/sermo-app/frontend/src/services/websocket/index.ts"],"sourcesContent":["import { Reaction } from '../../types';\nimport { store } from '../../store';\nimport { addMessage, updateMessage, addReaction, removeReaction } from '../../store/messages/messagesSlice';\nimport { updateUserStatus } from '../../store/chat/chatSlice';\n\n// Get WebSocket URL from environment variable or fallback to localhost\nconst WS_BASE_URL = process.env.REACT_APP_WS_URL || 'ws://localhost:8000/ws';\n\n// Helper function to get the correct WebSocket URL based on the current protocol\nconst getWebSocketUrl = () => {\n  // If we're on HTTPS, use WSS\n  if (window.location.protocol === 'https:' && WS_BASE_URL.startsWith('ws:')) {\n    return WS_BASE_URL.replace('ws:', 'wss:');\n  }\n  return WS_BASE_URL;\n};\n\ninterface WebSocketMessage {\n  type: 'new_message' | 'update_message' | 'user_status' | 'ping' | 'pong' | 'join_channel' | 'leave_channel' | 'reaction_added' | 'reaction_removed' | 'REACTION_ADDED' | 'REACTION_REMOVED';\n  channelId?: string;\n  message?: any;\n  id?: string;\n  updates?: any;\n  userId?: string;\n  status?: 'online' | 'offline' | 'away' | 'busy';\n  isReply?: boolean;\n  parentId?: string;\n  messageId?: string;\n  reaction?: Reaction;\n  emoji?: string;\n  data?: {\n    channel_id: number | string;\n    message_id: string;\n    user_id: string;\n    emoji: string;\n    reaction: Reaction;\n  };\n}\n\nexport class WebSocketService {\n  private static instance: WebSocketService | null = null;\n  private ws: WebSocket | null = null;\n  private pingInterval: NodeJS.Timeout | null = null;\n  private reconnectAttempts = 0;\n  private maxReconnectAttempts = 5;\n  private reconnectTimeout: NodeJS.Timeout | null = null;\n  private channels: Set<string> = new Set();\n\n  constructor() {\n    if (WebSocketService.instance) {\n      return WebSocketService.instance;\n    }\n    WebSocketService.instance = this;\n  }\n\n  private getAuthToken(): string | null {\n    const state = store.getState();\n    return state.auth?.token || null;\n  }\n\n  public connect() {\n    if (this.ws?.readyState === WebSocket.OPEN) {\n      console.log('WebSocket already connected');\n      return;\n    }\n\n    const token = this.getAuthToken();\n    if (!token) {\n      console.warn('No auth token available, skipping WebSocket connection');\n      return;\n    }\n\n    const wsUrl = `${getWebSocketUrl()}?token=${token}`;\n    console.log('Connecting to WebSocket:', wsUrl);\n    \n    try {\n      this.ws = new WebSocket(wsUrl);\n      \n      this.ws.onopen = () => {\n        console.log('WebSocket connected successfully');\n        this.reconnectAttempts = 0;\n        this.startPingInterval();\n        \n        // Rejoin all channels with a small delay to ensure connection is stable\n        setTimeout(() => {\n          console.log('Rejoining channels after connection:', Array.from(this.channels));\n          this.channels.forEach(channelId => {\n            console.log('Rejoining channel:', channelId);\n            this.joinChannel(channelId);\n          });\n        }, 1000);\n      };\n\n      this.ws.onmessage = (event) => {\n        console.log('Raw WebSocket message received:', event.data);\n        this.handleMessage(event);\n      };\n\n      this.ws.onclose = (event) => {\n        console.log('WebSocket disconnected with code:', event.code, 'reason:', event.reason);\n        this.stopPingInterval();\n        this.handleReconnect();\n      };\n\n      this.ws.onerror = (error) => {\n        console.error('WebSocket error:', error);\n      };\n    } catch (error) {\n      console.error('Error creating WebSocket connection:', error);\n    }\n  }\n\n  private handleReconnect() {\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n      this.reconnectAttempts++;\n      console.log(`Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\n      \n      // Store current channels before reconnecting\n      const currentChannels = new Set(this.channels);\n      \n      this.reconnectTimeout = setTimeout(() => {\n        this.connect();\n        \n        // After reconnection, verify channels are rejoined\n        setTimeout(() => {\n          currentChannels.forEach(channelId => {\n            if (!this.channels.has(channelId)) {\n              console.log('Rejoining channel after reconnect:', channelId);\n              this.joinChannel(channelId);\n            }\n          });\n        }, 2000);\n      }, 5000);\n    }\n  }\n\n  private startPingInterval() {\n    this.pingInterval = setInterval(() => {\n      if (this.ws?.readyState === WebSocket.OPEN) {\n        this.ws.send(JSON.stringify({ type: 'PING' }));\n      }\n    }, 30000);\n  }\n\n  private stopPingInterval() {\n    if (this.pingInterval) {\n      clearInterval(this.pingInterval);\n      this.pingInterval = null;\n    }\n  }\n\n  public disconnect() {\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n    this.stopPingInterval();\n  }\n\n  private handleMessage(event: MessageEvent) {\n    try {\n      const data = JSON.parse(event.data) as WebSocketMessage;\n      console.log('WebSocket received message:', data);\n\n      switch (data.type) {\n        case 'reaction_added':\n          console.log('Handling reaction_added:', data.payload);\n          if (this.store) {\n            const { channelId, messageId, reaction } = data.payload;\n            if (!channelId || !messageId || !reaction) {\n              console.warn('Invalid reaction_added payload:', data.payload);\n              return;\n            }\n            this.store.dispatch(addReaction({ channelId, messageId, reaction }));\n          }\n          break;\n\n        case 'reaction_removed':\n          console.log('Handling reaction_removed:', data.payload);\n          if (this.store) {\n            const { channelId, messageId, userId, emoji } = data.payload;\n            if (!channelId || !messageId || !userId || !emoji) {\n              console.warn('Invalid reaction_removed payload:', data.payload);\n              return;\n            }\n            this.store.dispatch(removeReaction({ channelId, messageId, userId, emoji }));\n          }\n          break;\n\n        case 'new_message':\n          if (data.channelId && data.message) {\n            if (data.isReply && data.parentId) {\n              store.dispatch(addMessage({\n                channelId: data.channelId,\n                message: {\n                  ...data.message,\n                  parentId: data.parentId\n                }\n              }));\n            } else {\n              store.dispatch(addMessage({\n                channelId: data.channelId,\n                message: data.message\n              }));\n            }\n          }\n          break;\n\n        case 'update_message':\n          if (data.channelId && data.id && data.updates) {\n            store.dispatch(updateMessage({\n              channelId: data.channelId,\n              messageId: data.id,\n              message: data.updates\n            }));\n          }\n          break;\n\n        case 'user_status':\n          if (data.userId && data.status) {\n            store.dispatch(updateUserStatus({\n              userId: data.userId,\n              status: data.status\n            }));\n          }\n          break;\n\n        case 'pong':\n          // Handle pong response\n          break;\n\n        default:\n          console.warn('Unknown message type:', data.type, 'original type:', data.type);\n      }\n    } catch (error) {\n      console.error('Error handling WebSocket message:', error);\n      console.error('Raw message data:', event.data);\n    }\n  }\n\n  public joinChannel(channelId: string) {\n    console.log('Joining channel:', channelId);\n    if (this.ws?.readyState === WebSocket.OPEN) {\n      this.ws.send(JSON.stringify({\n        type: 'join_channel',\n        channelId\n      }));\n      this.channels.add(channelId);\n      console.log('Current channels:', Array.from(this.channels));\n    } else {\n      console.warn('WebSocket not connected, queueing channel join for:', channelId);\n      // Add to channels set anyway, will be joined when connection is established\n      this.channels.add(channelId);\n      // Try to reconnect if not already connected\n      if (!this.ws || this.ws.readyState === WebSocket.CLOSED) {\n        this.connect();\n      }\n    }\n  }\n\n  public leaveChannel(channelId: string) {\n    console.log('Leaving channel:', channelId);\n    if (this.ws?.readyState === WebSocket.OPEN) {\n      this.ws.send(JSON.stringify({\n        type: 'leave_channel',\n        channelId\n      }));\n    } else {\n      console.warn('WebSocket not connected, skipping leave message for channel:', channelId);\n    }\n    // Always remove from channels set\n    this.channels.delete(channelId);\n    console.log('Current channels:', Array.from(this.channels));\n  }\n}\n\nexport default new WebSocketService(); "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}