{"ast":null,"code":"var _WebSocketService;\nimport { addReaction, removeReaction } from '../../store/messages/messagesSlice';\n// Get WebSocket URL from environment variable or fallback to localhost\nconst WS_BASE_URL = process.env.REACT_APP_WS_URL || 'ws://localhost:8000/ws';\n\n// Helper function to get the correct WebSocket URL based on the current protocol\nconst getWebSocketUrl = () => {\n  // If we're on HTTPS, use WSS\n  if (window.location.protocol === 'https:' && WS_BASE_URL.startsWith('ws:')) {\n    return WS_BASE_URL.replace('ws:', 'wss:');\n  }\n  return WS_BASE_URL;\n};\nfunction isReactionAddedMessage(message) {\n  return message.type === 'reaction_added' && 'payload' in message && message.payload && 'channelId' in message.payload && 'messageId' in message.payload && 'reaction' in message.payload;\n}\nfunction isReactionRemovedMessage(message) {\n  return message.type === 'reaction_removed' && 'payload' in message && message.payload && 'channelId' in message.payload && 'messageId' in message.payload && 'userId' in message.payload && 'emoji' in message.payload;\n}\nclass WebSocketService {\n  constructor() {\n    this.ws = null;\n    this.channels = new Set();\n    this.store = null;\n  }\n  static getInstance() {\n    if (!WebSocketService.instance) {\n      WebSocketService.instance = new WebSocketService();\n    }\n    return WebSocketService.instance;\n  }\n  initialize(store) {\n    this.store = store;\n  }\n  connect() {\n    var _this$ws;\n    if (((_this$ws = this.ws) === null || _this$ws === void 0 ? void 0 : _this$ws.readyState) === WebSocket.OPEN) {\n      console.log('WebSocket already connected');\n      return;\n    }\n    console.log('Connecting WebSocket...');\n    this.ws = new WebSocket(getWebSocketUrl());\n    this.ws.onopen = () => {\n      console.log('WebSocket connected, current channels:', Array.from(this.channels));\n      // Rejoin all channels after reconnection\n      for (const channelId of Array.from(this.channels)) {\n        console.log('Rejoining channel after connection:', channelId);\n        this.joinChannel(channelId);\n      }\n    };\n    this.ws.onclose = () => {\n      console.log('WebSocket disconnected, channels at disconnect:', Array.from(this.channels));\n      setTimeout(() => this.connect(), 1000);\n    };\n    this.ws.onerror = error => {\n      console.error('WebSocket error:', error);\n    };\n    this.ws.onmessage = event => {\n      try {\n        const data = JSON.parse(event.data);\n        console.log('Received WebSocket message:', data);\n        if (!this.store) {\n          console.warn('Store not initialized');\n          return;\n        }\n        if (isReactionAddedMessage(data)) {\n          const {\n            channelId,\n            messageId,\n            reaction\n          } = data.payload;\n          console.log('Checking channel subscription for reaction:', channelId, 'Current channels:', Array.from(this.channels));\n          if (!this.channels.has(channelId)) {\n            console.warn('Received reaction for unsubscribed channel:', channelId);\n            return;\n          }\n          console.log('Dispatching addReaction:', {\n            channelId,\n            messageId,\n            reaction\n          });\n          this.store.dispatch(addReaction({\n            channelId,\n            messageId,\n            reaction\n          }));\n        } else if (isReactionRemovedMessage(data)) {\n          const {\n            channelId,\n            messageId,\n            userId,\n            emoji\n          } = data.payload;\n          console.log('Checking channel subscription for reaction removal:', channelId, 'Current channels:', Array.from(this.channels));\n          if (!this.channels.has(channelId)) {\n            console.warn('Received reaction removal for unsubscribed channel:', channelId);\n            return;\n          }\n          console.log('Dispatching removeReaction:', {\n            channelId,\n            messageId,\n            userId,\n            emoji\n          });\n          this.store.dispatch(removeReaction({\n            channelId,\n            messageId,\n            userId,\n            emoji\n          }));\n        }\n      } catch (error) {\n        console.error('Error handling WebSocket message:', error);\n      }\n    };\n  }\n  joinChannel(channelId) {\n    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\n      console.warn('Cannot join channel - WebSocket not connected:', channelId);\n      return;\n    }\n    console.log('Joining channel:', channelId);\n    this.channels.add(channelId);\n    this.ws.send(JSON.stringify({\n      type: 'join',\n      channel: channelId\n    }));\n  }\n  leaveChannel(channelId) {\n    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\n      console.warn('Cannot leave channel - WebSocket not connected:', channelId);\n      return;\n    }\n    console.log('Leaving channel:', channelId);\n    this.channels.delete(channelId);\n    this.ws.send(JSON.stringify({\n      type: 'leave',\n      channel: channelId\n    }));\n  }\n}\n_WebSocketService = WebSocketService;\nWebSocketService.instance = null;\nexport const webSocketService = WebSocketService.getInstance();","map":{"version":3,"names":["addReaction","removeReaction","WS_BASE_URL","process","env","REACT_APP_WS_URL","getWebSocketUrl","window","location","protocol","startsWith","replace","isReactionAddedMessage","message","type","payload","isReactionRemovedMessage","WebSocketService","constructor","ws","channels","Set","store","getInstance","instance","initialize","connect","_this$ws","readyState","WebSocket","OPEN","console","log","onopen","Array","from","channelId","joinChannel","onclose","setTimeout","onerror","error","onmessage","event","data","JSON","parse","warn","messageId","reaction","has","dispatch","userId","emoji","add","send","stringify","channel","leaveChannel","delete","_WebSocketService","webSocketService"],"sources":["Z:/GAUNTLET/projects/SERMO/sermo-app/frontend/src/services/websocket/index.ts"],"sourcesContent":["import { Store } from '@reduxjs/toolkit';\nimport { addReaction, removeReaction } from '../../store/messages/messagesSlice';\nimport { Reaction } from '../../types';\n\n// Get WebSocket URL from environment variable or fallback to localhost\nconst WS_BASE_URL = process.env.REACT_APP_WS_URL || 'ws://localhost:8000/ws';\n\n// Helper function to get the correct WebSocket URL based on the current protocol\nconst getWebSocketUrl = () => {\n  // If we're on HTTPS, use WSS\n  if (window.location.protocol === 'https:' && WS_BASE_URL.startsWith('ws:')) {\n    return WS_BASE_URL.replace('ws:', 'wss:');\n  }\n  return WS_BASE_URL;\n};\n\ninterface BaseWebSocketMessage {\n  type: string;\n  payload?: any;\n}\n\ninterface ReactionAddedMessage extends BaseWebSocketMessage {\n  type: 'reaction_added';\n  payload: {\n    channelId: string;\n    messageId: string;\n    reaction: Reaction;\n  };\n}\n\ninterface ReactionRemovedMessage extends BaseWebSocketMessage {\n  type: 'reaction_removed';\n  payload: {\n    channelId: string;\n    messageId: string;\n    userId: string;\n    emoji: string;\n  };\n}\n\ntype WebSocketMessage = ReactionAddedMessage | ReactionRemovedMessage | BaseWebSocketMessage;\n\nfunction isReactionAddedMessage(message: WebSocketMessage): message is ReactionAddedMessage {\n  return message.type === 'reaction_added' && \n         'payload' in message && \n         message.payload && \n         'channelId' in message.payload &&\n         'messageId' in message.payload &&\n         'reaction' in message.payload;\n}\n\nfunction isReactionRemovedMessage(message: WebSocketMessage): message is ReactionRemovedMessage {\n  return message.type === 'reaction_removed' && \n         'payload' in message && \n         message.payload && \n         'channelId' in message.payload &&\n         'messageId' in message.payload &&\n         'userId' in message.payload &&\n         'emoji' in message.payload;\n}\n\nclass WebSocketService {\n  private ws: WebSocket | null = null;\n  private channels: Set<string> = new Set();\n  private store: Store | null = null;\n  private static instance: WebSocketService | null = null;\n\n  private constructor() {}\n\n  static getInstance(): WebSocketService {\n    if (!WebSocketService.instance) {\n      WebSocketService.instance = new WebSocketService();\n    }\n    return WebSocketService.instance;\n  }\n\n  initialize(store: Store) {\n    this.store = store;\n  }\n\n  connect() {\n    if (this.ws?.readyState === WebSocket.OPEN) {\n      console.log('WebSocket already connected');\n      return;\n    }\n\n    console.log('Connecting WebSocket...');\n    this.ws = new WebSocket(getWebSocketUrl());\n\n    this.ws.onopen = () => {\n      console.log('WebSocket connected, current channels:', Array.from(this.channels));\n      // Rejoin all channels after reconnection\n      for (const channelId of Array.from(this.channels)) {\n        console.log('Rejoining channel after connection:', channelId);\n        this.joinChannel(channelId);\n      }\n    };\n\n    this.ws.onclose = () => {\n      console.log('WebSocket disconnected, channels at disconnect:', Array.from(this.channels));\n      setTimeout(() => this.connect(), 1000);\n    };\n\n    this.ws.onerror = (error) => {\n      console.error('WebSocket error:', error);\n    };\n\n    this.ws.onmessage = (event) => {\n      try {\n        const data = JSON.parse(event.data) as WebSocketMessage;\n        console.log('Received WebSocket message:', data);\n\n        if (!this.store) {\n          console.warn('Store not initialized');\n          return;\n        }\n\n        if (isReactionAddedMessage(data)) {\n          const { channelId, messageId, reaction } = data.payload;\n          console.log('Checking channel subscription for reaction:', channelId, 'Current channels:', Array.from(this.channels));\n          \n          if (!this.channels.has(channelId)) {\n            console.warn('Received reaction for unsubscribed channel:', channelId);\n            return;\n          }\n\n          console.log('Dispatching addReaction:', { channelId, messageId, reaction });\n          this.store.dispatch(addReaction({ channelId, messageId, reaction }));\n        }\n        else if (isReactionRemovedMessage(data)) {\n          const { channelId, messageId, userId, emoji } = data.payload;\n          console.log('Checking channel subscription for reaction removal:', channelId, 'Current channels:', Array.from(this.channels));\n          \n          if (!this.channels.has(channelId)) {\n            console.warn('Received reaction removal for unsubscribed channel:', channelId);\n            return;\n          }\n\n          console.log('Dispatching removeReaction:', { channelId, messageId, userId, emoji });\n          this.store.dispatch(removeReaction({ channelId, messageId, userId, emoji }));\n        }\n      } catch (error) {\n        console.error('Error handling WebSocket message:', error);\n      }\n    };\n  }\n\n  joinChannel(channelId: string) {\n    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\n      console.warn('Cannot join channel - WebSocket not connected:', channelId);\n      return;\n    }\n\n    console.log('Joining channel:', channelId);\n    this.channels.add(channelId);\n    this.ws.send(JSON.stringify({ type: 'join', channel: channelId }));\n  }\n\n  leaveChannel(channelId: string) {\n    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\n      console.warn('Cannot leave channel - WebSocket not connected:', channelId);\n      return;\n    }\n\n    console.log('Leaving channel:', channelId);\n    this.channels.delete(channelId);\n    this.ws.send(JSON.stringify({ type: 'leave', channel: channelId }));\n  }\n}\n\nexport const webSocketService = WebSocketService.getInstance(); "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}