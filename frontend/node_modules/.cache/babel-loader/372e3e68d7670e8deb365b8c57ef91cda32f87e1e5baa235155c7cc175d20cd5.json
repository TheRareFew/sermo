{"ast":null,"code":"import { createAsyncThunk } from '@reduxjs/toolkit';\nimport * as messagesAPI from '../../services/api/messages';\nimport { fetchMessagesStart, fetchMessagesSuccess, fetchMessagesFailure, addMessage, updateMessage as updateMessageAction, deleteMessage as deleteMessageAction } from './messagesSlice';\nimport wsService from '../../services/websocket';\nexport const fetchMessages = createAsyncThunk('messages/fetchMessages', async ({\n  channelId,\n  limit = 50\n}, {\n  dispatch\n}) => {\n  try {\n    dispatch(fetchMessagesStart());\n    const messages = await messagesAPI.getChannelMessages(channelId, limit);\n    dispatch(fetchMessagesSuccess({\n      channelId,\n      messages\n    }));\n    return messages;\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : 'Failed to fetch messages';\n    dispatch(fetchMessagesFailure(errorMessage));\n    throw error;\n  }\n});\nexport const sendMessage = createAsyncThunk('messages/sendMessage', async ({\n  channelId,\n  content\n}, {\n  dispatch\n}) => {\n  try {\n    // Send via WebSocket\n    wsService.sendMessage(channelId, content);\n    return {\n      success: true\n    };\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : 'Failed to send message';\n    throw new Error(errorMessage);\n  }\n});\nexport const updateMessageThunk = createAsyncThunk('messages/updateMessage', async ({\n  messageId,\n  channelId,\n  content\n}, {\n  dispatch\n}) => {\n  try {\n    const updatedMessage = await messagesAPI.updateMessage(messageId, content);\n    dispatch(updateMessageAction({\n      channelId,\n      message: updatedMessage\n    }));\n    return updatedMessage;\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : 'Failed to update message';\n    throw new Error(errorMessage);\n  }\n});\nexport const deleteMessageThunk = createAsyncThunk('messages/deleteMessage', async ({\n  messageId,\n  channelId\n}, {\n  dispatch\n}) => {\n  try {\n    await messagesAPI.deleteMessage(messageId);\n    dispatch(deleteMessageAction({\n      channelId,\n      messageId\n    }));\n    return {\n      success: true\n    };\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : 'Failed to delete message';\n    throw new Error(errorMessage);\n  }\n});\n\n// Setup WebSocket message handlers\nexport const setupMessageHandlers = () => dispatch => {\n  wsService.onMessage(message => {\n    if (message.type === 'new_message') {\n      dispatch(addMessage({\n        channelId: message.message.channel_id,\n        message: {\n          id: message.message.id,\n          content: message.message.content,\n          sender_id: message.message.sender_id,\n          channel_id: message.message.channel_id,\n          created_at: message.message.created_at\n        }\n      }));\n    }\n  });\n};","map":{"version":3,"names":["createAsyncThunk","messagesAPI","fetchMessagesStart","fetchMessagesSuccess","fetchMessagesFailure","addMessage","updateMessage","updateMessageAction","deleteMessage","deleteMessageAction","wsService","fetchMessages","channelId","limit","dispatch","messages","getChannelMessages","error","errorMessage","Error","message","sendMessage","content","success","updateMessageThunk","messageId","updatedMessage","deleteMessageThunk","setupMessageHandlers","onMessage","type","channel_id","id","sender_id","created_at"],"sources":["Z:/GAUNTLET/projects/SERMO/sermo-app/frontend/src/store/messages/messagesThunks.ts"],"sourcesContent":["import { createAsyncThunk } from '@reduxjs/toolkit';\r\nimport * as messagesAPI from '../../services/api/messages';\r\nimport { Message } from '../../types';\r\nimport {\r\n  fetchMessagesStart,\r\n  fetchMessagesSuccess,\r\n  fetchMessagesFailure,\r\n  addMessage,\r\n  updateMessage as updateMessageAction,\r\n  deleteMessage as deleteMessageAction,\r\n} from './messagesSlice';\r\nimport wsService from '../../services/websocket';\r\n\r\nexport const fetchMessages = createAsyncThunk(\r\n  'messages/fetchMessages',\r\n  async ({ channelId, limit = 50 }: { channelId: number; limit?: number }, { dispatch }) => {\r\n    try {\r\n      dispatch(fetchMessagesStart());\r\n      const messages = await messagesAPI.getChannelMessages(channelId, limit);\r\n      dispatch(fetchMessagesSuccess({ channelId, messages }));\r\n      return messages;\r\n    } catch (error) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Failed to fetch messages';\r\n      dispatch(fetchMessagesFailure(errorMessage));\r\n      throw error;\r\n    }\r\n  }\r\n);\r\n\r\nexport const sendMessage = createAsyncThunk(\r\n  'messages/sendMessage',\r\n  async ({ channelId, content }: { channelId: number; content: string }, { dispatch }) => {\r\n    try {\r\n      // Send via WebSocket\r\n      wsService.sendMessage(channelId, content);\r\n      return { success: true };\r\n    } catch (error) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Failed to send message';\r\n      throw new Error(errorMessage);\r\n    }\r\n  }\r\n);\r\n\r\nexport const updateMessageThunk = createAsyncThunk(\r\n  'messages/updateMessage',\r\n  async ({ messageId, channelId, content }: { messageId: number; channelId: number; content: string }, { dispatch }) => {\r\n    try {\r\n      const updatedMessage = await messagesAPI.updateMessage(messageId, content);\r\n      dispatch(updateMessageAction({ channelId, message: updatedMessage }));\r\n      return updatedMessage;\r\n    } catch (error) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Failed to update message';\r\n      throw new Error(errorMessage);\r\n    }\r\n  }\r\n);\r\n\r\nexport const deleteMessageThunk = createAsyncThunk(\r\n  'messages/deleteMessage',\r\n  async ({ messageId, channelId }: { messageId: number; channelId: number }, { dispatch }) => {\r\n    try {\r\n      await messagesAPI.deleteMessage(messageId);\r\n      dispatch(deleteMessageAction({ channelId, messageId }));\r\n      return { success: true };\r\n    } catch (error) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Failed to delete message';\r\n      throw new Error(errorMessage);\r\n    }\r\n  }\r\n);\r\n\r\n// Setup WebSocket message handlers\r\nexport const setupMessageHandlers = () => (dispatch: any) => {\r\n  wsService.onMessage((message) => {\r\n    if (message.type === 'new_message') {\r\n      dispatch(addMessage({\r\n        channelId: message.message.channel_id,\r\n        message: {\r\n          id: message.message.id,\r\n          content: message.message.content,\r\n          sender_id: message.message.sender_id,\r\n          channel_id: message.message.channel_id,\r\n          created_at: message.message.created_at,\r\n        },\r\n      }));\r\n    }\r\n  });\r\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}