{"ast":null,"code":"var _WebSocketService;\nimport { store } from '../../store';\nimport { addMessage, updateMessage } from '../../store/messages/messagesSlice';\nimport { updateUserStatus } from '../../store/chat/chatSlice';\n\n// Get WebSocket URL from environment variable or fallback to localhost\nconst WS_BASE_URL = process.env.REACT_APP_WS_URL || 'ws://localhost:8000/ws';\n\n// Helper function to get the correct WebSocket URL based on the current protocol\nconst getWebSocketUrl = () => {\n  // If we're on HTTPS, use WSS\n  if (window.location.protocol === 'https:' && WS_BASE_URL.startsWith('ws:')) {\n    return WS_BASE_URL.replace('ws:', 'wss:');\n  }\n  return WS_BASE_URL;\n};\nexport class WebSocketService {\n  constructor() {\n    this.ws = null;\n    this.pingInterval = null;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectTimeout = null;\n    this.channels = new Set();\n    if (WebSocketService.instance) {\n      return WebSocketService.instance;\n    }\n    WebSocketService.instance = this;\n  }\n  getAuthToken() {\n    var _state$auth;\n    const state = store.getState();\n    return ((_state$auth = state.auth) === null || _state$auth === void 0 ? void 0 : _state$auth.token) || null;\n  }\n  connect() {\n    var _this$ws;\n    if (((_this$ws = this.ws) === null || _this$ws === void 0 ? void 0 : _this$ws.readyState) === WebSocket.OPEN) return;\n    const token = this.getAuthToken();\n    if (!token) {\n      console.warn('No auth token available, skipping WebSocket connection');\n      return;\n    }\n    const wsUrl = `${getWebSocketUrl()}?token=${token}`;\n    console.log('Connecting to WebSocket:', wsUrl);\n    try {\n      this.ws = new WebSocket(wsUrl);\n      this.ws.onopen = () => {\n        console.log('WebSocket connected successfully');\n        this.reconnectAttempts = 0;\n        this.startPingInterval();\n\n        // Rejoin all channels\n        this.channels.forEach(channelId => {\n          this.joinChannel(channelId);\n        });\n      };\n      this.ws.onmessage = this.handleMessage.bind(this);\n      this.ws.onclose = event => {\n        console.log('WebSocket disconnected with code:', event.code);\n        this.stopPingInterval();\n        this.handleReconnect();\n      };\n      this.ws.onerror = error => {\n        console.error('WebSocket error:', error);\n      };\n    } catch (error) {\n      console.error('Error creating WebSocket connection:', error);\n    }\n  }\n  handleReconnect() {\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n      this.reconnectAttempts++;\n      console.log(`Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\n      this.reconnectTimeout = setTimeout(() => {\n        this.connect();\n      }, 5000);\n    }\n  }\n  startPingInterval() {\n    this.pingInterval = setInterval(() => {\n      var _this$ws2;\n      if (((_this$ws2 = this.ws) === null || _this$ws2 === void 0 ? void 0 : _this$ws2.readyState) === WebSocket.OPEN) {\n        this.ws.send(JSON.stringify({\n          type: 'PING'\n        }));\n      }\n    }, 30000);\n  }\n  stopPingInterval() {\n    if (this.pingInterval) {\n      clearInterval(this.pingInterval);\n      this.pingInterval = null;\n    }\n  }\n  disconnect() {\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n    this.stopPingInterval();\n  }\n  handleMessage(event) {\n    try {\n      const data = JSON.parse(event.data);\n      console.log('WebSocket message received:', data);\n      switch (data.type) {\n        case 'NEW_MESSAGE':\n          if (data.channelId && data.message) {\n            store.dispatch(addMessage({\n              channelId: data.channelId,\n              message: data.message\n            }));\n          }\n          break;\n        case 'UPDATE_MESSAGE':\n          if (data.channelId && data.id && data.updates) {\n            const updatedMessage = {\n              id: data.id,\n              ...data.updates\n            };\n            store.dispatch(updateMessage({\n              channelId: data.channelId,\n              id: data.id,\n              message: updatedMessage\n            }));\n          }\n          break;\n        case 'USER_STATUS':\n          if (data.userId && data.status) {\n            store.dispatch(updateUserStatus({\n              userId: data.userId,\n              status: data.status\n            }));\n          }\n          break;\n        case 'PONG':\n          // Handle pong response\n          break;\n        default:\n          console.warn('Unknown message type:', data.type);\n      }\n    } catch (error) {\n      console.error('Error handling WebSocket message:', error);\n    }\n  }\n  joinChannel(channelId) {\n    var _this$ws3;\n    if (((_this$ws3 = this.ws) === null || _this$ws3 === void 0 ? void 0 : _this$ws3.readyState) === WebSocket.OPEN) {\n      this.ws.send(JSON.stringify({\n        type: 'JOIN_CHANNEL',\n        channelId\n      }));\n      this.channels.add(channelId);\n    }\n  }\n  leaveChannel(channelId) {\n    var _this$ws4;\n    if (((_this$ws4 = this.ws) === null || _this$ws4 === void 0 ? void 0 : _this$ws4.readyState) === WebSocket.OPEN) {\n      this.ws.send(JSON.stringify({\n        type: 'LEAVE_CHANNEL',\n        channelId\n      }));\n      this.channels.delete(channelId);\n    }\n  }\n}\n_WebSocketService = WebSocketService;\nWebSocketService.instance = null;\nexport default new WebSocketService();","map":{"version":3,"names":["store","addMessage","updateMessage","updateUserStatus","WS_BASE_URL","process","env","REACT_APP_WS_URL","getWebSocketUrl","window","location","protocol","startsWith","replace","WebSocketService","constructor","ws","pingInterval","reconnectAttempts","maxReconnectAttempts","reconnectTimeout","channels","Set","instance","getAuthToken","_state$auth","state","getState","auth","token","connect","_this$ws","readyState","WebSocket","OPEN","console","warn","wsUrl","log","onopen","startPingInterval","forEach","channelId","joinChannel","onmessage","handleMessage","bind","onclose","event","code","stopPingInterval","handleReconnect","onerror","error","setTimeout","setInterval","_this$ws2","send","JSON","stringify","type","clearInterval","disconnect","close","clearTimeout","data","parse","message","dispatch","id","updates","updatedMessage","userId","status","_this$ws3","add","leaveChannel","_this$ws4","delete","_WebSocketService"],"sources":["Z:/GAUNTLET/projects/SERMO/sermo-app/frontend/src/services/websocket/index.ts"],"sourcesContent":["import { Message, User, StoreMessage } from '../../types';\r\nimport { store } from '../../store';\r\nimport { addMessage, updateMessage } from '../../store/messages/messagesSlice';\r\nimport { updateUserStatus } from '../../store/chat/chatSlice';\r\n\r\n// Get WebSocket URL from environment variable or fallback to localhost\r\nconst WS_BASE_URL = process.env.REACT_APP_WS_URL || 'ws://localhost:8000/ws';\r\n\r\n// Helper function to get the correct WebSocket URL based on the current protocol\r\nconst getWebSocketUrl = () => {\r\n  // If we're on HTTPS, use WSS\r\n  if (window.location.protocol === 'https:' && WS_BASE_URL.startsWith('ws:')) {\r\n    return WS_BASE_URL.replace('ws:', 'wss:');\r\n  }\r\n  return WS_BASE_URL;\r\n};\r\n\r\ninterface WebSocketMessage {\r\n  type: 'NEW_MESSAGE' | 'UPDATE_MESSAGE' | 'USER_STATUS' | 'PING' | 'PONG' | 'JOIN_CHANNEL' | 'LEAVE_CHANNEL';\r\n  channelId?: string;\r\n  message?: StoreMessage;\r\n  id?: string;\r\n  updates?: Partial<StoreMessage>;\r\n  userId?: string;\r\n  status?: 'online' | 'offline' | 'away' | 'busy';\r\n}\r\n\r\nexport class WebSocketService {\r\n  private static instance: WebSocketService | null = null;\r\n  private ws: WebSocket | null = null;\r\n  private pingInterval: NodeJS.Timeout | null = null;\r\n  private reconnectAttempts = 0;\r\n  private maxReconnectAttempts = 5;\r\n  private reconnectTimeout: NodeJS.Timeout | null = null;\r\n  private channels: Set<string> = new Set();\r\n\r\n  constructor() {\r\n    if (WebSocketService.instance) {\r\n      return WebSocketService.instance;\r\n    }\r\n    WebSocketService.instance = this;\r\n  }\r\n\r\n  private getAuthToken(): string | null {\r\n    const state = store.getState();\r\n    return state.auth?.token || null;\r\n  }\r\n\r\n  public connect() {\r\n    if (this.ws?.readyState === WebSocket.OPEN) return;\r\n\r\n    const token = this.getAuthToken();\r\n    if (!token) {\r\n      console.warn('No auth token available, skipping WebSocket connection');\r\n      return;\r\n    }\r\n\r\n    const wsUrl = `${getWebSocketUrl()}?token=${token}`;\r\n    console.log('Connecting to WebSocket:', wsUrl);\r\n    \r\n    try {\r\n      this.ws = new WebSocket(wsUrl);\r\n      \r\n      this.ws.onopen = () => {\r\n        console.log('WebSocket connected successfully');\r\n        this.reconnectAttempts = 0;\r\n        this.startPingInterval();\r\n        \r\n        // Rejoin all channels\r\n        this.channels.forEach(channelId => {\r\n          this.joinChannel(channelId);\r\n        });\r\n      };\r\n\r\n      this.ws.onmessage = this.handleMessage.bind(this);\r\n      this.ws.onclose = (event) => {\r\n        console.log('WebSocket disconnected with code:', event.code);\r\n        this.stopPingInterval();\r\n        this.handleReconnect();\r\n      };\r\n      this.ws.onerror = (error) => {\r\n        console.error('WebSocket error:', error);\r\n      };\r\n    } catch (error) {\r\n      console.error('Error creating WebSocket connection:', error);\r\n    }\r\n  }\r\n\r\n  private handleReconnect() {\r\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\r\n      this.reconnectAttempts++;\r\n      console.log(`Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\r\n      this.reconnectTimeout = setTimeout(() => {\r\n        this.connect();\r\n      }, 5000);\r\n    }\r\n  }\r\n\r\n  private startPingInterval() {\r\n    this.pingInterval = setInterval(() => {\r\n      if (this.ws?.readyState === WebSocket.OPEN) {\r\n        this.ws.send(JSON.stringify({ type: 'PING' }));\r\n      }\r\n    }, 30000);\r\n  }\r\n\r\n  private stopPingInterval() {\r\n    if (this.pingInterval) {\r\n      clearInterval(this.pingInterval);\r\n      this.pingInterval = null;\r\n    }\r\n  }\r\n\r\n  public disconnect() {\r\n    if (this.ws) {\r\n      this.ws.close();\r\n      this.ws = null;\r\n    }\r\n    if (this.reconnectTimeout) {\r\n      clearTimeout(this.reconnectTimeout);\r\n      this.reconnectTimeout = null;\r\n    }\r\n    this.stopPingInterval();\r\n  }\r\n\r\n  private handleMessage(event: MessageEvent) {\r\n    try {\r\n      const data = JSON.parse(event.data) as WebSocketMessage;\r\n      console.log('WebSocket message received:', data);\r\n\r\n      switch (data.type) {\r\n        case 'NEW_MESSAGE':\r\n          if (data.channelId && data.message) {\r\n            store.dispatch(addMessage({\r\n              channelId: data.channelId,\r\n              message: data.message\r\n            }));\r\n          }\r\n          break;\r\n\r\n        case 'UPDATE_MESSAGE':\r\n          if (data.channelId && data.id && data.updates) {\r\n            const updatedMessage = {\r\n              id: data.id,\r\n              ...data.updates\r\n            } as StoreMessage;\r\n            \r\n            store.dispatch(updateMessage({\r\n              channelId: data.channelId,\r\n              id: data.id,\r\n              message: updatedMessage\r\n            }));\r\n          }\r\n          break;\r\n\r\n        case 'USER_STATUS':\r\n          if (data.userId && data.status) {\r\n            store.dispatch(updateUserStatus({\r\n              userId: data.userId,\r\n              status: data.status\r\n            }));\r\n          }\r\n          break;\r\n\r\n        case 'PONG':\r\n          // Handle pong response\r\n          break;\r\n\r\n        default:\r\n          console.warn('Unknown message type:', data.type);\r\n      }\r\n    } catch (error) {\r\n      console.error('Error handling WebSocket message:', error);\r\n    }\r\n  }\r\n\r\n  public joinChannel(channelId: string) {\r\n    if (this.ws?.readyState === WebSocket.OPEN) {\r\n      this.ws.send(JSON.stringify({\r\n        type: 'JOIN_CHANNEL',\r\n        channelId\r\n      }));\r\n      this.channels.add(channelId);\r\n    }\r\n  }\r\n\r\n  public leaveChannel(channelId: string) {\r\n    if (this.ws?.readyState === WebSocket.OPEN) {\r\n      this.ws.send(JSON.stringify({\r\n        type: 'LEAVE_CHANNEL',\r\n        channelId\r\n      }));\r\n      this.channels.delete(channelId);\r\n    }\r\n  }\r\n}\r\n\r\nexport default new WebSocketService(); "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}