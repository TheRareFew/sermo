{"ast":null,"code":"import { getAuthToken } from '../api/auth';\n\n// Add WebSocket message types\n\nclass WebSocketService {\n  constructor() {\n    this.socket = null;\n    this.messageHandlers = [];\n    this.errorHandlers = [];\n    this.currentChannelId = null;\n    this.joinedChannels = new Set();\n    this.messageQueue = [];\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectTimeout = null;\n    this.isReconnecting = false;\n    this.connectionPromise = null;\n    this.joinPromise = null;\n    this.lastMessageId = null;\n    this.processingQueue = false;\n    this.heartbeatInterval = null;\n    this.lastHeartbeatResponse = Date.now();\n    this.handleClose = event => {\n      console.log('[DEBUG] WebSocket closed:', event.code, event.reason);\n      if (this.socket === null) return;\n      const wasConnected = this.socket.readyState === WebSocket.OPEN;\n      this.socket = null;\n      this.joinedChannels.clear();\n      if (event.code !== 1000 && wasConnected) {\n        if (!this.isReconnecting && this.reconnectAttempts < this.maxReconnectAttempts) {\n          console.log('[DEBUG] Attempting reconnect after close');\n          this.attemptReconnect();\n        }\n      }\n    };\n    // Update message handler to track last message ID\n    this.handleWebSocketMessage = event => {\n      var _data$data8, _data$data8$channel_i;\n      try {\n        const data = JSON.parse(event.data);\n        console.log('Raw WebSocket message received:', event.data);\n        console.log('Parsed WebSocket message:', data);\n\n        // Update heartbeat timestamp for any message\n        this.lastHeartbeatResponse = Date.now();\n        switch (data.type) {\n          case 'new_message':\n            console.log('Broadcasting new message to handlers:', data);\n            this.messageHandlers.forEach(handler => {\n              var _data$data;\n              return handler({\n                type: 'new_message',\n                data: {\n                  message: data.message,\n                  channelId: data.channelId || ((_data$data = data.data) === null || _data$data === void 0 ? void 0 : _data$data.channelId)\n                }\n              });\n            });\n            break;\n          case 'message_updated':\n            console.log('Broadcasting updated message to handlers:', data);\n            this.messageHandlers.forEach(handler => {\n              var _data$data2;\n              return handler({\n                type: 'message_updated',\n                data: {\n                  message: data.message,\n                  channelId: data.channelId || ((_data$data2 = data.data) === null || _data$data2 === void 0 ? void 0 : _data$data2.channelId)\n                }\n              });\n            });\n            break;\n          case 'message_deleted':\n            console.log('Broadcasting deleted message to handlers:', data);\n            this.messageHandlers.forEach(handler => {\n              var _data$data3, _data$data4;\n              return handler({\n                type: 'message_deleted',\n                data: {\n                  messageId: data.messageId || ((_data$data3 = data.data) === null || _data$data3 === void 0 ? void 0 : _data$data3.messageId),\n                  channelId: data.channelId || ((_data$data4 = data.data) === null || _data$data4 === void 0 ? void 0 : _data$data4.channelId)\n                }\n              });\n            });\n            break;\n          case 'new_reply':\n            console.log('Broadcasting new reply to handlers:', data);\n            this.messageHandlers.forEach(handler => {\n              var _data$data5, _data$data6, _data$data7;\n              return handler({\n                type: 'new_reply',\n                data: {\n                  reply: data.reply || ((_data$data5 = data.data) === null || _data$data5 === void 0 ? void 0 : _data$data5.reply),\n                  parentMessageId: data.parentMessageId || ((_data$data6 = data.data) === null || _data$data6 === void 0 ? void 0 : _data$data6.parentMessageId),\n                  channelId: data.channelId || ((_data$data7 = data.data) === null || _data$data7 === void 0 ? void 0 : _data$data7.channelId)\n                }\n              });\n            });\n            break;\n          case 'pong':\n            console.log('Received heartbeat response');\n            break;\n          case 'joined':\n            const channelId = (_data$data8 = data.data) === null || _data$data8 === void 0 ? void 0 : (_data$data8$channel_i = _data$data8.channel_id) === null || _data$data8$channel_i === void 0 ? void 0 : _data$data8$channel_i.toString();\n            if (channelId) {\n              console.log('Channel joined:', channelId);\n              this.joinedChannels.add(channelId);\n            }\n            break;\n          default:\n            console.log('Unknown websocket message type:', data.type);\n        }\n      } catch (error) {\n        console.error('Error handling websocket message:', error);\n        this.handleError(error);\n      }\n    };\n  }\n  async connect(channelId) {\n    if (this.isConnected() && this.isConnectedToChannel(channelId)) {\n      console.log('Already connected to channel:', channelId);\n      return;\n    }\n\n    // Always disconnect before connecting to ensure clean state\n    this.disconnect();\n    this.currentChannelId = channelId;\n    this.isReconnecting = false;\n    this.reconnectAttempts = 0;\n    try {\n      const token = getAuthToken();\n      if (!token) {\n        throw new Error('No authentication token found');\n      }\n      console.log('Connecting to WebSocket server...');\n      // Use the same host as the current page, but with ws/wss protocol\n      const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n      const wsUrl = `${wsProtocol}//${window.location.host}/api/v1/ws/chat?token=${token}`;\n      console.log('WebSocket URL:', wsUrl.replace(token, '[REDACTED]'));\n      this.socket = new WebSocket(wsUrl);\n      await new Promise((resolve, reject) => {\n        const timeout = setTimeout(() => {\n          console.error('WebSocket connection timeout');\n          reject(new Error('WebSocket connection timeout'));\n        }, 5000);\n        if (this.socket) {\n          this.socket.onopen = () => {\n            console.log('WebSocket connection opened successfully');\n            clearTimeout(timeout);\n            this.startHeartbeat();\n            resolve();\n          };\n          this.socket.onerror = error => {\n            console.error('WebSocket connection error:', error);\n            clearTimeout(timeout);\n            reject(error);\n          };\n          this.socket.onclose = event => {\n            console.log('WebSocket connection closed:', event.code, event.reason);\n            this.handleClose(event);\n          };\n          this.socket.onmessage = event => {\n            try {\n              console.log('Raw WebSocket message received:', event.data);\n              this.handleWebSocketMessage(event);\n            } catch (error) {\n              console.error('Error handling WebSocket message:', error);\n            }\n          };\n        }\n      });\n      if (this.socket) {\n        console.log('Joining channel:', channelId);\n        await this.joinChannel(channelId);\n        console.log('Successfully joined channel:', channelId);\n      }\n    } catch (error) {\n      console.error('WebSocket connection failed:', error);\n      this.handleError(error instanceof Error ? error : new Error('WebSocket connection failed'));\n      throw error;\n    }\n  }\n  startHeartbeat() {\n    if (this.heartbeatInterval) {\n      clearInterval(this.heartbeatInterval);\n    }\n    this.heartbeatInterval = setInterval(() => {\n      if (!this.isConnected()) {\n        return;\n      }\n\n      // Check if we haven't received a heartbeat response in 30 seconds\n      if (Date.now() - this.lastHeartbeatResponse > 30000) {\n        console.warn('No heartbeat response received, reconnecting...');\n        this.reconnect();\n        return;\n      }\n      try {\n        var _this$socket;\n        (_this$socket = this.socket) === null || _this$socket === void 0 ? void 0 : _this$socket.send(JSON.stringify({\n          type: 'ping'\n        }));\n      } catch (error) {\n        console.error('Error sending heartbeat:', error);\n        this.reconnect();\n      }\n    }, 15000); // Send heartbeat every 15 seconds\n  }\n  reconnect() {\n    if (this.currentChannelId) {\n      this.disconnect();\n      this.connect(this.currentChannelId).catch(console.error);\n    }\n  }\n  async joinChannel(channelId) {\n    if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {\n      throw new Error('Cannot join channel: WebSocket is not connected');\n    }\n    if (this.isConnectedToChannel(channelId)) {\n      console.log('[DEBUG] Already joined channel:', channelId);\n      return;\n    }\n    return new Promise((resolve, reject) => {\n      const joinMessage = {\n        type: 'join',\n        data: {\n          channel_id: parseInt(channelId)\n        }\n      };\n      const joinTimeout = setTimeout(() => {\n        var _this$socket2;\n        (_this$socket2 = this.socket) === null || _this$socket2 === void 0 ? void 0 : _this$socket2.removeEventListener('message', handleJoinResponse);\n        reject(new Error('Channel join timeout'));\n      }, 10000);\n      const handleJoinResponse = event => {\n        try {\n          var _data$data9, _data$data9$channel_i;\n          const data = JSON.parse(event.data);\n          console.log('[DEBUG] Received join response:', data);\n          if (data.type === 'joined' && ((_data$data9 = data.data) === null || _data$data9 === void 0 ? void 0 : (_data$data9$channel_i = _data$data9.channel_id) === null || _data$data9$channel_i === void 0 ? void 0 : _data$data9$channel_i.toString()) === channelId) {\n            var _this$socket3;\n            clearTimeout(joinTimeout);\n            (_this$socket3 = this.socket) === null || _this$socket3 === void 0 ? void 0 : _this$socket3.removeEventListener('message', handleJoinResponse);\n            this.joinedChannels.add(channelId);\n            console.log('[DEBUG] Successfully joined channel:', channelId);\n            resolve();\n          } else if (data.type === 'error') {\n            var _this$socket4;\n            clearTimeout(joinTimeout);\n            (_this$socket4 = this.socket) === null || _this$socket4 === void 0 ? void 0 : _this$socket4.removeEventListener('message', handleJoinResponse);\n            console.error('[DEBUG] Error joining channel:', data.message);\n            reject(new Error(data.message));\n          }\n        } catch (error) {\n          console.error('[DEBUG] Error handling join response:', error);\n        }\n      };\n      if (this.socket) {\n        this.socket.addEventListener('message', handleJoinResponse);\n        console.log('[DEBUG] Sending join message:', joinMessage);\n        this.socket.send(JSON.stringify(joinMessage));\n      } else {\n        clearTimeout(joinTimeout);\n        reject(new Error('WebSocket not available'));\n      }\n    });\n  }\n  handleError(error) {\n    console.error('WebSocket error:', error);\n    this.errorHandlers.forEach(handler => handler(error));\n  }\n  isConnected() {\n    return this.socket !== null && this.socket.readyState === WebSocket.OPEN;\n  }\n  isConnectedToChannel(channelId) {\n    return this.isConnected() && this.joinedChannels.has(channelId) && this.currentChannelId === channelId;\n  }\n  onMessage(handler) {\n    this.messageHandlers.push(handler);\n    return () => {\n      this.messageHandlers = this.messageHandlers.filter(h => h !== handler);\n    };\n  }\n  onError(handler) {\n    this.errorHandlers.push(handler);\n    return () => {\n      this.errorHandlers = this.errorHandlers.filter(h => h !== handler);\n    };\n  }\n  disconnect() {\n    console.log('[DEBUG] Disconnecting WebSocket...');\n    this.isReconnecting = false;\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n    if (this.heartbeatInterval) {\n      clearInterval(this.heartbeatInterval);\n      this.heartbeatInterval = null;\n    }\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\n      this.socket.close(1000);\n    }\n    this.socket = null;\n    this.joinedChannels.clear();\n    this.messageHandlers = [];\n    this.errorHandlers = [];\n    this.reconnectAttempts = 0;\n    this.connectionPromise = null;\n    this.joinPromise = null;\n    this.currentChannelId = null;\n    console.log('[DEBUG] WebSocket disconnected and state cleared');\n  }\n  async processMessageQueue() {\n    if (this.processingQueue || this.messageQueue.length === 0) return;\n    this.processingQueue = true;\n    console.log(`Processing message queue (${this.messageQueue.length} messages)`);\n    while (this.messageQueue.length > 0) {\n      const message = this.messageQueue[0];\n      try {\n        if (this.isConnectedToChannel(message.channelId)) {\n          await this.sendMessage(message.channelId, message.content);\n          this.messageQueue.shift(); // Remove the successfully sent message\n        } else {\n          // If we're not connected to the channel, try to connect\n          try {\n            await this.connect(message.channelId);\n          } catch (error) {\n            console.error('Failed to connect while processing queue:', error);\n            break; // Stop processing if we can't connect\n          }\n        }\n      } catch (error) {\n        console.error('Failed to send queued message:', error);\n        // If sending fails, leave the message in the queue and try again later\n        break;\n      }\n    }\n    this.processingQueue = false;\n  }\n  async sendMessage(channelId, content) {\n    console.log('Attempting to send message:', {\n      channelId,\n      content\n    });\n    if (!this.isConnectedToChannel(channelId)) {\n      console.log('Not connected to channel, attempting to connect...');\n      try {\n        await this.connect(channelId);\n      } catch (error) {\n        console.error('Failed to connect:', error);\n        throw error;\n      }\n    }\n    const message = {\n      type: 'message',\n      data: {\n        channel_id: parseInt(channelId),\n        content: content\n      }\n    };\n    if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {\n      console.error('WebSocket is not connected');\n      throw new Error('WebSocket is not connected');\n    }\n    try {\n      console.log('Sending WebSocket message:', message);\n      this.socket.send(JSON.stringify(message));\n      console.log('Message sent successfully');\n    } catch (error) {\n      console.error('Error sending message:', error);\n      throw error;\n    }\n  }\n  async attemptReconnect() {\n    if (this.isReconnecting || this.reconnectAttempts >= this.maxReconnectAttempts) {\n      console.log('Skipping reconnect: already reconnecting or max attempts reached');\n      return;\n    }\n    this.isReconnecting = true;\n    this.reconnectAttempts++;\n    console.log(`Attempting to reconnect (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})...`);\n    if (this.currentChannelId) {\n      const backoffTime = Math.min(1000 * Math.pow(2, this.reconnectAttempts - 1), 10000);\n      if (this.reconnectTimeout) {\n        clearTimeout(this.reconnectTimeout);\n      }\n      this.reconnectTimeout = setTimeout(async () => {\n        try {\n          await this.connect(this.currentChannelId);\n          this.isReconnecting = false;\n          // Process any queued messages after successful reconnection\n          await this.processMessageQueue();\n        } catch (error) {\n          console.error('Reconnection failed:', error);\n          if (this.reconnectAttempts < this.maxReconnectAttempts) {\n            this.isReconnecting = false; // Reset flag to allow next attempt\n            this.attemptReconnect();\n          } else {\n            console.log('Max reconnection attempts reached');\n            this.isReconnecting = false;\n            this.handleError(new Error('Failed to reconnect after maximum attempts'));\n          }\n        }\n      }, backoffTime);\n    } else {\n      this.isReconnecting = false;\n    }\n  }\n  getChatSocketState() {\n    var _this$socket5;\n    return ((_this$socket5 = this.socket) === null || _this$socket5 === void 0 ? void 0 : _this$socket5.readyState) || WebSocket.CLOSED;\n  }\n  offMessage(handler) {\n    this.messageHandlers = this.messageHandlers.filter(h => h !== handler);\n  }\n  offError(handler) {\n    this.errorHandlers = this.errorHandlers.filter(h => h !== handler);\n  }\n}\nconst wsService = new WebSocketService();\nexport default wsService;","map":{"version":3,"names":["getAuthToken","WebSocketService","constructor","socket","messageHandlers","errorHandlers","currentChannelId","joinedChannels","Set","messageQueue","reconnectAttempts","maxReconnectAttempts","reconnectTimeout","isReconnecting","connectionPromise","joinPromise","lastMessageId","processingQueue","heartbeatInterval","lastHeartbeatResponse","Date","now","handleClose","event","console","log","code","reason","wasConnected","readyState","WebSocket","OPEN","clear","attemptReconnect","handleWebSocketMessage","_data$data8","_data$data8$channel_i","data","JSON","parse","type","forEach","handler","_data$data","message","channelId","_data$data2","_data$data3","_data$data4","messageId","_data$data5","_data$data6","_data$data7","reply","parentMessageId","channel_id","toString","add","error","handleError","connect","isConnected","isConnectedToChannel","disconnect","token","Error","wsProtocol","window","location","protocol","wsUrl","host","replace","Promise","resolve","reject","timeout","setTimeout","onopen","clearTimeout","startHeartbeat","onerror","onclose","onmessage","joinChannel","clearInterval","setInterval","warn","reconnect","_this$socket","send","stringify","catch","joinMessage","parseInt","joinTimeout","_this$socket2","removeEventListener","handleJoinResponse","_data$data9","_data$data9$channel_i","_this$socket3","_this$socket4","addEventListener","has","onMessage","push","filter","h","onError","close","processMessageQueue","length","sendMessage","content","shift","backoffTime","Math","min","pow","getChatSocketState","_this$socket5","CLOSED","offMessage","offError","wsService"],"sources":["Z:/GAUNTLET/projects/SERMO/sermo-app/frontend/src/services/websocket/index.ts"],"sourcesContent":["import { WebSocketMessage, Message } from '../../types';\nimport { getAuthToken } from '../api/auth';\nimport { store } from '../../store';\nimport { addMessage, setReplies } from '../../store/messages/messagesSlice';\n\n// Add WebSocket message types\ninterface WebSocketJoinMessage {\n  type: 'join_channel';\n  channel_id: string;\n}\n\ninterface WebSocketJoinResponse {\n  type: 'channel_joined' | 'channel_join_error';\n  channelId: string;\n  error?: string;\n}\n\nclass WebSocketService {\n  private socket: WebSocket | null = null;\n  private messageHandlers: ((message: WebSocketMessage) => void)[] = [];\n  private errorHandlers: ((error: Error) => void)[] = [];\n  private currentChannelId: string | null = null;\n  private joinedChannels: Set<string> = new Set();\n  private messageQueue: { channelId: string; content: string }[] = [];\n  private reconnectAttempts = 0;\n  private maxReconnectAttempts = 5;\n  private reconnectTimeout: NodeJS.Timeout | null = null;\n  private isReconnecting = false;\n  private connectionPromise: Promise<void> | null = null;\n  private joinPromise: Promise<void> | null = null;\n  private lastMessageId: string | null = null;\n  private processingQueue = false;\n  private heartbeatInterval: NodeJS.Timeout | null = null;\n  private lastHeartbeatResponse: number = Date.now();\n\n  public async connect(channelId: string): Promise<void> {\n    if (this.isConnected() && this.isConnectedToChannel(channelId)) {\n      console.log('Already connected to channel:', channelId);\n      return;\n    }\n\n    // Always disconnect before connecting to ensure clean state\n    this.disconnect();\n    this.currentChannelId = channelId;\n    this.isReconnecting = false;\n    this.reconnectAttempts = 0;\n    \n    try {\n      const token = getAuthToken();\n      if (!token) {\n        throw new Error('No authentication token found');\n      }\n\n      console.log('Connecting to WebSocket server...');\n      // Use the same host as the current page, but with ws/wss protocol\n      const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n      const wsUrl = `${wsProtocol}//${window.location.host}/api/v1/ws/chat?token=${token}`;\n      console.log('WebSocket URL:', wsUrl.replace(token, '[REDACTED]'));\n      \n      this.socket = new WebSocket(wsUrl);\n\n      await new Promise<void>((resolve, reject) => {\n        const timeout = setTimeout(() => {\n          console.error('WebSocket connection timeout');\n          reject(new Error('WebSocket connection timeout'));\n        }, 5000);\n\n        if (this.socket) {\n          this.socket.onopen = () => {\n            console.log('WebSocket connection opened successfully');\n            clearTimeout(timeout);\n            this.startHeartbeat();\n            resolve();\n          };\n\n          this.socket.onerror = (error) => {\n            console.error('WebSocket connection error:', error);\n            clearTimeout(timeout);\n            reject(error);\n          };\n\n          this.socket.onclose = (event) => {\n            console.log('WebSocket connection closed:', event.code, event.reason);\n            this.handleClose(event);\n          };\n\n          this.socket.onmessage = (event) => {\n            try {\n              console.log('Raw WebSocket message received:', event.data);\n              this.handleWebSocketMessage(event);\n            } catch (error) {\n              console.error('Error handling WebSocket message:', error);\n            }\n          };\n        }\n      });\n\n      if (this.socket) {\n        console.log('Joining channel:', channelId);\n        await this.joinChannel(channelId);\n        console.log('Successfully joined channel:', channelId);\n      }\n      \n    } catch (error) {\n      console.error('WebSocket connection failed:', error);\n      this.handleError(error instanceof Error ? error : new Error('WebSocket connection failed'));\n      throw error;\n    }\n  }\n\n  private startHeartbeat(): void {\n    if (this.heartbeatInterval) {\n      clearInterval(this.heartbeatInterval);\n    }\n\n    this.heartbeatInterval = setInterval(() => {\n      if (!this.isConnected()) {\n        return;\n      }\n\n      // Check if we haven't received a heartbeat response in 30 seconds\n      if (Date.now() - this.lastHeartbeatResponse > 30000) {\n        console.warn('No heartbeat response received, reconnecting...');\n        this.reconnect();\n        return;\n      }\n\n      try {\n        this.socket?.send(JSON.stringify({ type: 'ping' }));\n      } catch (error) {\n        console.error('Error sending heartbeat:', error);\n        this.reconnect();\n      }\n    }, 15000); // Send heartbeat every 15 seconds\n  }\n\n  private reconnect(): void {\n    if (this.currentChannelId) {\n      this.disconnect();\n      this.connect(this.currentChannelId).catch(console.error);\n    }\n  }\n\n  private handleClose = (event: CloseEvent) => {\n    console.log('[DEBUG] WebSocket closed:', event.code, event.reason);\n    if (this.socket === null) return;\n    \n    const wasConnected = this.socket.readyState === WebSocket.OPEN;\n    this.socket = null;\n    this.joinedChannels.clear();\n\n    if (event.code !== 1000 && wasConnected) {\n      if (!this.isReconnecting && this.reconnectAttempts < this.maxReconnectAttempts) {\n        console.log('[DEBUG] Attempting reconnect after close');\n        this.attemptReconnect();\n      }\n    }\n  };\n\n  public async joinChannel(channelId: string): Promise<void> {\n    if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {\n      throw new Error('Cannot join channel: WebSocket is not connected');\n    }\n\n    if (this.isConnectedToChannel(channelId)) {\n      console.log('[DEBUG] Already joined channel:', channelId);\n      return;\n    }\n\n    return new Promise((resolve, reject) => {\n      const joinMessage = {\n        type: 'join',\n        data: {\n          channel_id: parseInt(channelId)\n        }\n      };\n      \n      const joinTimeout = setTimeout(() => {\n        this.socket?.removeEventListener('message', handleJoinResponse);\n        reject(new Error('Channel join timeout'));\n      }, 10000);\n      \n      const handleJoinResponse = (event: MessageEvent) => {\n        try {\n          const data = JSON.parse(event.data);\n          console.log('[DEBUG] Received join response:', data);\n          \n          if (data.type === 'joined' && data.data?.channel_id?.toString() === channelId) {\n            clearTimeout(joinTimeout);\n            this.socket?.removeEventListener('message', handleJoinResponse);\n            this.joinedChannels.add(channelId);\n            console.log('[DEBUG] Successfully joined channel:', channelId);\n            resolve();\n          } else if (data.type === 'error') {\n            clearTimeout(joinTimeout);\n            this.socket?.removeEventListener('message', handleJoinResponse);\n            console.error('[DEBUG] Error joining channel:', data.message);\n            reject(new Error(data.message));\n          }\n        } catch (error) {\n          console.error('[DEBUG] Error handling join response:', error);\n        }\n      };\n\n      if (this.socket) {\n        this.socket.addEventListener('message', handleJoinResponse);\n        console.log('[DEBUG] Sending join message:', joinMessage);\n        this.socket.send(JSON.stringify(joinMessage));\n      } else {\n        clearTimeout(joinTimeout);\n        reject(new Error('WebSocket not available'));\n      }\n    });\n  }\n\n  private handleError(error: Error): void {\n    console.error('WebSocket error:', error);\n    this.errorHandlers.forEach(handler => handler(error));\n  }\n\n  public isConnected(): boolean {\n    return this.socket !== null && this.socket.readyState === WebSocket.OPEN;\n  }\n\n  private isConnectedToChannel(channelId: string): boolean {\n    return this.isConnected() && this.joinedChannels.has(channelId) && this.currentChannelId === channelId;\n  }\n\n  public onMessage(handler: (message: WebSocketMessage) => void): () => void {\n    this.messageHandlers.push(handler);\n    return () => {\n      this.messageHandlers = this.messageHandlers.filter(h => h !== handler);\n    };\n  }\n\n  public onError(handler: (error: Error) => void): () => void {\n    this.errorHandlers.push(handler);\n    return () => {\n      this.errorHandlers = this.errorHandlers.filter(h => h !== handler);\n    };\n  }\n\n  public disconnect(): void {\n    console.log('[DEBUG] Disconnecting WebSocket...');\n    this.isReconnecting = false;\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n    if (this.heartbeatInterval) {\n      clearInterval(this.heartbeatInterval);\n      this.heartbeatInterval = null;\n    }\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\n      this.socket.close(1000);\n    }\n    this.socket = null;\n    this.joinedChannels.clear();\n    this.messageHandlers = [];\n    this.errorHandlers = [];\n    this.reconnectAttempts = 0;\n    this.connectionPromise = null;\n    this.joinPromise = null;\n    this.currentChannelId = null;\n    console.log('[DEBUG] WebSocket disconnected and state cleared');\n  }\n\n  private async processMessageQueue(): Promise<void> {\n    if (this.processingQueue || this.messageQueue.length === 0) return;\n\n    this.processingQueue = true;\n    console.log(`Processing message queue (${this.messageQueue.length} messages)`);\n\n    while (this.messageQueue.length > 0) {\n      const message = this.messageQueue[0];\n      \n      try {\n        if (this.isConnectedToChannel(message.channelId)) {\n          await this.sendMessage(message.channelId, message.content);\n          this.messageQueue.shift(); // Remove the successfully sent message\n        } else {\n          // If we're not connected to the channel, try to connect\n          try {\n            await this.connect(message.channelId);\n          } catch (error) {\n            console.error('Failed to connect while processing queue:', error);\n            break; // Stop processing if we can't connect\n          }\n        }\n      } catch (error) {\n        console.error('Failed to send queued message:', error);\n        // If sending fails, leave the message in the queue and try again later\n        break;\n      }\n    }\n\n    this.processingQueue = false;\n  }\n\n  public async sendMessage(channelId: string, content: string): Promise<void> {\n    console.log('Attempting to send message:', { channelId, content });\n\n    if (!this.isConnectedToChannel(channelId)) {\n      console.log('Not connected to channel, attempting to connect...');\n      try {\n        await this.connect(channelId);\n      } catch (error) {\n        console.error('Failed to connect:', error);\n        throw error;\n      }\n    }\n\n    const message = {\n      type: 'message',\n      data: {\n        channel_id: parseInt(channelId),\n        content: content\n      }\n    };\n\n    if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {\n      console.error('WebSocket is not connected');\n      throw new Error('WebSocket is not connected');\n    }\n\n    try {\n      console.log('Sending WebSocket message:', message);\n      this.socket.send(JSON.stringify(message));\n      console.log('Message sent successfully');\n    } catch (error) {\n      console.error('Error sending message:', error);\n      throw error;\n    }\n  }\n\n  private async attemptReconnect(): Promise<void> {\n    if (this.isReconnecting || this.reconnectAttempts >= this.maxReconnectAttempts) {\n      console.log('Skipping reconnect: already reconnecting or max attempts reached');\n      return;\n    }\n\n    this.isReconnecting = true;\n    this.reconnectAttempts++;\n\n    console.log(`Attempting to reconnect (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})...`);\n\n    if (this.currentChannelId) {\n      const backoffTime = Math.min(1000 * Math.pow(2, this.reconnectAttempts - 1), 10000);\n      \n      if (this.reconnectTimeout) {\n        clearTimeout(this.reconnectTimeout);\n      }\n\n      this.reconnectTimeout = setTimeout(async () => {\n        try {\n          await this.connect(this.currentChannelId!);\n          this.isReconnecting = false;\n          // Process any queued messages after successful reconnection\n          await this.processMessageQueue();\n        } catch (error) {\n          console.error('Reconnection failed:', error);\n          if (this.reconnectAttempts < this.maxReconnectAttempts) {\n            this.isReconnecting = false; // Reset flag to allow next attempt\n            this.attemptReconnect();\n          } else {\n            console.log('Max reconnection attempts reached');\n            this.isReconnecting = false;\n            this.handleError(new Error('Failed to reconnect after maximum attempts'));\n          }\n        }\n      }, backoffTime);\n    } else {\n      this.isReconnecting = false;\n    }\n  }\n\n  public getChatSocketState(): number {\n    return this.socket?.readyState || WebSocket.CLOSED;\n  }\n\n  // Update message handler to track last message ID\n  private handleWebSocketMessage = (event: MessageEvent) => {\n    try {\n      const data = JSON.parse(event.data) as WebSocketMessage;\n      console.log('Raw WebSocket message received:', event.data);\n      console.log('Parsed WebSocket message:', data);\n      \n      // Update heartbeat timestamp for any message\n      this.lastHeartbeatResponse = Date.now();\n\n      switch (data.type) {\n        case 'new_message':\n          console.log('Broadcasting new message to handlers:', data);\n          this.messageHandlers.forEach(handler => handler({\n            type: 'new_message',\n            data: {\n              message: data.message as Message,\n              channelId: data.channelId || (data.data?.channelId as string)\n            }\n          }));\n          break;\n          \n        case 'message_updated':\n          console.log('Broadcasting updated message to handlers:', data);\n          this.messageHandlers.forEach(handler => handler({\n            type: 'message_updated',\n            data: {\n              message: data.message as Message,\n              channelId: data.channelId || (data.data?.channelId as string)\n            }\n          }));\n          break;\n          \n        case 'message_deleted':\n          console.log('Broadcasting deleted message to handlers:', data);\n          this.messageHandlers.forEach(handler => handler({\n            type: 'message_deleted',\n            data: {\n              messageId: data.messageId || (data.data?.messageId as string),\n              channelId: data.channelId || (data.data?.channelId as string)\n            }\n          }));\n          break;\n          \n        case 'new_reply':\n          console.log('Broadcasting new reply to handlers:', data);\n          this.messageHandlers.forEach(handler => handler({\n            type: 'new_reply',\n            data: {\n              reply: data.reply || (data.data?.reply as Message),\n              parentMessageId: data.parentMessageId || (data.data?.parentMessageId as string),\n              channelId: data.channelId || (data.data?.channelId as string)\n            }\n          }));\n          break;\n\n        case 'pong':\n          console.log('Received heartbeat response');\n          break;\n\n        case 'joined':\n          const channelId = data.data?.channel_id?.toString();\n          if (channelId) {\n            console.log('Channel joined:', channelId);\n            this.joinedChannels.add(channelId);\n          }\n          break;\n\n        default:\n          console.log('Unknown websocket message type:', data.type);\n      }\n    } catch (error) {\n      console.error('Error handling websocket message:', error);\n      this.handleError(error as Error);\n    }\n  };\n\n  public offMessage(handler: (message: WebSocketMessage) => void): void {\n    this.messageHandlers = this.messageHandlers.filter(h => h !== handler);\n  }\n\n  public offError(handler: (error: Error) => void): void {\n    this.errorHandlers = this.errorHandlers.filter(h => h !== handler);\n  }\n}\n\nconst wsService = new WebSocketService();\nexport default wsService; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}