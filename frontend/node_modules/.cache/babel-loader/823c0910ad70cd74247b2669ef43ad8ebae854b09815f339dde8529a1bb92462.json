{"ast":null,"code":"import { store } from '../../store';\nimport { addMessage, updateMessage } from '../../store/messages/messagesSlice';\nimport { updateUserStatus } from '../../store/chat/chatSlice';\nclass WebSocketService {\n  constructor() {\n    this.chatWs = null;\n    this.presenceWs = null;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectTimeout = null;\n    this.pingInterval = null;\n    this.channels = new Set();\n  }\n  connect() {\n    this.connectChat();\n    this.connectPresence();\n  }\n  getAuthToken() {\n    var _state$auth;\n    const state = store.getState();\n    return ((_state$auth = state.auth) === null || _state$auth === void 0 ? void 0 : _state$auth.token) || null;\n  }\n  connectChat() {\n    var _this$chatWs;\n    if (((_this$chatWs = this.chatWs) === null || _this$chatWs === void 0 ? void 0 : _this$chatWs.readyState) === WebSocket.OPEN) return;\n    const token = this.getAuthToken();\n    if (!token) {\n      console.error('No auth token available for WebSocket connection');\n      return;\n    }\n\n    // Use secure WebSocket if the page is served over HTTPS\n    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n    const wsUrl = `${protocol}//${window.location.host}/chat?token=${token}`;\n    this.chatWs = new WebSocket(wsUrl);\n    this.chatWs.onopen = () => {\n      console.log('Chat WebSocket connected');\n      this.reconnectAttempts = 0;\n      this.startPingInterval();\n\n      // Rejoin all channels\n      this.channels.forEach(channelId => {\n        this.joinChannel(channelId);\n      });\n    };\n    this.chatWs.onmessage = this.handleMessage.bind(this);\n    this.chatWs.onclose = () => {\n      console.log('Chat WebSocket disconnected');\n      this.stopPingInterval();\n      this.attemptReconnect('chat');\n    };\n    this.chatWs.onerror = error => {\n      console.error('Chat WebSocket error:', error);\n    };\n  }\n  connectPresence() {\n    var _this$presenceWs;\n    if (((_this$presenceWs = this.presenceWs) === null || _this$presenceWs === void 0 ? void 0 : _this$presenceWs.readyState) === WebSocket.OPEN) return;\n    const token = this.getAuthToken();\n    if (!token) {\n      console.error('No auth token available for WebSocket connection');\n      return;\n    }\n\n    // Use secure WebSocket if the page is served over HTTPS\n    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n    const wsUrl = `${protocol}//${window.location.host}/presence?token=${token}`;\n    this.presenceWs = new WebSocket(wsUrl);\n    this.presenceWs.onopen = () => {\n      console.log('Presence WebSocket connected');\n      this.reconnectAttempts = 0;\n    };\n    this.presenceWs.onmessage = this.handleMessage.bind(this);\n    this.presenceWs.onclose = () => {\n      console.log('Presence WebSocket disconnected');\n      this.attemptReconnect('presence');\n    };\n    this.presenceWs.onerror = error => {\n      console.error('Presence WebSocket error:', error);\n    };\n  }\n  handleMessage(event) {\n    try {\n      const data = JSON.parse(event.data);\n      console.log('WebSocket message received:', data);\n      switch (data.type) {\n        case 'NEW_MESSAGE':\n          if (data.channelId && data.message) {\n            store.dispatch(addMessage({\n              channelId: data.channelId,\n              message: data.message\n            }));\n          }\n          break;\n        case 'UPDATE_MESSAGE':\n          if (data.channelId && data.id && data.updates) {\n            const updatedMessage = {\n              id: data.id,\n              ...data.updates\n            };\n            store.dispatch(updateMessage({\n              channelId: data.channelId,\n              id: data.id,\n              message: updatedMessage\n            }));\n          }\n          break;\n        case 'USER_STATUS':\n          if (data.userId && data.status) {\n            store.dispatch(updateUserStatus({\n              userId: data.userId,\n              status: data.status\n            }));\n          }\n          break;\n        case 'PONG':\n          // Handle pong response\n          break;\n        default:\n          console.warn('Unknown message type:', data.type);\n      }\n    } catch (error) {\n      console.error('Error handling WebSocket message:', error);\n    }\n  }\n  attemptReconnect(type) {\n    if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n      console.error('Max reconnection attempts reached');\n      return;\n    }\n    this.reconnectAttempts++;\n    const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 10000);\n    this.reconnectTimeout = setTimeout(() => {\n      console.log(`Attempting to reconnect ${type} (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\n      if (type === 'chat') {\n        this.connectChat();\n      } else {\n        this.connectPresence();\n      }\n    }, delay);\n  }\n  startPingInterval() {\n    this.pingInterval = setInterval(() => {\n      this.send({\n        type: 'PING'\n      });\n    }, 30000);\n  }\n  stopPingInterval() {\n    if (this.pingInterval) {\n      clearInterval(this.pingInterval);\n      this.pingInterval = null;\n    }\n  }\n  send(data) {\n    // Send chat messages through chat WebSocket\n    if (data.type === 'NEW_MESSAGE' || data.type === 'UPDATE_MESSAGE' || data.type === 'JOIN_CHANNEL' || data.type === 'LEAVE_CHANNEL') {\n      var _this$chatWs2;\n      if (((_this$chatWs2 = this.chatWs) === null || _this$chatWs2 === void 0 ? void 0 : _this$chatWs2.readyState) === WebSocket.OPEN) {\n        this.chatWs.send(JSON.stringify(data));\n      } else {\n        console.warn('Chat WebSocket is not connected');\n      }\n    }\n    // Send presence updates through presence WebSocket\n    else if (data.type === 'USER_STATUS') {\n      var _this$presenceWs2;\n      if (((_this$presenceWs2 = this.presenceWs) === null || _this$presenceWs2 === void 0 ? void 0 : _this$presenceWs2.readyState) === WebSocket.OPEN) {\n        this.presenceWs.send(JSON.stringify(data));\n      } else {\n        console.warn('Presence WebSocket is not connected');\n      }\n    }\n  }\n  joinChannel(channelId) {\n    this.channels.add(channelId);\n    this.send({\n      type: 'JOIN_CHANNEL',\n      channelId\n    });\n  }\n  leaveChannel(channelId) {\n    this.channels.delete(channelId);\n    this.send({\n      type: 'LEAVE_CHANNEL',\n      channelId\n    });\n  }\n  disconnect() {\n    this.channels.clear();\n    if (this.chatWs) {\n      this.chatWs.close();\n      this.chatWs = null;\n    }\n    if (this.presenceWs) {\n      this.presenceWs.close();\n      this.presenceWs = null;\n    }\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n    this.stopPingInterval();\n  }\n}\nexport default new WebSocketService();","map":{"version":3,"names":["store","addMessage","updateMessage","updateUserStatus","WebSocketService","constructor","chatWs","presenceWs","reconnectAttempts","maxReconnectAttempts","reconnectTimeout","pingInterval","channels","Set","connect","connectChat","connectPresence","getAuthToken","_state$auth","state","getState","auth","token","_this$chatWs","readyState","WebSocket","OPEN","console","error","protocol","window","location","wsUrl","host","onopen","log","startPingInterval","forEach","channelId","joinChannel","onmessage","handleMessage","bind","onclose","stopPingInterval","attemptReconnect","onerror","_this$presenceWs","event","data","JSON","parse","type","message","dispatch","id","updates","updatedMessage","userId","status","warn","delay","Math","min","pow","setTimeout","setInterval","send","clearInterval","_this$chatWs2","stringify","_this$presenceWs2","add","leaveChannel","delete","disconnect","clear","close","clearTimeout"],"sources":["Z:/GAUNTLET/projects/SERMO/sermo-app/frontend/src/services/websocket/index.ts"],"sourcesContent":["import { Message, User, StoreMessage } from '../../types';\r\nimport { store } from '../../store';\r\nimport { addMessage, updateMessage } from '../../store/messages/messagesSlice';\r\nimport { updateUserStatus } from '../../store/chat/chatSlice';\r\n\r\ninterface WebSocketMessage {\r\n  type: 'NEW_MESSAGE' | 'UPDATE_MESSAGE' | 'USER_STATUS' | 'PING' | 'PONG' | 'JOIN_CHANNEL' | 'LEAVE_CHANNEL';\r\n  channelId?: string;\r\n  message?: StoreMessage;\r\n  id?: string;\r\n  updates?: Partial<StoreMessage>;\r\n  userId?: string;\r\n  status?: 'online' | 'offline' | 'away' | 'busy';\r\n}\r\n\r\nclass WebSocketService {\r\n  private chatWs: WebSocket | null = null;\r\n  private presenceWs: WebSocket | null = null;\r\n  private reconnectAttempts = 0;\r\n  private maxReconnectAttempts = 5;\r\n  private reconnectTimeout: NodeJS.Timeout | null = null;\r\n  private pingInterval: NodeJS.Timeout | null = null;\r\n  private channels: Set<string> = new Set();\r\n\r\n  connect() {\r\n    this.connectChat();\r\n    this.connectPresence();\r\n  }\r\n\r\n  private getAuthToken(): string | null {\r\n    const state = store.getState();\r\n    return state.auth?.token || null;\r\n  }\r\n\r\n  private connectChat() {\r\n    if (this.chatWs?.readyState === WebSocket.OPEN) return;\r\n\r\n    const token = this.getAuthToken();\r\n    if (!token) {\r\n      console.error('No auth token available for WebSocket connection');\r\n      return;\r\n    }\r\n\r\n    // Use secure WebSocket if the page is served over HTTPS\r\n    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\r\n    const wsUrl = `${protocol}//${window.location.host}/chat?token=${token}`;\r\n    \r\n    this.chatWs = new WebSocket(wsUrl);\r\n    \r\n    this.chatWs.onopen = () => {\r\n      console.log('Chat WebSocket connected');\r\n      this.reconnectAttempts = 0;\r\n      this.startPingInterval();\r\n      \r\n      // Rejoin all channels\r\n      this.channels.forEach(channelId => {\r\n        this.joinChannel(channelId);\r\n      });\r\n    };\r\n\r\n    this.chatWs.onmessage = this.handleMessage.bind(this);\r\n    this.chatWs.onclose = () => {\r\n      console.log('Chat WebSocket disconnected');\r\n      this.stopPingInterval();\r\n      this.attemptReconnect('chat');\r\n    };\r\n    this.chatWs.onerror = (error) => {\r\n      console.error('Chat WebSocket error:', error);\r\n    };\r\n  }\r\n\r\n  private connectPresence() {\r\n    if (this.presenceWs?.readyState === WebSocket.OPEN) return;\r\n\r\n    const token = this.getAuthToken();\r\n    if (!token) {\r\n      console.error('No auth token available for WebSocket connection');\r\n      return;\r\n    }\r\n\r\n    // Use secure WebSocket if the page is served over HTTPS\r\n    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\r\n    const wsUrl = `${protocol}//${window.location.host}/presence?token=${token}`;\r\n    \r\n    this.presenceWs = new WebSocket(wsUrl);\r\n    \r\n    this.presenceWs.onopen = () => {\r\n      console.log('Presence WebSocket connected');\r\n      this.reconnectAttempts = 0;\r\n    };\r\n\r\n    this.presenceWs.onmessage = this.handleMessage.bind(this);\r\n    this.presenceWs.onclose = () => {\r\n      console.log('Presence WebSocket disconnected');\r\n      this.attemptReconnect('presence');\r\n    };\r\n    this.presenceWs.onerror = (error) => {\r\n      console.error('Presence WebSocket error:', error);\r\n    };\r\n  }\r\n\r\n  private handleMessage(event: MessageEvent) {\r\n    try {\r\n      const data = JSON.parse(event.data) as WebSocketMessage;\r\n      console.log('WebSocket message received:', data);\r\n\r\n      switch (data.type) {\r\n        case 'NEW_MESSAGE':\r\n          if (data.channelId && data.message) {\r\n            store.dispatch(addMessage({\r\n              channelId: data.channelId,\r\n              message: data.message\r\n            }));\r\n          }\r\n          break;\r\n\r\n        case 'UPDATE_MESSAGE':\r\n          if (data.channelId && data.id && data.updates) {\r\n            const updatedMessage = {\r\n              id: data.id,\r\n              ...data.updates\r\n            } as StoreMessage;\r\n            \r\n            store.dispatch(updateMessage({\r\n              channelId: data.channelId,\r\n              id: data.id,\r\n              message: updatedMessage\r\n            }));\r\n          }\r\n          break;\r\n\r\n        case 'USER_STATUS':\r\n          if (data.userId && data.status) {\r\n            store.dispatch(updateUserStatus({\r\n              userId: data.userId,\r\n              status: data.status\r\n            }));\r\n          }\r\n          break;\r\n\r\n        case 'PONG':\r\n          // Handle pong response\r\n          break;\r\n\r\n        default:\r\n          console.warn('Unknown message type:', data.type);\r\n      }\r\n    } catch (error) {\r\n      console.error('Error handling WebSocket message:', error);\r\n    }\r\n  }\r\n\r\n  private attemptReconnect(type: 'chat' | 'presence') {\r\n    if (this.reconnectAttempts >= this.maxReconnectAttempts) {\r\n      console.error('Max reconnection attempts reached');\r\n      return;\r\n    }\r\n\r\n    this.reconnectAttempts++;\r\n    const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 10000);\r\n    \r\n    this.reconnectTimeout = setTimeout(() => {\r\n      console.log(`Attempting to reconnect ${type} (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\r\n      if (type === 'chat') {\r\n        this.connectChat();\r\n      } else {\r\n        this.connectPresence();\r\n      }\r\n    }, delay);\r\n  }\r\n\r\n  private startPingInterval() {\r\n    this.pingInterval = setInterval(() => {\r\n      this.send({ type: 'PING' });\r\n    }, 30000);\r\n  }\r\n\r\n  private stopPingInterval() {\r\n    if (this.pingInterval) {\r\n      clearInterval(this.pingInterval);\r\n      this.pingInterval = null;\r\n    }\r\n  }\r\n\r\n  send(data: WebSocketMessage) {\r\n    // Send chat messages through chat WebSocket\r\n    if (data.type === 'NEW_MESSAGE' || data.type === 'UPDATE_MESSAGE' || data.type === 'JOIN_CHANNEL' || data.type === 'LEAVE_CHANNEL') {\r\n      if (this.chatWs?.readyState === WebSocket.OPEN) {\r\n        this.chatWs.send(JSON.stringify(data));\r\n      } else {\r\n        console.warn('Chat WebSocket is not connected');\r\n      }\r\n    }\r\n    // Send presence updates through presence WebSocket\r\n    else if (data.type === 'USER_STATUS') {\r\n      if (this.presenceWs?.readyState === WebSocket.OPEN) {\r\n        this.presenceWs.send(JSON.stringify(data));\r\n      } else {\r\n        console.warn('Presence WebSocket is not connected');\r\n      }\r\n    }\r\n  }\r\n\r\n  joinChannel(channelId: string) {\r\n    this.channels.add(channelId);\r\n    this.send({\r\n      type: 'JOIN_CHANNEL',\r\n      channelId\r\n    });\r\n  }\r\n\r\n  leaveChannel(channelId: string) {\r\n    this.channels.delete(channelId);\r\n    this.send({\r\n      type: 'LEAVE_CHANNEL',\r\n      channelId\r\n    });\r\n  }\r\n\r\n  disconnect() {\r\n    this.channels.clear();\r\n    if (this.chatWs) {\r\n      this.chatWs.close();\r\n      this.chatWs = null;\r\n    }\r\n    if (this.presenceWs) {\r\n      this.presenceWs.close();\r\n      this.presenceWs = null;\r\n    }\r\n    if (this.reconnectTimeout) {\r\n      clearTimeout(this.reconnectTimeout);\r\n      this.reconnectTimeout = null;\r\n    }\r\n    this.stopPingInterval();\r\n  }\r\n}\r\n\r\nexport default new WebSocketService(); "],"mappings":"AACA,SAASA,KAAK,QAAQ,aAAa;AACnC,SAASC,UAAU,EAAEC,aAAa,QAAQ,oCAAoC;AAC9E,SAASC,gBAAgB,QAAQ,4BAA4B;AAY7D,MAAMC,gBAAgB,CAAC;EAAAC,YAAA;IAAA,KACbC,MAAM,GAAqB,IAAI;IAAA,KAC/BC,UAAU,GAAqB,IAAI;IAAA,KACnCC,iBAAiB,GAAG,CAAC;IAAA,KACrBC,oBAAoB,GAAG,CAAC;IAAA,KACxBC,gBAAgB,GAA0B,IAAI;IAAA,KAC9CC,YAAY,GAA0B,IAAI;IAAA,KAC1CC,QAAQ,GAAgB,IAAIC,GAAG,CAAC,CAAC;EAAA;EAEzCC,OAAOA,CAAA,EAAG;IACR,IAAI,CAACC,WAAW,CAAC,CAAC;IAClB,IAAI,CAACC,eAAe,CAAC,CAAC;EACxB;EAEQC,YAAYA,CAAA,EAAkB;IAAA,IAAAC,WAAA;IACpC,MAAMC,KAAK,GAAGnB,KAAK,CAACoB,QAAQ,CAAC,CAAC;IAC9B,OAAO,EAAAF,WAAA,GAAAC,KAAK,CAACE,IAAI,cAAAH,WAAA,uBAAVA,WAAA,CAAYI,KAAK,KAAI,IAAI;EAClC;EAEQP,WAAWA,CAAA,EAAG;IAAA,IAAAQ,YAAA;IACpB,IAAI,EAAAA,YAAA,OAAI,CAACjB,MAAM,cAAAiB,YAAA,uBAAXA,YAAA,CAAaC,UAAU,MAAKC,SAAS,CAACC,IAAI,EAAE;IAEhD,MAAMJ,KAAK,GAAG,IAAI,CAACL,YAAY,CAAC,CAAC;IACjC,IAAI,CAACK,KAAK,EAAE;MACVK,OAAO,CAACC,KAAK,CAAC,kDAAkD,CAAC;MACjE;IACF;;IAEA;IACA,MAAMC,QAAQ,GAAGC,MAAM,CAACC,QAAQ,CAACF,QAAQ,KAAK,QAAQ,GAAG,MAAM,GAAG,KAAK;IACvE,MAAMG,KAAK,GAAG,GAAGH,QAAQ,KAAKC,MAAM,CAACC,QAAQ,CAACE,IAAI,eAAeX,KAAK,EAAE;IAExE,IAAI,CAAChB,MAAM,GAAG,IAAImB,SAAS,CAACO,KAAK,CAAC;IAElC,IAAI,CAAC1B,MAAM,CAAC4B,MAAM,GAAG,MAAM;MACzBP,OAAO,CAACQ,GAAG,CAAC,0BAA0B,CAAC;MACvC,IAAI,CAAC3B,iBAAiB,GAAG,CAAC;MAC1B,IAAI,CAAC4B,iBAAiB,CAAC,CAAC;;MAExB;MACA,IAAI,CAACxB,QAAQ,CAACyB,OAAO,CAACC,SAAS,IAAI;QACjC,IAAI,CAACC,WAAW,CAACD,SAAS,CAAC;MAC7B,CAAC,CAAC;IACJ,CAAC;IAED,IAAI,CAAChC,MAAM,CAACkC,SAAS,GAAG,IAAI,CAACC,aAAa,CAACC,IAAI,CAAC,IAAI,CAAC;IACrD,IAAI,CAACpC,MAAM,CAACqC,OAAO,GAAG,MAAM;MAC1BhB,OAAO,CAACQ,GAAG,CAAC,6BAA6B,CAAC;MAC1C,IAAI,CAACS,gBAAgB,CAAC,CAAC;MACvB,IAAI,CAACC,gBAAgB,CAAC,MAAM,CAAC;IAC/B,CAAC;IACD,IAAI,CAACvC,MAAM,CAACwC,OAAO,GAAIlB,KAAK,IAAK;MAC/BD,OAAO,CAACC,KAAK,CAAC,uBAAuB,EAAEA,KAAK,CAAC;IAC/C,CAAC;EACH;EAEQZ,eAAeA,CAAA,EAAG;IAAA,IAAA+B,gBAAA;IACxB,IAAI,EAAAA,gBAAA,OAAI,CAACxC,UAAU,cAAAwC,gBAAA,uBAAfA,gBAAA,CAAiBvB,UAAU,MAAKC,SAAS,CAACC,IAAI,EAAE;IAEpD,MAAMJ,KAAK,GAAG,IAAI,CAACL,YAAY,CAAC,CAAC;IACjC,IAAI,CAACK,KAAK,EAAE;MACVK,OAAO,CAACC,KAAK,CAAC,kDAAkD,CAAC;MACjE;IACF;;IAEA;IACA,MAAMC,QAAQ,GAAGC,MAAM,CAACC,QAAQ,CAACF,QAAQ,KAAK,QAAQ,GAAG,MAAM,GAAG,KAAK;IACvE,MAAMG,KAAK,GAAG,GAAGH,QAAQ,KAAKC,MAAM,CAACC,QAAQ,CAACE,IAAI,mBAAmBX,KAAK,EAAE;IAE5E,IAAI,CAACf,UAAU,GAAG,IAAIkB,SAAS,CAACO,KAAK,CAAC;IAEtC,IAAI,CAACzB,UAAU,CAAC2B,MAAM,GAAG,MAAM;MAC7BP,OAAO,CAACQ,GAAG,CAAC,8BAA8B,CAAC;MAC3C,IAAI,CAAC3B,iBAAiB,GAAG,CAAC;IAC5B,CAAC;IAED,IAAI,CAACD,UAAU,CAACiC,SAAS,GAAG,IAAI,CAACC,aAAa,CAACC,IAAI,CAAC,IAAI,CAAC;IACzD,IAAI,CAACnC,UAAU,CAACoC,OAAO,GAAG,MAAM;MAC9BhB,OAAO,CAACQ,GAAG,CAAC,iCAAiC,CAAC;MAC9C,IAAI,CAACU,gBAAgB,CAAC,UAAU,CAAC;IACnC,CAAC;IACD,IAAI,CAACtC,UAAU,CAACuC,OAAO,GAAIlB,KAAK,IAAK;MACnCD,OAAO,CAACC,KAAK,CAAC,2BAA2B,EAAEA,KAAK,CAAC;IACnD,CAAC;EACH;EAEQa,aAAaA,CAACO,KAAmB,EAAE;IACzC,IAAI;MACF,MAAMC,IAAI,GAAGC,IAAI,CAACC,KAAK,CAACH,KAAK,CAACC,IAAI,CAAqB;MACvDtB,OAAO,CAACQ,GAAG,CAAC,6BAA6B,EAAEc,IAAI,CAAC;MAEhD,QAAQA,IAAI,CAACG,IAAI;QACf,KAAK,aAAa;UAChB,IAAIH,IAAI,CAACX,SAAS,IAAIW,IAAI,CAACI,OAAO,EAAE;YAClCrD,KAAK,CAACsD,QAAQ,CAACrD,UAAU,CAAC;cACxBqC,SAAS,EAAEW,IAAI,CAACX,SAAS;cACzBe,OAAO,EAAEJ,IAAI,CAACI;YAChB,CAAC,CAAC,CAAC;UACL;UACA;QAEF,KAAK,gBAAgB;UACnB,IAAIJ,IAAI,CAACX,SAAS,IAAIW,IAAI,CAACM,EAAE,IAAIN,IAAI,CAACO,OAAO,EAAE;YAC7C,MAAMC,cAAc,GAAG;cACrBF,EAAE,EAAEN,IAAI,CAACM,EAAE;cACX,GAAGN,IAAI,CAACO;YACV,CAAiB;YAEjBxD,KAAK,CAACsD,QAAQ,CAACpD,aAAa,CAAC;cAC3BoC,SAAS,EAAEW,IAAI,CAACX,SAAS;cACzBiB,EAAE,EAAEN,IAAI,CAACM,EAAE;cACXF,OAAO,EAAEI;YACX,CAAC,CAAC,CAAC;UACL;UACA;QAEF,KAAK,aAAa;UAChB,IAAIR,IAAI,CAACS,MAAM,IAAIT,IAAI,CAACU,MAAM,EAAE;YAC9B3D,KAAK,CAACsD,QAAQ,CAACnD,gBAAgB,CAAC;cAC9BuD,MAAM,EAAET,IAAI,CAACS,MAAM;cACnBC,MAAM,EAAEV,IAAI,CAACU;YACf,CAAC,CAAC,CAAC;UACL;UACA;QAEF,KAAK,MAAM;UACT;UACA;QAEF;UACEhC,OAAO,CAACiC,IAAI,CAAC,uBAAuB,EAAEX,IAAI,CAACG,IAAI,CAAC;MACpD;IACF,CAAC,CAAC,OAAOxB,KAAK,EAAE;MACdD,OAAO,CAACC,KAAK,CAAC,mCAAmC,EAAEA,KAAK,CAAC;IAC3D;EACF;EAEQiB,gBAAgBA,CAACO,IAAyB,EAAE;IAClD,IAAI,IAAI,CAAC5C,iBAAiB,IAAI,IAAI,CAACC,oBAAoB,EAAE;MACvDkB,OAAO,CAACC,KAAK,CAAC,mCAAmC,CAAC;MAClD;IACF;IAEA,IAAI,CAACpB,iBAAiB,EAAE;IACxB,MAAMqD,KAAK,GAAGC,IAAI,CAACC,GAAG,CAAC,IAAI,GAAGD,IAAI,CAACE,GAAG,CAAC,CAAC,EAAE,IAAI,CAACxD,iBAAiB,CAAC,EAAE,KAAK,CAAC;IAEzE,IAAI,CAACE,gBAAgB,GAAGuD,UAAU,CAAC,MAAM;MACvCtC,OAAO,CAACQ,GAAG,CAAC,2BAA2BiB,IAAI,KAAK,IAAI,CAAC5C,iBAAiB,IAAI,IAAI,CAACC,oBAAoB,GAAG,CAAC;MACvG,IAAI2C,IAAI,KAAK,MAAM,EAAE;QACnB,IAAI,CAACrC,WAAW,CAAC,CAAC;MACpB,CAAC,MAAM;QACL,IAAI,CAACC,eAAe,CAAC,CAAC;MACxB;IACF,CAAC,EAAE6C,KAAK,CAAC;EACX;EAEQzB,iBAAiBA,CAAA,EAAG;IAC1B,IAAI,CAACzB,YAAY,GAAGuD,WAAW,CAAC,MAAM;MACpC,IAAI,CAACC,IAAI,CAAC;QAAEf,IAAI,EAAE;MAAO,CAAC,CAAC;IAC7B,CAAC,EAAE,KAAK,CAAC;EACX;EAEQR,gBAAgBA,CAAA,EAAG;IACzB,IAAI,IAAI,CAACjC,YAAY,EAAE;MACrByD,aAAa,CAAC,IAAI,CAACzD,YAAY,CAAC;MAChC,IAAI,CAACA,YAAY,GAAG,IAAI;IAC1B;EACF;EAEAwD,IAAIA,CAAClB,IAAsB,EAAE;IAC3B;IACA,IAAIA,IAAI,CAACG,IAAI,KAAK,aAAa,IAAIH,IAAI,CAACG,IAAI,KAAK,gBAAgB,IAAIH,IAAI,CAACG,IAAI,KAAK,cAAc,IAAIH,IAAI,CAACG,IAAI,KAAK,eAAe,EAAE;MAAA,IAAAiB,aAAA;MAClI,IAAI,EAAAA,aAAA,OAAI,CAAC/D,MAAM,cAAA+D,aAAA,uBAAXA,aAAA,CAAa7C,UAAU,MAAKC,SAAS,CAACC,IAAI,EAAE;QAC9C,IAAI,CAACpB,MAAM,CAAC6D,IAAI,CAACjB,IAAI,CAACoB,SAAS,CAACrB,IAAI,CAAC,CAAC;MACxC,CAAC,MAAM;QACLtB,OAAO,CAACiC,IAAI,CAAC,iCAAiC,CAAC;MACjD;IACF;IACA;IAAA,KACK,IAAIX,IAAI,CAACG,IAAI,KAAK,aAAa,EAAE;MAAA,IAAAmB,iBAAA;MACpC,IAAI,EAAAA,iBAAA,OAAI,CAAChE,UAAU,cAAAgE,iBAAA,uBAAfA,iBAAA,CAAiB/C,UAAU,MAAKC,SAAS,CAACC,IAAI,EAAE;QAClD,IAAI,CAACnB,UAAU,CAAC4D,IAAI,CAACjB,IAAI,CAACoB,SAAS,CAACrB,IAAI,CAAC,CAAC;MAC5C,CAAC,MAAM;QACLtB,OAAO,CAACiC,IAAI,CAAC,qCAAqC,CAAC;MACrD;IACF;EACF;EAEArB,WAAWA,CAACD,SAAiB,EAAE;IAC7B,IAAI,CAAC1B,QAAQ,CAAC4D,GAAG,CAAClC,SAAS,CAAC;IAC5B,IAAI,CAAC6B,IAAI,CAAC;MACRf,IAAI,EAAE,cAAc;MACpBd;IACF,CAAC,CAAC;EACJ;EAEAmC,YAAYA,CAACnC,SAAiB,EAAE;IAC9B,IAAI,CAAC1B,QAAQ,CAAC8D,MAAM,CAACpC,SAAS,CAAC;IAC/B,IAAI,CAAC6B,IAAI,CAAC;MACRf,IAAI,EAAE,eAAe;MACrBd;IACF,CAAC,CAAC;EACJ;EAEAqC,UAAUA,CAAA,EAAG;IACX,IAAI,CAAC/D,QAAQ,CAACgE,KAAK,CAAC,CAAC;IACrB,IAAI,IAAI,CAACtE,MAAM,EAAE;MACf,IAAI,CAACA,MAAM,CAACuE,KAAK,CAAC,CAAC;MACnB,IAAI,CAACvE,MAAM,GAAG,IAAI;IACpB;IACA,IAAI,IAAI,CAACC,UAAU,EAAE;MACnB,IAAI,CAACA,UAAU,CAACsE,KAAK,CAAC,CAAC;MACvB,IAAI,CAACtE,UAAU,GAAG,IAAI;IACxB;IACA,IAAI,IAAI,CAACG,gBAAgB,EAAE;MACzBoE,YAAY,CAAC,IAAI,CAACpE,gBAAgB,CAAC;MACnC,IAAI,CAACA,gBAAgB,GAAG,IAAI;IAC9B;IACA,IAAI,CAACkC,gBAAgB,CAAC,CAAC;EACzB;AACF;AAEA,eAAe,IAAIxC,gBAAgB,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}