{"ast":null,"code":"import { store } from '../../store';\nimport { addMessage, setReplies } from '../../store/messages/messagesSlice';\nclass WebSocketService {\n  constructor() {\n    this.socket = null;\n    this.messageHandlers = [];\n    this.errorHandlers = [];\n    this.currentChannelId = null;\n    this.joinedChannels = new Set();\n    this.messageQueue = [];\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectTimeout = null;\n    this.isReconnecting = false;\n    this.connectionPromise = null;\n    this.handleMessage = event => {\n      try {\n        const data = JSON.parse(event.data);\n        console.log('Received WebSocket message:', data);\n        if (data.type === 'message' || data.type === 'new_reply' || data.type === 'message_sent') {\n          if (!this.processedMessageIds.has(data.message.id.toString())) {\n            this.processedMessageIds.add(data.message.id.toString());\n            const transformedMessage = {\n              id: data.message.id.toString(),\n              content: data.message.content,\n              channelId: data.message.channel_id.toString(),\n              userId: data.message.sender_id.toString(),\n              createdAt: data.message.created_at,\n              updatedAt: data.message.created_at,\n              reactions: [],\n              attachments: [],\n              replyCount: typeof data.message.reply_count === 'number' ? data.message.reply_count : 0,\n              isExpanded: false,\n              ...(data.type === 'new_reply' && data.parentId ? {\n                parentId: data.parentId.toString()\n              } : {})\n            };\n            if (data.type === 'new_reply' && data.parentId) {\n              // For replies, update the parent message's replies array and replyCount\n              store.dispatch(setReplies({\n                channelId: transformedMessage.channelId,\n                messageId: data.parentId.toString(),\n                replies: [transformedMessage]\n              }));\n            } else {\n              // Only dispatch addMessage for non-reply messages\n              store.dispatch(addMessage(transformedMessage));\n            }\n\n            // Notify all message handlers\n            this.messageHandlers.forEach(handler => {\n              try {\n                handler(data);\n              } catch (error) {\n                console.error('Error in message handler:', error);\n              }\n            });\n          }\n        } else {\n          // For other message types, just notify handlers\n          this.messageHandlers.forEach(handler => {\n            try {\n              handler(data);\n            } catch (error) {\n              console.error('Error in message handler:', error);\n            }\n          });\n        }\n      } catch (error) {\n        console.error('Error handling WebSocket message:', error);\n        this.handleError(error);\n      }\n    };\n  }\n  async connect(channelId) {\n    if (this.isReconnecting) {\n      console.log('Already attempting to reconnect...');\n      return;\n    }\n    if (this.connectionPromise) {\n      await this.connectionPromise;\n      if (this.isConnected() && this.isConnectedToChannel(channelId)) {\n        return;\n      }\n    }\n    this.currentChannelId = channelId;\n    try {\n      this.connectionPromise = new Promise((resolve, reject) => {\n        const token = localStorage.getItem('token');\n        if (!token) {\n          reject(new Error('No authentication token found'));\n          return;\n        }\n        console.log(`Connecting to WebSocket: ws://localhost:8000/ws/chat?token=${token}`);\n        this.socket = new WebSocket(`ws://localhost:8000/ws/chat?token=${token}`);\n        this.socket.onopen = async () => {\n          console.log('WebSocket connection opened');\n          this.reconnectAttempts = 0;\n          this.isReconnecting = false;\n          try {\n            await this.joinChannel(channelId);\n            resolve();\n          } catch (error) {\n            console.error('Failed to join channel:', error);\n            reject(error);\n          }\n        };\n        this.socket.onclose = event => {\n          console.log(`WebSocket disconnected with code: ${event.code}`);\n          this.socket = null;\n          this.joinedChannels.clear();\n          if (event.code !== 1000) {\n            this.attemptReconnect();\n          }\n        };\n        this.socket.onerror = error => {\n          console.error('WebSocket error:', error);\n          this.handleError(new Error('WebSocket connection error'));\n        };\n        this.socket.onmessage = event => {\n          try {\n            const message = JSON.parse(event.data);\n            this.messageHandlers.forEach(handler => handler(message));\n          } catch (error) {\n            console.error('Error parsing WebSocket message:', error);\n          }\n        };\n      });\n      await this.connectionPromise;\n    } catch (error) {\n      console.error('WebSocket connection failed:', error);\n      this.handleError(error);\n      throw error;\n    } finally {\n      this.connectionPromise = null;\n    }\n  }\n  async joinChannel(channelId) {\n    if (!this.isConnected()) {\n      throw new Error('WebSocket is not connected');\n    }\n    if (this.isConnectedToChannel(channelId)) {\n      return;\n    }\n    return new Promise((resolve, reject) => {\n      var _this$socket3, _this$socket4;\n      const joinMessage = {\n        type: 'join_channel',\n        channel_id: channelId\n      };\n      const timeoutId = setTimeout(() => {\n        reject(new Error('Channel join timeout'));\n      }, 5000);\n      const handleJoinResponse = message => {\n        if (message.type === 'channel_joined' && message.channelId === channelId) {\n          var _this$socket;\n          clearTimeout(timeoutId);\n          this.joinedChannels.add(channelId);\n          (_this$socket = this.socket) === null || _this$socket === void 0 ? void 0 : _this$socket.removeEventListener('message', handleJoinResponse);\n          resolve();\n        } else if (message.type === 'channel_join_error') {\n          var _this$socket2;\n          clearTimeout(timeoutId);\n          (_this$socket2 = this.socket) === null || _this$socket2 === void 0 ? void 0 : _this$socket2.removeEventListener('message', handleJoinResponse);\n          reject(new Error(message.error || 'Failed to join channel'));\n        }\n      };\n      (_this$socket3 = this.socket) === null || _this$socket3 === void 0 ? void 0 : _this$socket3.addEventListener('message', handleJoinResponse);\n      (_this$socket4 = this.socket) === null || _this$socket4 === void 0 ? void 0 : _this$socket4.send(JSON.stringify(joinMessage));\n    });\n  }\n  attemptReconnect() {\n    if (this.isReconnecting || this.reconnectAttempts >= this.maxReconnectAttempts) {\n      return;\n    }\n    this.isReconnecting = true;\n    this.reconnectAttempts++;\n    console.log(`Attempting to reconnect (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})...`);\n    if (this.currentChannelId) {\n      const backoffTime = Math.min(1000 * Math.pow(2, this.reconnectAttempts - 1), 10000);\n      this.reconnectTimeout = setTimeout(() => {\n        this.connect(this.currentChannelId).catch(error => {\n          console.error('Reconnection failed:', error);\n          if (this.reconnectAttempts < this.maxReconnectAttempts) {\n            this.attemptReconnect();\n          } else {\n            this.isReconnecting = false;\n            this.handleError(new Error('Max reconnection attempts reached'));\n          }\n        });\n      }, backoffTime);\n    }\n  }\n  handleError(error) {\n    console.error('WebSocket error:', error);\n    const errorObj = {\n      code: error instanceof Error ? error.name : 'UNKNOWN_ERROR',\n      message: error instanceof Error ? error.message : String(error)\n    };\n    this.errorHandlers.forEach(handler => {\n      try {\n        handler(errorObj);\n      } catch (handlerError) {\n        console.error('Error in error handler:', handlerError);\n      }\n    });\n  }\n  disconnect() {\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n    if (this.socket) {\n      // Leave all joined channels\n      Array.from(this.joinedChannels).forEach(channelId => {\n        try {\n          var _this$socket5;\n          const message = {\n            type: 'leave_channel',\n            channel_id: channelId\n          };\n          (_this$socket5 = this.socket) === null || _this$socket5 === void 0 ? void 0 : _this$socket5.send(JSON.stringify(message));\n        } catch (error) {\n          console.error(`Error leaving channel ${channelId}:`, error);\n        }\n      });\n      this.socket.close(1000); // Normal closure\n      this.socket = null;\n      this.currentChannelId = null;\n      this.joinedChannels.clear();\n      this.reconnectAttempts = 0;\n      this.isReconnecting = false;\n    }\n  }\n  async processMessageQueue() {\n    while (this.messageQueue.length > 0 && ((_this$socket6 = this.socket) === null || _this$socket6 === void 0 ? void 0 : _this$socket6.readyState) === WebSocket.OPEN) {\n      var _this$socket6;\n      const message = this.messageQueue.shift();\n      if (message) {\n        try {\n          await this.sendMessageImmediate(message.channelId, message.content);\n        } catch (error) {\n          console.error('Failed to send queued message:', error);\n        }\n      }\n    }\n  }\n  sendMessageImmediate(channelId, content) {\n    var _this$socket7;\n    if (((_this$socket7 = this.socket) === null || _this$socket7 === void 0 ? void 0 : _this$socket7.readyState) !== WebSocket.OPEN) {\n      throw new Error('WebSocket is not connected');\n    }\n    const message = {\n      type: 'message',\n      channel_id: channelId,\n      content: content\n    };\n    this.socket.send(JSON.stringify(message));\n  }\n  async sendMessage(channelId, content) {\n    var _this$socket8;\n    // If not connected to the right channel, connect first\n    if (this.currentChannelId !== channelId) {\n      console.log('Connecting to channel before sending message');\n      try {\n        await this.connect(channelId);\n      } catch (error) {\n        console.error('Failed to connect to channel:', error);\n        this.handleError('Failed to send message: Could not connect to channel');\n        return;\n      }\n    }\n    if (((_this$socket8 = this.socket) === null || _this$socket8 === void 0 ? void 0 : _this$socket8.readyState) === WebSocket.OPEN) {\n      try {\n        await this.sendMessageImmediate(channelId, content);\n      } catch (error) {\n        console.error('Failed to send message:', error);\n        // Queue the message for retry\n        this.messageQueue.push({\n          channelId,\n          content\n        });\n        this.handleError('Message will be sent when connection is restored');\n      }\n    } else {\n      // Queue the message for later\n      this.messageQueue.push({\n        channelId,\n        content\n      });\n      this.handleError('Message will be sent when connection is restored');\n    }\n  }\n  leaveChannel(channelId) {\n    var _this$socket9;\n    if (((_this$socket9 = this.socket) === null || _this$socket9 === void 0 ? void 0 : _this$socket9.readyState) === WebSocket.OPEN && this.joinedChannels.has(channelId)) {\n      const message = {\n        type: 'leave_channel',\n        channel_id: channelId\n      };\n      this.socket.send(JSON.stringify(message));\n      this.joinedChannels.delete(channelId);\n\n      // If this was the current channel, set current to null\n      if (this.currentChannelId === channelId) {\n        this.currentChannelId = null;\n      }\n    }\n  }\n  isChannelJoined(channelId) {\n    return this.joinedChannels.has(channelId);\n  }\n  onMessage(handler) {\n    this.messageHandlers.push(handler);\n    return () => {\n      this.messageHandlers = this.messageHandlers.filter(h => h !== handler);\n    };\n  }\n  onError(handler) {\n    this.errorHandlers.push(handler);\n    return () => {\n      this.errorHandlers = this.errorHandlers.filter(h => h !== handler);\n    };\n  }\n  getChatSocketState() {\n    var _this$socket10;\n    return ((_this$socket10 = this.socket) === null || _this$socket10 === void 0 ? void 0 : _this$socket10.readyState) || WebSocket.CLOSED;\n  }\n  getCurrentChannelId() {\n    return this.currentChannelId;\n  }\n  // Helper method to check if connected to a channel\n  isConnectedToChannel(channelId) {\n    var _this$socket11;\n    return ((_this$socket11 = this.socket) === null || _this$socket11 === void 0 ? void 0 : _this$socket11.readyState) === WebSocket.OPEN && this.joinedChannels.has(channelId);\n  }\n\n  // Helper method to ensure connection is ready\n  ensureConnected() {\n    if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {\n      throw new Error('WebSocket is not connected');\n    }\n  }\n\n  // Add method to join multiple channels\n  async joinChannels(channelIds) {\n    if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {\n      const primaryChannel = channelIds[0];\n      await this.connect(primaryChannel);\n    }\n    for (const channelId of channelIds) {\n      if (!this.joinedChannels.has(channelId)) {\n        try {\n          await this.joinChannel(channelId);\n        } catch (error) {\n          console.error(`Failed to join channel ${channelId}:`, error);\n        }\n      }\n    }\n  }\n\n  // Add isConnected method\n  isConnected() {\n    return this.socket !== null && this.socket.readyState === WebSocket.OPEN;\n  }\n}\nconst wsService = new WebSocketService();\nexport default wsService;","map":{"version":3,"names":["store","addMessage","setReplies","WebSocketService","constructor","socket","messageHandlers","errorHandlers","currentChannelId","joinedChannels","Set","messageQueue","reconnectAttempts","maxReconnectAttempts","reconnectTimeout","isReconnecting","connectionPromise","handleMessage","event","data","JSON","parse","console","log","type","processedMessageIds","has","message","id","toString","add","transformedMessage","content","channelId","channel_id","userId","sender_id","createdAt","created_at","updatedAt","reactions","attachments","replyCount","reply_count","isExpanded","parentId","dispatch","messageId","replies","forEach","handler","error","handleError","connect","isConnected","isConnectedToChannel","Promise","resolve","reject","token","localStorage","getItem","Error","WebSocket","onopen","joinChannel","onclose","code","clear","attemptReconnect","onerror","onmessage","_this$socket3","_this$socket4","joinMessage","timeoutId","setTimeout","handleJoinResponse","_this$socket","clearTimeout","removeEventListener","_this$socket2","addEventListener","send","stringify","backoffTime","Math","min","pow","catch","errorObj","name","String","handlerError","disconnect","Array","from","_this$socket5","close","processMessageQueue","length","_this$socket6","readyState","OPEN","shift","sendMessageImmediate","_this$socket7","sendMessage","_this$socket8","push","leaveChannel","_this$socket9","delete","isChannelJoined","onMessage","filter","h","onError","getChatSocketState","_this$socket10","CLOSED","getCurrentChannelId","_this$socket11","ensureConnected","joinChannels","channelIds","primaryChannel","wsService"],"sources":["Z:/GAUNTLET/projects/SERMO/sermo-app/frontend/src/services/websocket/index.ts"],"sourcesContent":["import { WebSocketMessage, WebSocketChannelJoinMessage, WebSocketChannelMessage, StoreMessage } from '../../types';\r\nimport { getAuthToken } from '../api/auth';\r\nimport { store } from '../../store';\r\nimport { addMessage, setReplies } from '../../store/messages/messagesSlice';\r\n\r\nclass WebSocketService {\r\n  private socket: WebSocket | null = null;\r\n  private messageHandlers: ((message: WebSocketMessage) => void)[] = [];\r\n  private errorHandlers: ((error: Error) => void)[] = [];\r\n  private currentChannelId: string | null = null;\r\n  private joinedChannels: Set<string> = new Set();\r\n  private messageQueue: WebSocketMessage[] = [];\r\n  private reconnectAttempts = 0;\r\n  private maxReconnectAttempts = 5;\r\n  private reconnectTimeout: NodeJS.Timeout | null = null;\r\n  private isReconnecting = false;\r\n  private connectionPromise: Promise<void> | null = null;\r\n\r\n  public async connect(channelId: string): Promise<void> {\r\n    if (this.isReconnecting) {\r\n      console.log('Already attempting to reconnect...');\r\n      return;\r\n    }\r\n\r\n    if (this.connectionPromise) {\r\n      await this.connectionPromise;\r\n      if (this.isConnected() && this.isConnectedToChannel(channelId)) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    this.currentChannelId = channelId;\r\n    \r\n    try {\r\n      this.connectionPromise = new Promise((resolve, reject) => {\r\n        const token = localStorage.getItem('token');\r\n        if (!token) {\r\n          reject(new Error('No authentication token found'));\r\n          return;\r\n        }\r\n\r\n        console.log(`Connecting to WebSocket: ws://localhost:8000/ws/chat?token=${token}`);\r\n        this.socket = new WebSocket(`ws://localhost:8000/ws/chat?token=${token}`);\r\n\r\n        this.socket.onopen = async () => {\r\n          console.log('WebSocket connection opened');\r\n          this.reconnectAttempts = 0;\r\n          this.isReconnecting = false;\r\n\r\n          try {\r\n            await this.joinChannel(channelId);\r\n            resolve();\r\n          } catch (error) {\r\n            console.error('Failed to join channel:', error);\r\n            reject(error);\r\n          }\r\n        };\r\n\r\n        this.socket.onclose = (event) => {\r\n          console.log(`WebSocket disconnected with code: ${event.code}`);\r\n          this.socket = null;\r\n          this.joinedChannels.clear();\r\n\r\n          if (event.code !== 1000) {\r\n            this.attemptReconnect();\r\n          }\r\n        };\r\n\r\n        this.socket.onerror = (error) => {\r\n          console.error('WebSocket error:', error);\r\n          this.handleError(new Error('WebSocket connection error'));\r\n        };\r\n\r\n        this.socket.onmessage = (event) => {\r\n          try {\r\n            const message = JSON.parse(event.data);\r\n            this.messageHandlers.forEach(handler => handler(message));\r\n          } catch (error) {\r\n            console.error('Error parsing WebSocket message:', error);\r\n          }\r\n        };\r\n      });\r\n\r\n      await this.connectionPromise;\r\n    } catch (error) {\r\n      console.error('WebSocket connection failed:', error);\r\n      this.handleError(error as Error);\r\n      throw error;\r\n    } finally {\r\n      this.connectionPromise = null;\r\n    }\r\n  }\r\n\r\n  private async joinChannel(channelId: string): Promise<void> {\r\n    if (!this.isConnected()) {\r\n      throw new Error('WebSocket is not connected');\r\n    }\r\n\r\n    if (this.isConnectedToChannel(channelId)) {\r\n      return;\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const joinMessage = {\r\n        type: 'join_channel',\r\n        channel_id: channelId\r\n      };\r\n\r\n      const timeoutId = setTimeout(() => {\r\n        reject(new Error('Channel join timeout'));\r\n      }, 5000);\r\n\r\n      const handleJoinResponse = (message: WebSocketMessage) => {\r\n        if (message.type === 'channel_joined' && message.channelId === channelId) {\r\n          clearTimeout(timeoutId);\r\n          this.joinedChannels.add(channelId);\r\n          this.socket?.removeEventListener('message', handleJoinResponse);\r\n          resolve();\r\n        } else if (message.type === 'channel_join_error') {\r\n          clearTimeout(timeoutId);\r\n          this.socket?.removeEventListener('message', handleJoinResponse);\r\n          reject(new Error(message.error || 'Failed to join channel'));\r\n        }\r\n      };\r\n\r\n      this.socket?.addEventListener('message', handleJoinResponse);\r\n      this.socket?.send(JSON.stringify(joinMessage));\r\n    });\r\n  }\r\n\r\n  private attemptReconnect(): void {\r\n    if (this.isReconnecting || this.reconnectAttempts >= this.maxReconnectAttempts) {\r\n      return;\r\n    }\r\n\r\n    this.isReconnecting = true;\r\n    this.reconnectAttempts++;\r\n\r\n    console.log(`Attempting to reconnect (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})...`);\r\n\r\n    if (this.currentChannelId) {\r\n      const backoffTime = Math.min(1000 * Math.pow(2, this.reconnectAttempts - 1), 10000);\r\n      this.reconnectTimeout = setTimeout(() => {\r\n        this.connect(this.currentChannelId!).catch(error => {\r\n          console.error('Reconnection failed:', error);\r\n          if (this.reconnectAttempts < this.maxReconnectAttempts) {\r\n            this.attemptReconnect();\r\n          } else {\r\n            this.isReconnecting = false;\r\n            this.handleError(new Error('Max reconnection attempts reached'));\r\n          }\r\n        });\r\n      }, backoffTime);\r\n    }\r\n  }\r\n\r\n  private handleError(error: unknown): void {\r\n    console.error('WebSocket error:', error);\r\n    const errorObj = {\r\n      code: error instanceof Error ? error.name : 'UNKNOWN_ERROR',\r\n      message: error instanceof Error ? error.message : String(error)\r\n    };\r\n    this.errorHandlers.forEach(handler => {\r\n      try {\r\n        handler(errorObj);\r\n      } catch (handlerError) {\r\n        console.error('Error in error handler:', handlerError);\r\n      }\r\n    });\r\n  }\r\n\r\n  disconnect() {\r\n    if (this.reconnectTimeout) {\r\n      clearTimeout(this.reconnectTimeout);\r\n      this.reconnectTimeout = null;\r\n    }\r\n    \r\n    if (this.socket) {\r\n      // Leave all joined channels\r\n      Array.from(this.joinedChannels).forEach(channelId => {\r\n        try {\r\n          const message = {\r\n            type: 'leave_channel',\r\n            channel_id: channelId\r\n          };\r\n          this.socket?.send(JSON.stringify(message));\r\n        } catch (error) {\r\n          console.error(`Error leaving channel ${channelId}:`, error);\r\n        }\r\n      });\r\n      \r\n      this.socket.close(1000); // Normal closure\r\n      this.socket = null;\r\n      this.currentChannelId = null;\r\n      this.joinedChannels.clear();\r\n      this.reconnectAttempts = 0;\r\n      this.isReconnecting = false;\r\n    }\r\n  }\r\n\r\n  private async processMessageQueue() {\r\n    while (this.messageQueue.length > 0 && this.socket?.readyState === WebSocket.OPEN) {\r\n      const message = this.messageQueue.shift();\r\n      if (message) {\r\n        try {\r\n          await this.sendMessageImmediate(message.channelId, message.content);\r\n        } catch (error) {\r\n          console.error('Failed to send queued message:', error);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private sendMessageImmediate(channelId: string, content: string) {\r\n    if (this.socket?.readyState !== WebSocket.OPEN) {\r\n      throw new Error('WebSocket is not connected');\r\n    }\r\n\r\n    const message = {\r\n      type: 'message',\r\n      channel_id: channelId,\r\n      content: content\r\n    };\r\n    this.socket.send(JSON.stringify(message));\r\n  }\r\n\r\n  async sendMessage(channelId: string, content: string) {\r\n    // If not connected to the right channel, connect first\r\n    if (this.currentChannelId !== channelId) {\r\n      console.log('Connecting to channel before sending message');\r\n      try {\r\n        await this.connect(channelId);\r\n      } catch (error) {\r\n        console.error('Failed to connect to channel:', error);\r\n        this.handleError('Failed to send message: Could not connect to channel');\r\n        return;\r\n      }\r\n    }\r\n\r\n    if (this.socket?.readyState === WebSocket.OPEN) {\r\n      try {\r\n        await this.sendMessageImmediate(channelId, content);\r\n      } catch (error) {\r\n        console.error('Failed to send message:', error);\r\n        // Queue the message for retry\r\n        this.messageQueue.push({ channelId, content });\r\n        this.handleError('Message will be sent when connection is restored');\r\n      }\r\n    } else {\r\n      // Queue the message for later\r\n      this.messageQueue.push({ channelId, content });\r\n      this.handleError('Message will be sent when connection is restored');\r\n    }\r\n  }\r\n\r\n  leaveChannel(channelId: string) {\r\n    if (this.socket?.readyState === WebSocket.OPEN && this.joinedChannels.has(channelId)) {\r\n      const message = {\r\n        type: 'leave_channel',\r\n        channel_id: channelId\r\n      };\r\n      this.socket.send(JSON.stringify(message));\r\n      this.joinedChannels.delete(channelId);\r\n      \r\n      // If this was the current channel, set current to null\r\n      if (this.currentChannelId === channelId) {\r\n        this.currentChannelId = null;\r\n      }\r\n    }\r\n  }\r\n\r\n  isChannelJoined(channelId: string): boolean {\r\n    return this.joinedChannels.has(channelId);\r\n  }\r\n\r\n  onMessage(handler: (message: WebSocketMessage) => void) {\r\n    this.messageHandlers.push(handler);\r\n    return () => {\r\n      this.messageHandlers = this.messageHandlers.filter(h => h !== handler);\r\n    };\r\n  }\r\n\r\n  onError(handler: (error: Error) => void) {\r\n    this.errorHandlers.push(handler);\r\n    return () => {\r\n      this.errorHandlers = this.errorHandlers.filter(h => h !== handler);\r\n    };\r\n  }\r\n\r\n  getChatSocketState() {\r\n    return this.socket?.readyState || WebSocket.CLOSED;\r\n  }\r\n\r\n  getCurrentChannelId() {\r\n    return this.currentChannelId;\r\n  }\r\n\r\n  private handleMessage = (event: MessageEvent) => {\r\n    try {\r\n      const data = JSON.parse(event.data) as WebSocketMessage;\r\n      console.log('Received WebSocket message:', data);\r\n\r\n      if (data.type === 'message' || data.type === 'new_reply' || data.type === 'message_sent') {\r\n        if (!this.processedMessageIds.has(data.message.id.toString())) {\r\n          this.processedMessageIds.add(data.message.id.toString());\r\n          const transformedMessage: StoreMessage = {\r\n            id: data.message.id.toString(),\r\n            content: data.message.content,\r\n            channelId: data.message.channel_id.toString(),\r\n            userId: data.message.sender_id.toString(),\r\n            createdAt: data.message.created_at,\r\n            updatedAt: data.message.created_at,\r\n            reactions: [],\r\n            attachments: [],\r\n            replyCount: typeof data.message.reply_count === 'number' ? data.message.reply_count : 0,\r\n            isExpanded: false,\r\n            ...(data.type === 'new_reply' && data.parentId ? { parentId: data.parentId.toString() } : {})\r\n          };\r\n\r\n          if (data.type === 'new_reply' && data.parentId) {\r\n            // For replies, update the parent message's replies array and replyCount\r\n            store.dispatch(setReplies({\r\n              channelId: transformedMessage.channelId,\r\n              messageId: data.parentId.toString(),\r\n              replies: [transformedMessage]\r\n            }));\r\n          } else {\r\n            // Only dispatch addMessage for non-reply messages\r\n            store.dispatch(addMessage(transformedMessage));\r\n          }\r\n\r\n          // Notify all message handlers\r\n          this.messageHandlers.forEach(handler => {\r\n            try {\r\n              handler(data);\r\n            } catch (error) {\r\n              console.error('Error in message handler:', error);\r\n            }\r\n          });\r\n        }\r\n      } else {\r\n        // For other message types, just notify handlers\r\n        this.messageHandlers.forEach(handler => {\r\n          try {\r\n            handler(data);\r\n          } catch (error) {\r\n            console.error('Error in message handler:', error);\r\n          }\r\n        });\r\n      }\r\n    } catch (error) {\r\n      console.error('Error handling WebSocket message:', error);\r\n      this.handleError(error);\r\n    }\r\n  };\r\n\r\n  // Helper method to check if connected to a channel\r\n  private isConnectedToChannel(channelId: string): boolean {\r\n    return (\r\n      this.socket?.readyState === WebSocket.OPEN &&\r\n      this.joinedChannels.has(channelId)\r\n    );\r\n  }\r\n\r\n  // Helper method to ensure connection is ready\r\n  private ensureConnected(): void {\r\n    if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {\r\n      throw new Error('WebSocket is not connected');\r\n    }\r\n  }\r\n\r\n  // Add method to join multiple channels\r\n  async joinChannels(channelIds: string[]): Promise<void> {\r\n    if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {\r\n      const primaryChannel = channelIds[0];\r\n      await this.connect(primaryChannel);\r\n    }\r\n\r\n    for (const channelId of channelIds) {\r\n      if (!this.joinedChannels.has(channelId)) {\r\n        try {\r\n          await this.joinChannel(channelId);\r\n        } catch (error) {\r\n          console.error(`Failed to join channel ${channelId}:`, error);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Add isConnected method\r\n  public isConnected(): boolean {\r\n    return this.socket !== null && this.socket.readyState === WebSocket.OPEN;\r\n  }\r\n}\r\n\r\nconst wsService = new WebSocketService();\r\nexport default wsService; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}