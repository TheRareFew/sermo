{"ast":null,"code":"import { createSlice } from '@reduxjs/toolkit';\nconst initialState = {\n  messagesByChannel: {},\n  loading: false,\n  error: null\n};\nconst messagesSlice = createSlice({\n  name: 'messages',\n  initialState,\n  reducers: {\n    setMessages: (state, action) => {\n      const {\n        channelId,\n        messages\n      } = action.payload;\n      state.messagesByChannel[channelId] = messages;\n    },\n    addMessage: (state, action) => {\n      const {\n        channelId,\n        message\n      } = action.payload;\n      if (!state.messagesByChannel[channelId]) {\n        state.messagesByChannel[channelId] = [];\n      }\n      state.messagesByChannel[channelId].push(message);\n    },\n    updateMessage: (state, action) => {\n      const {\n        channelId,\n        message\n      } = action.payload;\n      if (!state.messagesByChannel[channelId]) return;\n      const index = state.messagesByChannel[channelId].findIndex(m => m.id === message.id);\n      if (index !== -1) {\n        state.messagesByChannel[channelId][index] = message;\n      }\n    },\n    deleteMessage: (state, action) => {\n      const {\n        channelId,\n        messageId\n      } = action.payload;\n      if (!state.messagesByChannel[channelId]) return;\n\n      // Delete main message\n      state.messagesByChannel[channelId] = state.messagesByChannel[channelId].filter(m => m.id !== messageId);\n\n      // Delete reply and update reply count\n      state.messagesByChannel[channelId].forEach(mainMessage => {\n        if (mainMessage.replies) {\n          const originalLength = mainMessage.replies.length;\n          mainMessage.replies = mainMessage.replies.filter(r => r.id !== messageId);\n          if (mainMessage.replies.length !== originalLength) {\n            mainMessage.replyCount = mainMessage.replies.length;\n          }\n        }\n      });\n    },\n    setReplies: (state, action) => {\n      const {\n        channelId,\n        parentMessageId,\n        replies\n      } = action.payload;\n      if (!state.messagesByChannel[channelId]) return;\n      const parentMessage = state.messagesByChannel[channelId].find(m => m.id === parentMessageId);\n      if (parentMessage) {\n        if (!parentMessage.replies) {\n          parentMessage.replies = [];\n        }\n        // Append new replies while preserving existing ones\n        const newReplies = replies.filter(reply => {\n          var _parentMessage$replie;\n          return !((_parentMessage$replie = parentMessage.replies) !== null && _parentMessage$replie !== void 0 && _parentMessage$replie.some(existing => existing.id === reply.id));\n        });\n        parentMessage.replies = [...parentMessage.replies, ...newReplies];\n        parentMessage.replyCount = parentMessage.replies.length;\n        parentMessage.repliesLoaded = true;\n      }\n    },\n    toggleExpanded: (state, action) => {\n      const {\n        channelId,\n        messageId\n      } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const message = messages.find(msg => msg.id === messageId);\n        if (message) {\n          message.isExpanded = !message.isExpanded;\n        }\n      }\n    },\n    setExpanded: (state, action) => {\n      const {\n        channelId,\n        messageId,\n        expanded\n      } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const message = messages.find(msg => msg.id === messageId);\n        if (message) {\n          message.isExpanded = expanded;\n        }\n      }\n    },\n    addReply: (state, action) => {\n      const {\n        channelId,\n        parentMessageId,\n        reply\n      } = action.payload;\n      const channelMessages = state.messagesByChannel[channelId];\n      if (channelMessages) {\n        const parentMessage = channelMessages.find(msg => msg.id === parentMessageId);\n        if (parentMessage) {\n          if (!parentMessage.replies) {\n            parentMessage.replies = [];\n          }\n          parentMessage.replies.push(reply);\n          parentMessage.replyCount = (parentMessage.replyCount || 0) + 1;\n        }\n      }\n    }\n  }\n});\nexport const {\n  setMessages,\n  addMessage,\n  updateMessage,\n  deleteMessage,\n  setReplies,\n  toggleExpanded,\n  setExpanded,\n  addReply\n} = messagesSlice.actions;\nexport default messagesSlice.reducer;","map":{"version":3,"names":["createSlice","initialState","messagesByChannel","loading","error","messagesSlice","name","reducers","setMessages","state","action","channelId","messages","payload","addMessage","message","push","updateMessage","index","findIndex","m","id","deleteMessage","messageId","filter","forEach","mainMessage","replies","originalLength","length","r","replyCount","setReplies","parentMessageId","parentMessage","find","newReplies","reply","_parentMessage$replie","some","existing","repliesLoaded","toggleExpanded","msg","isExpanded","setExpanded","expanded","addReply","channelMessages","actions","reducer"],"sources":["Z:/GAUNTLET/projects/SERMO/sermo-app/frontend/src/store/messages/messagesSlice.ts"],"sourcesContent":["import { createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { MessagesState, Reaction, StoreMessage } from '../../types';\n\nconst initialState: MessagesState = {\n  messagesByChannel: {},\n  loading: false,\n  error: null,\n};\n\nconst messagesSlice = createSlice({\n  name: 'messages',\n  initialState,\n  reducers: {\n    setMessages: (state, action: PayloadAction<{ channelId: number; messages: StoreMessage[] }>) => {\n      const { channelId, messages } = action.payload;\n      state.messagesByChannel[channelId] = messages;\n    },\n    addMessage: (state, action: PayloadAction<{ channelId: number; message: StoreMessage }>) => {\n      const { channelId, message } = action.payload;\n      if (!state.messagesByChannel[channelId]) {\n        state.messagesByChannel[channelId] = [];\n      }\n      state.messagesByChannel[channelId].push(message);\n    },\n    updateMessage: (state, action: PayloadAction<{ channelId: number; message: StoreMessage }>) => {\n      const { channelId, message } = action.payload;\n      if (!state.messagesByChannel[channelId]) return;\n\n      const index = state.messagesByChannel[channelId].findIndex(m => m.id === message.id);\n      if (index !== -1) {\n        state.messagesByChannel[channelId][index] = message;\n      }\n    },\n    deleteMessage: (state, action: PayloadAction<{ channelId: number; messageId: number }>) => {\n      const { channelId, messageId } = action.payload;\n      if (!state.messagesByChannel[channelId]) return;\n\n      // Delete main message\n      state.messagesByChannel[channelId] = state.messagesByChannel[channelId].filter(m => m.id !== messageId);\n\n      // Delete reply and update reply count\n      state.messagesByChannel[channelId].forEach(mainMessage => {\n        if (mainMessage.replies) {\n          const originalLength = mainMessage.replies.length;\n          mainMessage.replies = mainMessage.replies.filter(r => r.id !== messageId);\n          if (mainMessage.replies.length !== originalLength) {\n            mainMessage.replyCount = mainMessage.replies.length;\n          }\n        }\n      });\n    },\n    setReplies: (state, action: PayloadAction<{ channelId: number; parentMessageId: number; replies: StoreMessage[] }>) => {\n      const { channelId, parentMessageId, replies } = action.payload;\n      \n      if (!state.messagesByChannel[channelId]) return;\n\n      const parentMessage = state.messagesByChannel[channelId].find(m => m.id === parentMessageId);\n      if (parentMessage) {\n        if (!parentMessage.replies) {\n          parentMessage.replies = [];\n        }\n        // Append new replies while preserving existing ones\n        const newReplies = replies.filter(reply => \n          !parentMessage.replies?.some(existing => existing.id === reply.id)\n        );\n        parentMessage.replies = [...parentMessage.replies, ...newReplies];\n        parentMessage.replyCount = parentMessage.replies.length;\n        parentMessage.repliesLoaded = true;\n      }\n    },\n    toggleExpanded: (state, action: PayloadAction<{ channelId: number; messageId: number }>) => {\n      const { channelId, messageId } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const message = messages.find((msg: StoreMessage) => msg.id === messageId);\n        if (message) {\n          message.isExpanded = !message.isExpanded;\n        }\n      }\n    },\n    setExpanded: (state, action: PayloadAction<{ channelId: number; messageId: number; expanded: boolean }>) => {\n      const { channelId, messageId, expanded } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const message = messages.find((msg: StoreMessage) => msg.id === messageId);\n        if (message) {\n          message.isExpanded = expanded;\n        }\n      }\n    },\n    addReply: (state, action: PayloadAction<{ channelId: number; parentMessageId: number; reply: StoreMessage }>) => {\n      const { channelId, parentMessageId, reply } = action.payload;\n      const channelMessages = state.messagesByChannel[channelId];\n      if (channelMessages) {\n        const parentMessage = channelMessages.find(msg => msg.id === parentMessageId);\n        if (parentMessage) {\n          if (!parentMessage.replies) {\n            parentMessage.replies = [];\n          }\n          parentMessage.replies.push(reply);\n          parentMessage.replyCount = (parentMessage.replyCount || 0) + 1;\n        }\n      }\n    },\n  },\n});\n\nexport const {\n  setMessages,\n  addMessage,\n  updateMessage,\n  deleteMessage,\n  setReplies,\n  toggleExpanded,\n  setExpanded,\n  addReply\n} = messagesSlice.actions;\n\nexport default messagesSlice.reducer; "],"mappings":"AAAA,SAASA,WAAW,QAAuB,kBAAkB;AAG7D,MAAMC,YAA2B,GAAG;EAClCC,iBAAiB,EAAE,CAAC,CAAC;EACrBC,OAAO,EAAE,KAAK;EACdC,KAAK,EAAE;AACT,CAAC;AAED,MAAMC,aAAa,GAAGL,WAAW,CAAC;EAChCM,IAAI,EAAE,UAAU;EAChBL,YAAY;EACZM,QAAQ,EAAE;IACRC,WAAW,EAAEA,CAACC,KAAK,EAAEC,MAAsE,KAAK;MAC9F,MAAM;QAAEC,SAAS;QAAEC;MAAS,CAAC,GAAGF,MAAM,CAACG,OAAO;MAC9CJ,KAAK,CAACP,iBAAiB,CAACS,SAAS,CAAC,GAAGC,QAAQ;IAC/C,CAAC;IACDE,UAAU,EAAEA,CAACL,KAAK,EAAEC,MAAmE,KAAK;MAC1F,MAAM;QAAEC,SAAS;QAAEI;MAAQ,CAAC,GAAGL,MAAM,CAACG,OAAO;MAC7C,IAAI,CAACJ,KAAK,CAACP,iBAAiB,CAACS,SAAS,CAAC,EAAE;QACvCF,KAAK,CAACP,iBAAiB,CAACS,SAAS,CAAC,GAAG,EAAE;MACzC;MACAF,KAAK,CAACP,iBAAiB,CAACS,SAAS,CAAC,CAACK,IAAI,CAACD,OAAO,CAAC;IAClD,CAAC;IACDE,aAAa,EAAEA,CAACR,KAAK,EAAEC,MAAmE,KAAK;MAC7F,MAAM;QAAEC,SAAS;QAAEI;MAAQ,CAAC,GAAGL,MAAM,CAACG,OAAO;MAC7C,IAAI,CAACJ,KAAK,CAACP,iBAAiB,CAACS,SAAS,CAAC,EAAE;MAEzC,MAAMO,KAAK,GAAGT,KAAK,CAACP,iBAAiB,CAACS,SAAS,CAAC,CAACQ,SAAS,CAACC,CAAC,IAAIA,CAAC,CAACC,EAAE,KAAKN,OAAO,CAACM,EAAE,CAAC;MACpF,IAAIH,KAAK,KAAK,CAAC,CAAC,EAAE;QAChBT,KAAK,CAACP,iBAAiB,CAACS,SAAS,CAAC,CAACO,KAAK,CAAC,GAAGH,OAAO;MACrD;IACF,CAAC;IACDO,aAAa,EAAEA,CAACb,KAAK,EAAEC,MAA+D,KAAK;MACzF,MAAM;QAAEC,SAAS;QAAEY;MAAU,CAAC,GAAGb,MAAM,CAACG,OAAO;MAC/C,IAAI,CAACJ,KAAK,CAACP,iBAAiB,CAACS,SAAS,CAAC,EAAE;;MAEzC;MACAF,KAAK,CAACP,iBAAiB,CAACS,SAAS,CAAC,GAAGF,KAAK,CAACP,iBAAiB,CAACS,SAAS,CAAC,CAACa,MAAM,CAACJ,CAAC,IAAIA,CAAC,CAACC,EAAE,KAAKE,SAAS,CAAC;;MAEvG;MACAd,KAAK,CAACP,iBAAiB,CAACS,SAAS,CAAC,CAACc,OAAO,CAACC,WAAW,IAAI;QACxD,IAAIA,WAAW,CAACC,OAAO,EAAE;UACvB,MAAMC,cAAc,GAAGF,WAAW,CAACC,OAAO,CAACE,MAAM;UACjDH,WAAW,CAACC,OAAO,GAAGD,WAAW,CAACC,OAAO,CAACH,MAAM,CAACM,CAAC,IAAIA,CAAC,CAACT,EAAE,KAAKE,SAAS,CAAC;UACzE,IAAIG,WAAW,CAACC,OAAO,CAACE,MAAM,KAAKD,cAAc,EAAE;YACjDF,WAAW,CAACK,UAAU,GAAGL,WAAW,CAACC,OAAO,CAACE,MAAM;UACrD;QACF;MACF,CAAC,CAAC;IACJ,CAAC;IACDG,UAAU,EAAEA,CAACvB,KAAK,EAAEC,MAA8F,KAAK;MACrH,MAAM;QAAEC,SAAS;QAAEsB,eAAe;QAAEN;MAAQ,CAAC,GAAGjB,MAAM,CAACG,OAAO;MAE9D,IAAI,CAACJ,KAAK,CAACP,iBAAiB,CAACS,SAAS,CAAC,EAAE;MAEzC,MAAMuB,aAAa,GAAGzB,KAAK,CAACP,iBAAiB,CAACS,SAAS,CAAC,CAACwB,IAAI,CAACf,CAAC,IAAIA,CAAC,CAACC,EAAE,KAAKY,eAAe,CAAC;MAC5F,IAAIC,aAAa,EAAE;QACjB,IAAI,CAACA,aAAa,CAACP,OAAO,EAAE;UAC1BO,aAAa,CAACP,OAAO,GAAG,EAAE;QAC5B;QACA;QACA,MAAMS,UAAU,GAAGT,OAAO,CAACH,MAAM,CAACa,KAAK;UAAA,IAAAC,qBAAA;UAAA,OACrC,GAAAA,qBAAA,GAACJ,aAAa,CAACP,OAAO,cAAAW,qBAAA,eAArBA,qBAAA,CAAuBC,IAAI,CAACC,QAAQ,IAAIA,QAAQ,CAACnB,EAAE,KAAKgB,KAAK,CAAChB,EAAE,CAAC;QAAA,CACpE,CAAC;QACDa,aAAa,CAACP,OAAO,GAAG,CAAC,GAAGO,aAAa,CAACP,OAAO,EAAE,GAAGS,UAAU,CAAC;QACjEF,aAAa,CAACH,UAAU,GAAGG,aAAa,CAACP,OAAO,CAACE,MAAM;QACvDK,aAAa,CAACO,aAAa,GAAG,IAAI;MACpC;IACF,CAAC;IACDC,cAAc,EAAEA,CAACjC,KAAK,EAAEC,MAA+D,KAAK;MAC1F,MAAM;QAAEC,SAAS;QAAEY;MAAU,CAAC,GAAGb,MAAM,CAACG,OAAO;MAC/C,MAAMD,QAAQ,GAAGH,KAAK,CAACP,iBAAiB,CAACS,SAAS,CAAC;MACnD,IAAIC,QAAQ,EAAE;QACZ,MAAMG,OAAO,GAAGH,QAAQ,CAACuB,IAAI,CAAEQ,GAAiB,IAAKA,GAAG,CAACtB,EAAE,KAAKE,SAAS,CAAC;QAC1E,IAAIR,OAAO,EAAE;UACXA,OAAO,CAAC6B,UAAU,GAAG,CAAC7B,OAAO,CAAC6B,UAAU;QAC1C;MACF;IACF,CAAC;IACDC,WAAW,EAAEA,CAACpC,KAAK,EAAEC,MAAkF,KAAK;MAC1G,MAAM;QAAEC,SAAS;QAAEY,SAAS;QAAEuB;MAAS,CAAC,GAAGpC,MAAM,CAACG,OAAO;MACzD,MAAMD,QAAQ,GAAGH,KAAK,CAACP,iBAAiB,CAACS,SAAS,CAAC;MACnD,IAAIC,QAAQ,EAAE;QACZ,MAAMG,OAAO,GAAGH,QAAQ,CAACuB,IAAI,CAAEQ,GAAiB,IAAKA,GAAG,CAACtB,EAAE,KAAKE,SAAS,CAAC;QAC1E,IAAIR,OAAO,EAAE;UACXA,OAAO,CAAC6B,UAAU,GAAGE,QAAQ;QAC/B;MACF;IACF,CAAC;IACDC,QAAQ,EAAEA,CAACtC,KAAK,EAAEC,MAA0F,KAAK;MAC/G,MAAM;QAAEC,SAAS;QAAEsB,eAAe;QAAEI;MAAM,CAAC,GAAG3B,MAAM,CAACG,OAAO;MAC5D,MAAMmC,eAAe,GAAGvC,KAAK,CAACP,iBAAiB,CAACS,SAAS,CAAC;MAC1D,IAAIqC,eAAe,EAAE;QACnB,MAAMd,aAAa,GAAGc,eAAe,CAACb,IAAI,CAACQ,GAAG,IAAIA,GAAG,CAACtB,EAAE,KAAKY,eAAe,CAAC;QAC7E,IAAIC,aAAa,EAAE;UACjB,IAAI,CAACA,aAAa,CAACP,OAAO,EAAE;YAC1BO,aAAa,CAACP,OAAO,GAAG,EAAE;UAC5B;UACAO,aAAa,CAACP,OAAO,CAACX,IAAI,CAACqB,KAAK,CAAC;UACjCH,aAAa,CAACH,UAAU,GAAG,CAACG,aAAa,CAACH,UAAU,IAAI,CAAC,IAAI,CAAC;QAChE;MACF;IACF;EACF;AACF,CAAC,CAAC;AAEF,OAAO,MAAM;EACXvB,WAAW;EACXM,UAAU;EACVG,aAAa;EACbK,aAAa;EACbU,UAAU;EACVU,cAAc;EACdG,WAAW;EACXE;AACF,CAAC,GAAG1C,aAAa,CAAC4C,OAAO;AAEzB,eAAe5C,aAAa,CAAC6C,OAAO","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}