{"ast":null,"code":"import { createSlice } from '@reduxjs/toolkit';\nconst initialState = {\n  messagesByChannel: {},\n  loading: false,\n  error: null\n};\nconst messagesSlice = createSlice({\n  name: 'messages',\n  initialState,\n  reducers: {\n    setMessages: (state, action) => {\n      const {\n        channelId,\n        messages\n      } = action.payload;\n      state.messagesByChannel[channelId] = messages;\n      state.loading = false;\n      state.error = null;\n    },\n    prependMessages: (state, action) => {\n      const {\n        channelId,\n        messages\n      } = action.payload;\n      if (!state.messagesByChannel[channelId]) {\n        state.messagesByChannel[channelId] = [];\n      }\n      // Add messages to the beginning of the array, avoiding duplicates\n      const existingIds = new Set(state.messagesByChannel[channelId].map(msg => msg.id));\n      const newMessages = messages.filter(msg => !existingIds.has(msg.id));\n      state.messagesByChannel[channelId] = [...newMessages, ...state.messagesByChannel[channelId]];\n    },\n    addMessage: (state, action) => {\n      const {\n        channelId\n      } = action.payload;\n\n      // Initialize channel messages array if it doesn't exist\n      if (!state.messagesByChannel[channelId]) {\n        state.messagesByChannel[channelId] = [];\n      }\n\n      // Check if message already exists by ID\n      const existingMessageIndex = state.messagesByChannel[channelId].findIndex(msg => msg.id === action.payload.id);\n      if (existingMessageIndex === -1) {\n        // Add new message\n        state.messagesByChannel[channelId].push(action.payload);\n\n        // Sort messages by creation time, ensuring chronological order\n        state.messagesByChannel[channelId].sort((a, b) => {\n          const timeA = new Date(a.createdAt).getTime();\n          const timeB = new Date(b.createdAt).getTime();\n          return timeA - timeB;\n        });\n\n        // Ensure parent messages are marked as having replies\n        if (action.payload.parentId) {\n          const parentMessage = state.messagesByChannel[channelId].find(msg => msg.id === action.payload.parentId);\n          if (parentMessage) {\n            parentMessage.replyCount = (parentMessage.replyCount || 0) + 1;\n          }\n        }\n      } else {\n        // Update existing message if it has changed\n        const existingMessage = state.messagesByChannel[channelId][existingMessageIndex];\n        if (existingMessage.updatedAt !== action.payload.updatedAt || existingMessage.content !== action.payload.content || existingMessage.replyCount !== action.payload.replyCount) {\n          state.messagesByChannel[channelId][existingMessageIndex] = {\n            ...existingMessage,\n            ...action.payload,\n            reactions: [...existingMessage.reactions] // Preserve existing reactions\n          };\n        }\n      }\n    },\n    updateMessage: (state, action) => {\n      const {\n        channelId,\n        id\n      } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const index = messages.findIndex(msg => msg.id === id);\n        if (index !== -1) {\n          messages[index] = action.payload.message;\n        }\n      }\n    },\n    deleteMessage: (state, action) => {\n      const {\n        channelId,\n        messageId\n      } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        state.messagesByChannel[channelId] = messages.filter(msg => msg.id !== messageId);\n      }\n    },\n    addReaction: (state, action) => {\n      const {\n        channelId,\n        messageId,\n        reaction\n      } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const message = messages.find(msg => msg.id === messageId);\n        if (message) {\n          // Check if reaction already exists\n          const existingReactionIndex = message.reactions.findIndex(r => r.id === reaction.id || r.emoji === reaction.emoji && r.userId === reaction.userId);\n          if (existingReactionIndex === -1) {\n            message.reactions.push(reaction);\n          }\n        }\n      }\n    },\n    removeReaction: (state, action) => {\n      const {\n        channelId,\n        messageId,\n        reactionId\n      } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const message = messages.find(msg => msg.id === messageId);\n        if (message) {\n          message.reactions = message.reactions.filter(reaction => reaction.id !== reactionId);\n        }\n      }\n    },\n    setReplies: (state, action) => {\n      const {\n        channelId,\n        messageId,\n        replies\n      } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const messageIndex = messages.findIndex(msg => msg.id === messageId);\n        if (messageIndex !== -1) {\n          // Create a new message object with the updated replies\n          const updatedMessage = {\n            ...messages[messageIndex],\n            replies: [...(messages[messageIndex].replies || []), ...replies.filter(reply => {\n              var _messages$messageInde;\n              return !((_messages$messageInde = messages[messageIndex].replies) !== null && _messages$messageInde !== void 0 && _messages$messageInde.some(existingReply => existingReply.id === reply.id));\n            })],\n            repliesLoaded: true,\n            isExpanded: true // Auto-expand when new replies are added\n          };\n\n          // Update reply count\n          updatedMessage.replyCount = updatedMessage.replies.length;\n\n          // Update the message in the array\n          messages[messageIndex] = updatedMessage;\n        }\n      }\n    },\n    toggleExpanded: (state, action) => {\n      const {\n        channelId,\n        messageId\n      } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const message = messages.find(msg => msg.id === messageId);\n        if (message) {\n          message.isExpanded = !message.isExpanded;\n        }\n      }\n    }\n  }\n});\nexport const {\n  setMessages,\n  prependMessages,\n  addMessage,\n  updateMessage,\n  deleteMessage,\n  addReaction,\n  removeReaction,\n  setReplies,\n  toggleExpanded\n} = messagesSlice.actions;\nexport default messagesSlice.reducer;","map":{"version":3,"names":["createSlice","initialState","messagesByChannel","loading","error","messagesSlice","name","reducers","setMessages","state","action","channelId","messages","payload","prependMessages","existingIds","Set","map","msg","id","newMessages","filter","has","addMessage","existingMessageIndex","findIndex","push","sort","a","b","timeA","Date","createdAt","getTime","timeB","parentId","parentMessage","find","replyCount","existingMessage","updatedAt","content","reactions","updateMessage","index","message","deleteMessage","messageId","addReaction","reaction","existingReactionIndex","r","emoji","userId","removeReaction","reactionId","setReplies","replies","messageIndex","updatedMessage","reply","_messages$messageInde","some","existingReply","repliesLoaded","isExpanded","length","toggleExpanded","actions","reducer"],"sources":["Z:/GAUNTLET/projects/SERMO/sermo-app/frontend/src/store/messages/messagesSlice.ts"],"sourcesContent":["import { createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { MessagesState, Reaction, StoreMessage } from '../../types';\n\nconst initialState: MessagesState = {\n  messagesByChannel: {},\n  loading: false,\n  error: null,\n};\n\nconst messagesSlice = createSlice({\n  name: 'messages',\n  initialState,\n  reducers: {\n    setMessages: (state, action: PayloadAction<{ channelId: string; messages: StoreMessage[] }>) => {\n      const { channelId, messages } = action.payload;\n      state.messagesByChannel[channelId] = messages;\n      state.loading = false;\n      state.error = null;\n    },\n    prependMessages: (state, action: PayloadAction<{ channelId: string; messages: StoreMessage[] }>) => {\n      const { channelId, messages } = action.payload;\n      if (!state.messagesByChannel[channelId]) {\n        state.messagesByChannel[channelId] = [];\n      }\n      // Add messages to the beginning of the array, avoiding duplicates\n      const existingIds = new Set(state.messagesByChannel[channelId].map(msg => msg.id));\n      const newMessages = messages.filter(msg => !existingIds.has(msg.id));\n      state.messagesByChannel[channelId] = [...newMessages, ...state.messagesByChannel[channelId]];\n    },\n    addMessage: (state, action: PayloadAction<StoreMessage>) => {\n      const { channelId } = action.payload;\n      \n      // Initialize channel messages array if it doesn't exist\n      if (!state.messagesByChannel[channelId]) {\n        state.messagesByChannel[channelId] = [];\n      }\n\n      // Check if message already exists by ID\n      const existingMessageIndex = state.messagesByChannel[channelId].findIndex(\n        (msg: StoreMessage) => msg.id === action.payload.id\n      );\n\n      if (existingMessageIndex === -1) {\n        // Add new message\n        state.messagesByChannel[channelId].push(action.payload);\n        \n        // Sort messages by creation time, ensuring chronological order\n        state.messagesByChannel[channelId].sort((a, b) => {\n          const timeA = new Date(a.createdAt).getTime();\n          const timeB = new Date(b.createdAt).getTime();\n          return timeA - timeB;\n        });\n\n        // Ensure parent messages are marked as having replies\n        if (action.payload.parentId) {\n          const parentMessage = state.messagesByChannel[channelId].find(\n            msg => msg.id === action.payload.parentId\n          );\n          if (parentMessage) {\n            parentMessage.replyCount = (parentMessage.replyCount || 0) + 1;\n          }\n        }\n      } else {\n        // Update existing message if it has changed\n        const existingMessage = state.messagesByChannel[channelId][existingMessageIndex];\n        if (\n          existingMessage.updatedAt !== action.payload.updatedAt ||\n          existingMessage.content !== action.payload.content ||\n          existingMessage.replyCount !== action.payload.replyCount\n        ) {\n          state.messagesByChannel[channelId][existingMessageIndex] = {\n            ...existingMessage,\n            ...action.payload,\n            reactions: [...existingMessage.reactions] // Preserve existing reactions\n          };\n        }\n      }\n    },\n    updateMessage: (state, action: PayloadAction<{ channelId: string; id: string; message: StoreMessage }>) => {\n      const { channelId, id } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const index = messages.findIndex((msg: StoreMessage) => msg.id === id);\n        if (index !== -1) {\n          messages[index] = action.payload.message;\n        }\n      }\n    },\n    deleteMessage: (state, action: PayloadAction<{ channelId: string; messageId: string }>) => {\n      const { channelId, messageId } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        state.messagesByChannel[channelId] = messages.filter((msg: StoreMessage) => msg.id !== messageId);\n      }\n    },\n    addReaction: (state, action: PayloadAction<{ channelId: string; messageId: string; reaction: Reaction }>) => {\n      const { channelId, messageId, reaction } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const message = messages.find((msg: StoreMessage) => msg.id === messageId);\n        if (message) {\n          // Check if reaction already exists\n          const existingReactionIndex = message.reactions.findIndex(\n            (r: Reaction) => r.id === reaction.id || (r.emoji === reaction.emoji && r.userId === reaction.userId)\n          );\n          if (existingReactionIndex === -1) {\n            message.reactions.push(reaction);\n          }\n        }\n      }\n    },\n    removeReaction: (state, action: PayloadAction<{ channelId: string; messageId: string; reactionId: string }>) => {\n      const { channelId, messageId, reactionId } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const message = messages.find((msg: StoreMessage) => msg.id === messageId);\n        if (message) {\n          message.reactions = message.reactions.filter((reaction: Reaction) => reaction.id !== reactionId);\n        }\n      }\n    },\n    setReplies: (state, action: PayloadAction<{ channelId: string; messageId: string; replies: StoreMessage[] }>) => {\n      const { channelId, messageId, replies } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const messageIndex = messages.findIndex((msg: StoreMessage) => msg.id === messageId);\n        if (messageIndex !== -1) {\n          // Create a new message object with the updated replies\n          const updatedMessage = {\n            ...messages[messageIndex],\n            replies: [\n              ...(messages[messageIndex].replies || []),\n              ...replies.filter(reply => \n                !messages[messageIndex].replies?.some(existingReply => \n                  existingReply.id === reply.id\n                )\n              )\n            ],\n            repliesLoaded: true,\n            isExpanded: true // Auto-expand when new replies are added\n          };\n          \n          // Update reply count\n          updatedMessage.replyCount = updatedMessage.replies.length;\n          \n          // Update the message in the array\n          messages[messageIndex] = updatedMessage;\n        }\n      }\n    },\n    toggleExpanded: (state, action: PayloadAction<{ channelId: string; messageId: string }>) => {\n      const { channelId, messageId } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const message = messages.find((msg: StoreMessage) => msg.id === messageId);\n        if (message) {\n          message.isExpanded = !message.isExpanded;\n        }\n      }\n    },\n  },\n});\n\nexport const {\n  setMessages,\n  prependMessages,\n  addMessage,\n  updateMessage,\n  deleteMessage,\n  addReaction,\n  removeReaction,\n  setReplies,\n  toggleExpanded\n} = messagesSlice.actions;\n\nexport default messagesSlice.reducer; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}