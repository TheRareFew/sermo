{"ast":null,"code":"var _WebSocketService;\nimport { store } from '../../store';\nimport { addMessage, updateMessage, addReaction, removeReaction } from '../../store/messages/messagesSlice';\nimport { updateUserStatus } from '../../store/chat/chatSlice';\n\n// Get WebSocket URL from environment variable or fallback to localhost\nconst WS_BASE_URL = process.env.REACT_APP_WS_URL || 'ws://localhost:8000/ws';\n\n// Helper function to get the correct WebSocket URL based on the current protocol\nconst getWebSocketUrl = () => {\n  // If we're on HTTPS, use WSS\n  if (window.location.protocol === 'https:' && WS_BASE_URL.startsWith('ws:')) {\n    return WS_BASE_URL.replace('ws:', 'wss:');\n  }\n  return WS_BASE_URL;\n};\nexport class WebSocketService {\n  constructor() {\n    this.ws = null;\n    this.pingInterval = null;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectTimeout = null;\n    this.channels = new Set();\n    if (WebSocketService.instance) {\n      return WebSocketService.instance;\n    }\n    WebSocketService.instance = this;\n  }\n  getAuthToken() {\n    var _state$auth;\n    const state = store.getState();\n    return ((_state$auth = state.auth) === null || _state$auth === void 0 ? void 0 : _state$auth.token) || null;\n  }\n  connect() {\n    var _this$ws;\n    if (((_this$ws = this.ws) === null || _this$ws === void 0 ? void 0 : _this$ws.readyState) === WebSocket.OPEN) {\n      console.log('WebSocket already connected');\n      return;\n    }\n    const token = this.getAuthToken();\n    if (!token) {\n      console.warn('No auth token available, skipping WebSocket connection');\n      return;\n    }\n    const wsUrl = `${getWebSocketUrl()}?token=${token}`;\n    console.log('Connecting to WebSocket:', wsUrl);\n    try {\n      this.ws = new WebSocket(wsUrl);\n      this.ws.onopen = () => {\n        console.log('WebSocket connected successfully');\n        this.reconnectAttempts = 0;\n        this.startPingInterval();\n\n        // Rejoin all channels\n        this.channels.forEach(channelId => {\n          console.log('Rejoining channel:', channelId);\n          this.joinChannel(channelId);\n        });\n      };\n      this.ws.onmessage = event => {\n        console.log('Raw WebSocket message received:', event.data);\n        this.handleMessage(event);\n      };\n      this.ws.onclose = event => {\n        console.log('WebSocket disconnected with code:', event.code, 'reason:', event.reason);\n        this.stopPingInterval();\n        this.handleReconnect();\n      };\n      this.ws.onerror = error => {\n        console.error('WebSocket error:', error);\n      };\n    } catch (error) {\n      console.error('Error creating WebSocket connection:', error);\n    }\n  }\n  handleReconnect() {\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n      this.reconnectAttempts++;\n      console.log(`Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\n      this.reconnectTimeout = setTimeout(() => {\n        this.connect();\n      }, 5000);\n    }\n  }\n  startPingInterval() {\n    this.pingInterval = setInterval(() => {\n      var _this$ws2;\n      if (((_this$ws2 = this.ws) === null || _this$ws2 === void 0 ? void 0 : _this$ws2.readyState) === WebSocket.OPEN) {\n        this.ws.send(JSON.stringify({\n          type: 'PING'\n        }));\n      }\n    }, 30000);\n  }\n  stopPingInterval() {\n    if (this.pingInterval) {\n      clearInterval(this.pingInterval);\n      this.pingInterval = null;\n    }\n  }\n  disconnect() {\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n    this.stopPingInterval();\n  }\n  handleMessage(event) {\n    var _data$data2, _data$data3, _data$data9, _data$data10, _data$data11, _data$data12;\n    try {\n      console.log('Raw WebSocket message received:', event.data);\n      const data = JSON.parse(event.data);\n      console.log('Parsed WebSocket message:', data);\n\n      // Normalize the message type to lowercase\n      const messageType = data.type.toLowerCase();\n      console.log('Normalized message type:', messageType);\n\n      // For reaction events, check if we're subscribed to the channel\n      if (messageType === 'reaction_added' || messageType === 'reaction_removed') {\n        var _data$data, _data$data$channel_id;\n        const channelId = (_data$data = data.data) === null || _data$data === void 0 ? void 0 : (_data$data$channel_id = _data$data.channel_id) === null || _data$data$channel_id === void 0 ? void 0 : _data$data$channel_id.toString();\n        console.log('Reaction event received for channel:', channelId);\n        console.log('Currently subscribed channels:', Array.from(this.channels));\n        if (channelId && !this.channels.has(channelId)) {\n          console.warn('Received reaction event for unsubscribed channel:', channelId);\n          return;\n        }\n      }\n      switch (messageType) {\n        case 'new_message':\n          if (data.channelId && data.message) {\n            if (data.isReply && data.parentId) {\n              store.dispatch(addMessage({\n                channelId: data.channelId,\n                message: {\n                  ...data.message,\n                  parentId: data.parentId\n                }\n              }));\n            } else {\n              store.dispatch(addMessage({\n                channelId: data.channelId,\n                message: data.message\n              }));\n            }\n          }\n          break;\n        case 'update_message':\n          if (data.channelId && data.id && data.updates) {\n            store.dispatch(updateMessage({\n              channelId: data.channelId,\n              messageId: data.id,\n              message: data.updates\n            }));\n          }\n          break;\n        case 'user_status':\n          if (data.userId && data.status) {\n            store.dispatch(updateUserStatus({\n              userId: data.userId,\n              status: data.status\n            }));\n          }\n          break;\n        case 'reaction_added':\n          console.log('Processing reaction_added event:', data);\n          if ((_data$data2 = data.data) !== null && _data$data2 !== void 0 && _data$data2.channel_id && (_data$data3 = data.data) !== null && _data$data3 !== void 0 && _data$data3.message_id) {\n            var _data$data$reaction_i, _data$data$user_id, _state$messages$messa, _updatedState$message;\n            const channelId = data.data.channel_id.toString();\n            const messageId = data.data.message_id;\n            const reaction = {\n              id: ((_data$data$reaction_i = data.data.reaction_id) === null || _data$data$reaction_i === void 0 ? void 0 : _data$data$reaction_i.toString()) || '',\n              messageId: data.data.message_id,\n              userId: ((_data$data$user_id = data.data.user_id) === null || _data$data$user_id === void 0 ? void 0 : _data$data$user_id.toString()) || '',\n              emoji: data.data.emoji || '',\n              createdAt: new Date().toISOString()\n            };\n            console.log('Handling reaction_added:', {\n              channelId,\n              messageId,\n              reaction\n            });\n\n            // Get current state\n            const state = store.getState();\n            const message = (_state$messages$messa = state.messages.messagesByChannel[channelId]) === null || _state$messages$messa === void 0 ? void 0 : _state$messages$messa.find(m => m.id === messageId);\n            console.log('Current message state:', message);\n            if (!message) {\n              console.warn('Message not found in store:', messageId);\n              return;\n            }\n            store.dispatch(addReaction({\n              channelId,\n              messageId,\n              reaction\n            }));\n\n            // Get updated state\n            const updatedState = store.getState();\n            const updatedMessage = (_updatedState$message = updatedState.messages.messagesByChannel[channelId]) === null || _updatedState$message === void 0 ? void 0 : _updatedState$message.find(m => m.id === messageId);\n            console.log('Updated message state:', updatedMessage);\n          } else {\n            var _data$data4, _data$data5, _data$data6, _data$data7, _data$data8;\n            console.warn('Invalid reaction_added data:', {\n              channelId: (_data$data4 = data.data) === null || _data$data4 === void 0 ? void 0 : _data$data4.channel_id,\n              messageId: (_data$data5 = data.data) === null || _data$data5 === void 0 ? void 0 : _data$data5.message_id,\n              userId: (_data$data6 = data.data) === null || _data$data6 === void 0 ? void 0 : _data$data6.user_id,\n              emoji: (_data$data7 = data.data) === null || _data$data7 === void 0 ? void 0 : _data$data7.emoji,\n              reactionId: (_data$data8 = data.data) === null || _data$data8 === void 0 ? void 0 : _data$data8.reaction_id\n            });\n          }\n          break;\n        case 'reaction_removed':\n          if ((_data$data9 = data.data) !== null && _data$data9 !== void 0 && _data$data9.channel_id && (_data$data10 = data.data) !== null && _data$data10 !== void 0 && _data$data10.message_id && (_data$data11 = data.data) !== null && _data$data11 !== void 0 && _data$data11.user_id && (_data$data12 = data.data) !== null && _data$data12 !== void 0 && _data$data12.emoji) {\n            var _state$messages$messa2, _updatedState$message2;\n            const channelId = data.data.channel_id.toString();\n            const messageId = data.data.message_id;\n            const userId = data.data.user_id;\n            const emoji = data.data.emoji;\n            console.log('Handling reaction_removed:', {\n              channelId,\n              messageId,\n              userId,\n              emoji\n            });\n\n            // Get current state\n            const state = store.getState();\n            const message = (_state$messages$messa2 = state.messages.messagesByChannel[channelId]) === null || _state$messages$messa2 === void 0 ? void 0 : _state$messages$messa2.find(m => m.id === messageId);\n            console.log('Current message state:', message);\n            store.dispatch(removeReaction({\n              channelId,\n              messageId,\n              userId,\n              emoji\n            }));\n\n            // Get updated state\n            const updatedState = store.getState();\n            const updatedMessage = (_updatedState$message2 = updatedState.messages.messagesByChannel[channelId]) === null || _updatedState$message2 === void 0 ? void 0 : _updatedState$message2.find(m => m.id === messageId);\n            console.log('Updated message state:', updatedMessage);\n          } else {\n            var _data$data13, _data$data14, _data$data15, _data$data16;\n            console.warn('Invalid reaction_removed data:', {\n              channelId: (_data$data13 = data.data) === null || _data$data13 === void 0 ? void 0 : _data$data13.channel_id,\n              messageId: (_data$data14 = data.data) === null || _data$data14 === void 0 ? void 0 : _data$data14.message_id,\n              userId: (_data$data15 = data.data) === null || _data$data15 === void 0 ? void 0 : _data$data15.user_id,\n              emoji: (_data$data16 = data.data) === null || _data$data16 === void 0 ? void 0 : _data$data16.emoji\n            });\n          }\n          break;\n        case 'pong':\n          // Handle pong response\n          break;\n        default:\n          console.warn('Unknown message type:', messageType, 'original type:', data.type);\n      }\n    } catch (error) {\n      console.error('Error handling WebSocket message:', error);\n      console.error('Raw message data:', event.data);\n    }\n  }\n  joinChannel(channelId) {\n    var _this$ws3;\n    console.log('Joining channel:', channelId);\n    if (((_this$ws3 = this.ws) === null || _this$ws3 === void 0 ? void 0 : _this$ws3.readyState) === WebSocket.OPEN) {\n      this.ws.send(JSON.stringify({\n        type: 'join_channel',\n        channelId\n      }));\n      this.channels.add(channelId);\n      console.log('Current channels:', Array.from(this.channels));\n    } else {\n      console.warn('WebSocket not connected, cannot join channel:', channelId);\n    }\n  }\n  leaveChannel(channelId) {\n    var _this$ws4;\n    console.log('Leaving channel:', channelId);\n    if (((_this$ws4 = this.ws) === null || _this$ws4 === void 0 ? void 0 : _this$ws4.readyState) === WebSocket.OPEN) {\n      this.ws.send(JSON.stringify({\n        type: 'leave_channel',\n        channelId\n      }));\n      this.channels.delete(channelId);\n      console.log('Current channels:', Array.from(this.channels));\n    } else {\n      console.warn('WebSocket not connected, cannot leave channel:', channelId);\n    }\n  }\n}\n_WebSocketService = WebSocketService;\nWebSocketService.instance = null;\nexport default new WebSocketService();","map":{"version":3,"names":["store","addMessage","updateMessage","addReaction","removeReaction","updateUserStatus","WS_BASE_URL","process","env","REACT_APP_WS_URL","getWebSocketUrl","window","location","protocol","startsWith","replace","WebSocketService","constructor","ws","pingInterval","reconnectAttempts","maxReconnectAttempts","reconnectTimeout","channels","Set","instance","getAuthToken","_state$auth","state","getState","auth","token","connect","_this$ws","readyState","WebSocket","OPEN","console","log","warn","wsUrl","onopen","startPingInterval","forEach","channelId","joinChannel","onmessage","event","data","handleMessage","onclose","code","reason","stopPingInterval","handleReconnect","onerror","error","setTimeout","setInterval","_this$ws2","send","JSON","stringify","type","clearInterval","disconnect","close","clearTimeout","_data$data2","_data$data3","_data$data9","_data$data10","_data$data11","_data$data12","parse","messageType","toLowerCase","_data$data","_data$data$channel_id","channel_id","toString","Array","from","has","message","isReply","parentId","dispatch","id","updates","messageId","userId","status","message_id","_data$data$reaction_i","_data$data$user_id","_state$messages$messa","_updatedState$message","reaction","reaction_id","user_id","emoji","createdAt","Date","toISOString","messages","messagesByChannel","find","m","updatedState","updatedMessage","_data$data4","_data$data5","_data$data6","_data$data7","_data$data8","reactionId","_state$messages$messa2","_updatedState$message2","_data$data13","_data$data14","_data$data15","_data$data16","_this$ws3","add","leaveChannel","_this$ws4","delete","_WebSocketService"],"sources":["Z:/GAUNTLET/projects/SERMO/sermo-app/frontend/src/services/websocket/index.ts"],"sourcesContent":["import { Reaction } from '../../types';\r\nimport { store } from '../../store';\r\nimport { addMessage, updateMessage, addReaction, removeReaction } from '../../store/messages/messagesSlice';\r\nimport { updateUserStatus } from '../../store/chat/chatSlice';\r\n\r\n// Get WebSocket URL from environment variable or fallback to localhost\r\nconst WS_BASE_URL = process.env.REACT_APP_WS_URL || 'ws://localhost:8000/ws';\r\n\r\n// Helper function to get the correct WebSocket URL based on the current protocol\r\nconst getWebSocketUrl = () => {\r\n  // If we're on HTTPS, use WSS\r\n  if (window.location.protocol === 'https:' && WS_BASE_URL.startsWith('ws:')) {\r\n    return WS_BASE_URL.replace('ws:', 'wss:');\r\n  }\r\n  return WS_BASE_URL;\r\n};\r\n\r\ninterface WebSocketMessage {\r\n  type: 'new_message' | 'update_message' | 'user_status' | 'ping' | 'pong' | 'join_channel' | 'leave_channel' | 'reaction_added' | 'reaction_removed' | 'REACTION_ADDED' | 'REACTION_REMOVED';\r\n  channelId?: string;\r\n  message?: any;\r\n  id?: string;\r\n  updates?: any;\r\n  userId?: string;\r\n  status?: 'online' | 'offline' | 'away' | 'busy';\r\n  isReply?: boolean;\r\n  parentId?: string;\r\n  messageId?: string;\r\n  reaction?: Reaction;\r\n  emoji?: string;\r\n  data?: {\r\n    channel_id: number | string;\r\n    message_id: string;\r\n    user_id: string;\r\n    emoji: string;\r\n    reaction: Reaction;\r\n  };\r\n}\r\n\r\nexport class WebSocketService {\r\n  private static instance: WebSocketService | null = null;\r\n  private ws: WebSocket | null = null;\r\n  private pingInterval: NodeJS.Timeout | null = null;\r\n  private reconnectAttempts = 0;\r\n  private maxReconnectAttempts = 5;\r\n  private reconnectTimeout: NodeJS.Timeout | null = null;\r\n  private channels: Set<string> = new Set();\r\n\r\n  constructor() {\r\n    if (WebSocketService.instance) {\r\n      return WebSocketService.instance;\r\n    }\r\n    WebSocketService.instance = this;\r\n  }\r\n\r\n  private getAuthToken(): string | null {\r\n    const state = store.getState();\r\n    return state.auth?.token || null;\r\n  }\r\n\r\n  public connect() {\r\n    if (this.ws?.readyState === WebSocket.OPEN) {\r\n      console.log('WebSocket already connected');\r\n      return;\r\n    }\r\n\r\n    const token = this.getAuthToken();\r\n    if (!token) {\r\n      console.warn('No auth token available, skipping WebSocket connection');\r\n      return;\r\n    }\r\n\r\n    const wsUrl = `${getWebSocketUrl()}?token=${token}`;\r\n    console.log('Connecting to WebSocket:', wsUrl);\r\n    \r\n    try {\r\n      this.ws = new WebSocket(wsUrl);\r\n      \r\n      this.ws.onopen = () => {\r\n        console.log('WebSocket connected successfully');\r\n        this.reconnectAttempts = 0;\r\n        this.startPingInterval();\r\n        \r\n        // Rejoin all channels\r\n        this.channels.forEach(channelId => {\r\n          console.log('Rejoining channel:', channelId);\r\n          this.joinChannel(channelId);\r\n        });\r\n      };\r\n\r\n      this.ws.onmessage = (event) => {\r\n        console.log('Raw WebSocket message received:', event.data);\r\n        this.handleMessage(event);\r\n      };\r\n\r\n      this.ws.onclose = (event) => {\r\n        console.log('WebSocket disconnected with code:', event.code, 'reason:', event.reason);\r\n        this.stopPingInterval();\r\n        this.handleReconnect();\r\n      };\r\n\r\n      this.ws.onerror = (error) => {\r\n        console.error('WebSocket error:', error);\r\n      };\r\n    } catch (error) {\r\n      console.error('Error creating WebSocket connection:', error);\r\n    }\r\n  }\r\n\r\n  private handleReconnect() {\r\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\r\n      this.reconnectAttempts++;\r\n      console.log(`Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\r\n      this.reconnectTimeout = setTimeout(() => {\r\n        this.connect();\r\n      }, 5000);\r\n    }\r\n  }\r\n\r\n  private startPingInterval() {\r\n    this.pingInterval = setInterval(() => {\r\n      if (this.ws?.readyState === WebSocket.OPEN) {\r\n        this.ws.send(JSON.stringify({ type: 'PING' }));\r\n      }\r\n    }, 30000);\r\n  }\r\n\r\n  private stopPingInterval() {\r\n    if (this.pingInterval) {\r\n      clearInterval(this.pingInterval);\r\n      this.pingInterval = null;\r\n    }\r\n  }\r\n\r\n  public disconnect() {\r\n    if (this.ws) {\r\n      this.ws.close();\r\n      this.ws = null;\r\n    }\r\n    if (this.reconnectTimeout) {\r\n      clearTimeout(this.reconnectTimeout);\r\n      this.reconnectTimeout = null;\r\n    }\r\n    this.stopPingInterval();\r\n  }\r\n\r\n  private handleMessage(event: MessageEvent) {\r\n    try {\r\n      console.log('Raw WebSocket message received:', event.data);\r\n      const data = JSON.parse(event.data) as WebSocketMessage;\r\n      console.log('Parsed WebSocket message:', data);\r\n\r\n      // Normalize the message type to lowercase\r\n      const messageType = data.type.toLowerCase();\r\n      console.log('Normalized message type:', messageType);\r\n\r\n      // For reaction events, check if we're subscribed to the channel\r\n      if (messageType === 'reaction_added' || messageType === 'reaction_removed') {\r\n        const channelId = data.data?.channel_id?.toString();\r\n        console.log('Reaction event received for channel:', channelId);\r\n        console.log('Currently subscribed channels:', Array.from(this.channels));\r\n        if (channelId && !this.channels.has(channelId)) {\r\n          console.warn('Received reaction event for unsubscribed channel:', channelId);\r\n          return;\r\n        }\r\n      }\r\n\r\n      switch (messageType) {\r\n        case 'new_message':\r\n          if (data.channelId && data.message) {\r\n            if (data.isReply && data.parentId) {\r\n              store.dispatch(addMessage({\r\n                channelId: data.channelId,\r\n                message: {\r\n                  ...data.message,\r\n                  parentId: data.parentId\r\n                }\r\n              }));\r\n            } else {\r\n              store.dispatch(addMessage({\r\n                channelId: data.channelId,\r\n                message: data.message\r\n              }));\r\n            }\r\n          }\r\n          break;\r\n\r\n        case 'update_message':\r\n          if (data.channelId && data.id && data.updates) {\r\n            store.dispatch(updateMessage({\r\n              channelId: data.channelId,\r\n              messageId: data.id,\r\n              message: data.updates\r\n            }));\r\n          }\r\n          break;\r\n\r\n        case 'user_status':\r\n          if (data.userId && data.status) {\r\n            store.dispatch(updateUserStatus({\r\n              userId: data.userId,\r\n              status: data.status\r\n            }));\r\n          }\r\n          break;\r\n\r\n        case 'reaction_added':\r\n          console.log('Processing reaction_added event:', data);\r\n          if (data.data?.channel_id && data.data?.message_id) {\r\n            const channelId = data.data.channel_id.toString();\r\n            const messageId = data.data.message_id;\r\n            const reaction = {\r\n              id: data.data.reaction_id?.toString() || '',\r\n              messageId: data.data.message_id,\r\n              userId: data.data.user_id?.toString() || '',\r\n              emoji: data.data.emoji || '',\r\n              createdAt: new Date().toISOString(),\r\n            };\r\n\r\n            console.log('Handling reaction_added:', {\r\n              channelId,\r\n              messageId,\r\n              reaction\r\n            });\r\n            \r\n            // Get current state\r\n            const state = store.getState();\r\n            const message = state.messages.messagesByChannel[channelId]?.find(\r\n              m => m.id === messageId\r\n            );\r\n            console.log('Current message state:', message);\r\n            \r\n            if (!message) {\r\n              console.warn('Message not found in store:', messageId);\r\n              return;\r\n            }\r\n            \r\n            store.dispatch(addReaction({\r\n              channelId,\r\n              messageId,\r\n              reaction\r\n            }));\r\n            \r\n            // Get updated state\r\n            const updatedState = store.getState();\r\n            const updatedMessage = updatedState.messages.messagesByChannel[channelId]?.find(\r\n              m => m.id === messageId\r\n            );\r\n            console.log('Updated message state:', updatedMessage);\r\n          } else {\r\n            console.warn('Invalid reaction_added data:', {\r\n              channelId: data.data?.channel_id,\r\n              messageId: data.data?.message_id,\r\n              userId: data.data?.user_id,\r\n              emoji: data.data?.emoji,\r\n              reactionId: data.data?.reaction_id\r\n            });\r\n          }\r\n          break;\r\n\r\n        case 'reaction_removed':\r\n          if (data.data?.channel_id && data.data?.message_id && data.data?.user_id && data.data?.emoji) {\r\n            const channelId = data.data.channel_id.toString();\r\n            const messageId = data.data.message_id;\r\n            const userId = data.data.user_id;\r\n            const emoji = data.data.emoji;\r\n\r\n            console.log('Handling reaction_removed:', {\r\n              channelId,\r\n              messageId,\r\n              userId,\r\n              emoji\r\n            });\r\n            \r\n            // Get current state\r\n            const state = store.getState();\r\n            const message = state.messages.messagesByChannel[channelId]?.find(\r\n              m => m.id === messageId\r\n            );\r\n            console.log('Current message state:', message);\r\n            \r\n            store.dispatch(removeReaction({\r\n              channelId,\r\n              messageId,\r\n              userId,\r\n              emoji\r\n            }));\r\n            \r\n            // Get updated state\r\n            const updatedState = store.getState();\r\n            const updatedMessage = updatedState.messages.messagesByChannel[channelId]?.find(\r\n              m => m.id === messageId\r\n            );\r\n            console.log('Updated message state:', updatedMessage);\r\n          } else {\r\n            console.warn('Invalid reaction_removed data:', {\r\n              channelId: data.data?.channel_id,\r\n              messageId: data.data?.message_id,\r\n              userId: data.data?.user_id,\r\n              emoji: data.data?.emoji\r\n            });\r\n          }\r\n          break;\r\n\r\n        case 'pong':\r\n          // Handle pong response\r\n          break;\r\n\r\n        default:\r\n          console.warn('Unknown message type:', messageType, 'original type:', data.type);\r\n      }\r\n    } catch (error) {\r\n      console.error('Error handling WebSocket message:', error);\r\n      console.error('Raw message data:', event.data);\r\n    }\r\n  }\r\n\r\n  public joinChannel(channelId: string) {\r\n    console.log('Joining channel:', channelId);\r\n    if (this.ws?.readyState === WebSocket.OPEN) {\r\n      this.ws.send(JSON.stringify({\r\n        type: 'join_channel',\r\n        channelId\r\n      }));\r\n      this.channels.add(channelId);\r\n      console.log('Current channels:', Array.from(this.channels));\r\n    } else {\r\n      console.warn('WebSocket not connected, cannot join channel:', channelId);\r\n    }\r\n  }\r\n\r\n  public leaveChannel(channelId: string) {\r\n    console.log('Leaving channel:', channelId);\r\n    if (this.ws?.readyState === WebSocket.OPEN) {\r\n      this.ws.send(JSON.stringify({\r\n        type: 'leave_channel',\r\n        channelId\r\n      }));\r\n      this.channels.delete(channelId);\r\n      console.log('Current channels:', Array.from(this.channels));\r\n    } else {\r\n      console.warn('WebSocket not connected, cannot leave channel:', channelId);\r\n    }\r\n  }\r\n}\r\n\r\nexport default new WebSocketService(); "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}