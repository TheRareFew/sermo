{"ast":null,"code":"import { createSlice } from '@reduxjs/toolkit';\nconst initialState = {\n  messagesByChannel: {},\n  loading: false,\n  error: null\n};\nconst messagesSlice = createSlice({\n  name: 'messages',\n  initialState,\n  reducers: {\n    setMessages: (state, action) => {\n      const {\n        channelId,\n        messages\n      } = action.payload;\n\n      // Organize messages by parent/reply relationship\n      const mainMessages = [];\n      const repliesByParentId = {};\n\n      // First pass: separate messages into main messages and replies\n      messages.forEach(msg => {\n        if (msg.parentId) {\n          // This is a reply\n          if (!repliesByParentId[msg.parentId]) {\n            repliesByParentId[msg.parentId] = [];\n          }\n          repliesByParentId[msg.parentId].push(msg);\n        } else {\n          // This is a main message\n          mainMessages.push(msg);\n        }\n      });\n\n      // Second pass: attach replies to their parent messages\n      mainMessages.forEach(msg => {\n        if (repliesByParentId[msg.id]) {\n          msg.replies = repliesByParentId[msg.id];\n          msg.replyCount = repliesByParentId[msg.id].length;\n          msg.repliesLoaded = true;\n        }\n      });\n\n      // Update the state with organized messages\n      state.messagesByChannel[channelId] = mainMessages;\n      state.loading = false;\n      state.error = null;\n    },\n    prependMessages: (state, action) => {\n      const {\n        channelId,\n        messages\n      } = action.payload;\n      if (!state.messagesByChannel[channelId]) {\n        state.messagesByChannel[channelId] = [];\n      }\n      // Add messages to the beginning of the array, avoiding duplicates\n      const existingIds = new Set(state.messagesByChannel[channelId].map(msg => msg.id));\n      const newMessages = messages.filter(msg => !existingIds.has(msg.id));\n      state.messagesByChannel[channelId] = [...newMessages, ...state.messagesByChannel[channelId]];\n    },\n    addMessage: (state, action) => {\n      const {\n        channelId,\n        message\n      } = action.payload;\n\n      // Initialize channel messages array if it doesn't exist\n      if (!state.messagesByChannel[channelId]) {\n        state.messagesByChannel[channelId] = [];\n      }\n\n      // Check if message already exists\n      const existingMessageIndex = state.messagesByChannel[channelId].findIndex(msg => msg.id === message.id);\n      if (existingMessageIndex === -1) {\n        // Add new message if it doesn't exist\n        const newMessage = {\n          ...message,\n          replies: [],\n          repliesLoaded: false,\n          isExpanded: false,\n          replyCount: message.replyCount || 0\n        };\n        state.messagesByChannel[channelId].push(newMessage);\n\n        // Sort messages by creation time\n        state.messagesByChannel[channelId].sort((a, b) => {\n          const timeA = new Date(a.createdAt).getTime();\n          const timeB = new Date(b.createdAt).getTime();\n          return timeA - timeB;\n        });\n\n        // Update parent message if this is a reply\n        if (message.parentId) {\n          const parentMessage = state.messagesByChannel[channelId].find(msg => msg.id === message.parentId);\n          if (parentMessage) {\n            parentMessage.replyCount = (parentMessage.replyCount || 0) + 1;\n            if (!parentMessage.replies) {\n              parentMessage.replies = [];\n            }\n            parentMessage.replies.push(newMessage);\n            // Sort replies by creation time\n            parentMessage.replies.sort((a, b) => {\n              const timeA = new Date(a.createdAt).getTime();\n              const timeB = new Date(b.createdAt).getTime();\n              return timeA - timeB;\n            });\n          }\n        }\n      } else {\n        // Update existing message while preserving its state\n        const existingMessage = state.messagesByChannel[channelId][existingMessageIndex];\n        state.messagesByChannel[channelId][existingMessageIndex] = {\n          ...message,\n          replies: existingMessage.replies || [],\n          repliesLoaded: existingMessage.repliesLoaded || false,\n          isExpanded: existingMessage.isExpanded || false,\n          replyCount: existingMessage.replyCount || 0\n        };\n      }\n    },\n    updateMessage: (state, action) => {\n      const {\n        channelId,\n        id,\n        message\n      } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (!messages) return;\n\n      // First check if it's a main message\n      const index = messages.findIndex(msg => msg.id === id);\n      if (index !== -1) {\n        // Preserve existing state when updating\n        const existingMessage = messages[index];\n        messages[index] = {\n          ...message,\n          replies: existingMessage.replies || [],\n          repliesLoaded: existingMessage.repliesLoaded || false,\n          isExpanded: existingMessage.isExpanded || false,\n          replyCount: existingMessage.replyCount || 0\n        };\n      } else {\n        // Check if it's a reply to any message\n        for (const mainMessage of messages) {\n          if (mainMessage.replies) {\n            const replyIndex = mainMessage.replies.findIndex(reply => reply.id === id);\n            if (replyIndex !== -1) {\n              // Preserve parent ID and other state when updating reply\n              const existingReply = mainMessage.replies[replyIndex];\n              mainMessage.replies[replyIndex] = {\n                ...message,\n                parentId: mainMessage.id,\n                replies: existingReply.replies || [],\n                repliesLoaded: existingReply.repliesLoaded || false,\n                isExpanded: existingReply.isExpanded || false,\n                replyCount: existingReply.replyCount || 0\n              };\n              break;\n            }\n          }\n        }\n      }\n    },\n    deleteMessage: (state, action) => {\n      const {\n        channelId,\n        messageId\n      } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        state.messagesByChannel[channelId] = messages.filter(msg => msg.id !== messageId);\n      }\n    },\n    addReaction: (state, action) => {\n      const {\n        channelId,\n        messageId,\n        reaction\n      } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const message = messages.find(msg => msg.id === messageId);\n        if (message) {\n          // Check if reaction already exists\n          const existingReactionIndex = message.reactions.findIndex(r => r.id === reaction.id || r.emoji === reaction.emoji && r.userId === reaction.userId);\n          if (existingReactionIndex === -1) {\n            message.reactions.push(reaction);\n          }\n        }\n      }\n    },\n    removeReaction: (state, action) => {\n      const {\n        channelId,\n        messageId,\n        reactionId\n      } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const message = messages.find(msg => msg.id === messageId);\n        if (message) {\n          message.reactions = message.reactions.filter(reaction => reaction.id !== reactionId);\n        }\n      }\n    },\n    setReplies: (state, action) => {\n      const {\n        channelId,\n        messageId,\n        replies\n      } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const messageIndex = messages.findIndex(msg => msg.id === messageId);\n        if (messageIndex !== -1) {\n          // Create a new message object with the updated replies\n          const updatedMessage = {\n            ...messages[messageIndex],\n            replies: [...(messages[messageIndex].replies || []), ...replies.filter(reply => {\n              var _messages$messageInde;\n              return !((_messages$messageInde = messages[messageIndex].replies) !== null && _messages$messageInde !== void 0 && _messages$messageInde.some(existingReply => existingReply.id === reply.id));\n            })],\n            repliesLoaded: true,\n            isExpanded: true // Auto-expand when new replies are added\n          };\n\n          // Update reply count\n          updatedMessage.replyCount = updatedMessage.replies.length;\n\n          // Update the message in the array\n          messages[messageIndex] = updatedMessage;\n        }\n      }\n    },\n    toggleExpanded: (state, action) => {\n      const {\n        channelId,\n        messageId\n      } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const message = messages.find(msg => msg.id === messageId);\n        if (message) {\n          message.isExpanded = !message.isExpanded;\n        }\n      }\n    }\n  }\n});\nexport const {\n  setMessages,\n  prependMessages,\n  addMessage,\n  updateMessage,\n  deleteMessage,\n  addReaction,\n  removeReaction,\n  setReplies,\n  toggleExpanded\n} = messagesSlice.actions;\nexport default messagesSlice.reducer;","map":{"version":3,"names":["createSlice","initialState","messagesByChannel","loading","error","messagesSlice","name","reducers","setMessages","state","action","channelId","messages","payload","mainMessages","repliesByParentId","forEach","msg","parentId","push","id","replies","replyCount","length","repliesLoaded","prependMessages","existingIds","Set","map","newMessages","filter","has","addMessage","message","existingMessageIndex","findIndex","newMessage","isExpanded","sort","a","b","timeA","Date","createdAt","getTime","timeB","parentMessage","find","existingMessage","updateMessage","index","mainMessage","replyIndex","reply","existingReply","deleteMessage","messageId","addReaction","reaction","existingReactionIndex","reactions","r","emoji","userId","removeReaction","reactionId","setReplies","messageIndex","updatedMessage","_messages$messageInde","some","toggleExpanded","actions","reducer"],"sources":["Z:/GAUNTLET/projects/SERMO/sermo-app/frontend/src/store/messages/messagesSlice.ts"],"sourcesContent":["import { createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { MessagesState, Reaction, StoreMessage } from '../../types';\n\nconst initialState: MessagesState = {\n  messagesByChannel: {},\n  loading: false,\n  error: null,\n};\n\nconst messagesSlice = createSlice({\n  name: 'messages',\n  initialState,\n  reducers: {\n    setMessages: (state, action: PayloadAction<{ channelId: string; messages: StoreMessage[] }>) => {\n      const { channelId, messages } = action.payload;\n      \n      // Organize messages by parent/reply relationship\n      const mainMessages: StoreMessage[] = [];\n      const repliesByParentId: { [key: string]: StoreMessage[] } = {};\n\n      // First pass: separate messages into main messages and replies\n      messages.forEach(msg => {\n        if (msg.parentId) {\n          // This is a reply\n          if (!repliesByParentId[msg.parentId]) {\n            repliesByParentId[msg.parentId] = [];\n          }\n          repliesByParentId[msg.parentId].push(msg);\n        } else {\n          // This is a main message\n          mainMessages.push(msg);\n        }\n      });\n\n      // Second pass: attach replies to their parent messages\n      mainMessages.forEach(msg => {\n        if (repliesByParentId[msg.id]) {\n          msg.replies = repliesByParentId[msg.id];\n          msg.replyCount = repliesByParentId[msg.id].length;\n          msg.repliesLoaded = true;\n        }\n      });\n\n      // Update the state with organized messages\n      state.messagesByChannel[channelId] = mainMessages;\n      state.loading = false;\n      state.error = null;\n    },\n    prependMessages: (state, action: PayloadAction<{ channelId: string; messages: StoreMessage[] }>) => {\n      const { channelId, messages } = action.payload;\n      if (!state.messagesByChannel[channelId]) {\n        state.messagesByChannel[channelId] = [];\n      }\n      // Add messages to the beginning of the array, avoiding duplicates\n      const existingIds = new Set(state.messagesByChannel[channelId].map(msg => msg.id));\n      const newMessages = messages.filter(msg => !existingIds.has(msg.id));\n      state.messagesByChannel[channelId] = [...newMessages, ...state.messagesByChannel[channelId]];\n    },\n    addMessage: (state, action: PayloadAction<{ channelId: string; message: StoreMessage }>) => {\n      const { channelId, message } = action.payload;\n      \n      // Initialize channel messages array if it doesn't exist\n      if (!state.messagesByChannel[channelId]) {\n        state.messagesByChannel[channelId] = [];\n      }\n\n      // Check if message already exists\n      const existingMessageIndex = state.messagesByChannel[channelId].findIndex(\n        msg => msg.id === message.id\n      );\n\n      if (existingMessageIndex === -1) {\n        // Add new message if it doesn't exist\n        const newMessage = {\n          ...message,\n          replies: [],\n          repliesLoaded: false,\n          isExpanded: false,\n          replyCount: message.replyCount || 0\n        };\n        \n        state.messagesByChannel[channelId].push(newMessage);\n        \n        // Sort messages by creation time\n        state.messagesByChannel[channelId].sort((a, b) => {\n          const timeA = new Date(a.createdAt).getTime();\n          const timeB = new Date(b.createdAt).getTime();\n          return timeA - timeB;\n        });\n\n        // Update parent message if this is a reply\n        if (message.parentId) {\n          const parentMessage = state.messagesByChannel[channelId].find(\n            msg => msg.id === message.parentId\n          );\n          if (parentMessage) {\n            parentMessage.replyCount = (parentMessage.replyCount || 0) + 1;\n            if (!parentMessage.replies) {\n              parentMessage.replies = [];\n            }\n            parentMessage.replies.push(newMessage);\n            // Sort replies by creation time\n            parentMessage.replies.sort((a, b) => {\n              const timeA = new Date(a.createdAt).getTime();\n              const timeB = new Date(b.createdAt).getTime();\n              return timeA - timeB;\n            });\n          }\n        }\n      } else {\n        // Update existing message while preserving its state\n        const existingMessage = state.messagesByChannel[channelId][existingMessageIndex];\n        state.messagesByChannel[channelId][existingMessageIndex] = {\n          ...message,\n          replies: existingMessage.replies || [],\n          repliesLoaded: existingMessage.repliesLoaded || false,\n          isExpanded: existingMessage.isExpanded || false,\n          replyCount: existingMessage.replyCount || 0\n        };\n      }\n    },\n    updateMessage: (state, action: PayloadAction<{ channelId: string; id: string; message: StoreMessage }>) => {\n      const { channelId, id, message } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (!messages) return;\n\n      // First check if it's a main message\n      const index = messages.findIndex((msg: StoreMessage) => msg.id === id);\n      if (index !== -1) {\n        // Preserve existing state when updating\n        const existingMessage = messages[index];\n        messages[index] = {\n          ...message,\n          replies: existingMessage.replies || [],\n          repliesLoaded: existingMessage.repliesLoaded || false,\n          isExpanded: existingMessage.isExpanded || false,\n          replyCount: existingMessage.replyCount || 0\n        };\n      } else {\n        // Check if it's a reply to any message\n        for (const mainMessage of messages) {\n          if (mainMessage.replies) {\n            const replyIndex = mainMessage.replies.findIndex(reply => reply.id === id);\n            if (replyIndex !== -1) {\n              // Preserve parent ID and other state when updating reply\n              const existingReply = mainMessage.replies[replyIndex];\n              mainMessage.replies[replyIndex] = {\n                ...message,\n                parentId: mainMessage.id,\n                replies: existingReply.replies || [],\n                repliesLoaded: existingReply.repliesLoaded || false,\n                isExpanded: existingReply.isExpanded || false,\n                replyCount: existingReply.replyCount || 0\n              };\n              break;\n            }\n          }\n        }\n      }\n    },\n    deleteMessage: (state, action: PayloadAction<{ channelId: string; messageId: string }>) => {\n      const { channelId, messageId } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        state.messagesByChannel[channelId] = messages.filter((msg: StoreMessage) => msg.id !== messageId);\n      }\n    },\n    addReaction: (state, action: PayloadAction<{ channelId: string; messageId: string; reaction: Reaction }>) => {\n      const { channelId, messageId, reaction } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const message = messages.find((msg: StoreMessage) => msg.id === messageId);\n        if (message) {\n          // Check if reaction already exists\n          const existingReactionIndex = message.reactions.findIndex(\n            (r: Reaction) => r.id === reaction.id || (r.emoji === reaction.emoji && r.userId === reaction.userId)\n          );\n          if (existingReactionIndex === -1) {\n            message.reactions.push(reaction);\n          }\n        }\n      }\n    },\n    removeReaction: (state, action: PayloadAction<{ channelId: string; messageId: string; reactionId: string }>) => {\n      const { channelId, messageId, reactionId } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const message = messages.find((msg: StoreMessage) => msg.id === messageId);\n        if (message) {\n          message.reactions = message.reactions.filter((reaction: Reaction) => reaction.id !== reactionId);\n        }\n      }\n    },\n    setReplies: (state, action: PayloadAction<{ channelId: string; messageId: string; replies: StoreMessage[] }>) => {\n      const { channelId, messageId, replies } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const messageIndex = messages.findIndex((msg: StoreMessage) => msg.id === messageId);\n        if (messageIndex !== -1) {\n          // Create a new message object with the updated replies\n          const updatedMessage = {\n            ...messages[messageIndex],\n            replies: [\n              ...(messages[messageIndex].replies || []),\n              ...replies.filter(reply => \n                !messages[messageIndex].replies?.some(existingReply => \n                  existingReply.id === reply.id\n                )\n              )\n            ],\n            repliesLoaded: true,\n            isExpanded: true // Auto-expand when new replies are added\n          };\n          \n          // Update reply count\n          updatedMessage.replyCount = updatedMessage.replies.length;\n          \n          // Update the message in the array\n          messages[messageIndex] = updatedMessage;\n        }\n      }\n    },\n    toggleExpanded: (state, action: PayloadAction<{ channelId: string; messageId: string }>) => {\n      const { channelId, messageId } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const message = messages.find((msg: StoreMessage) => msg.id === messageId);\n        if (message) {\n          message.isExpanded = !message.isExpanded;\n        }\n      }\n    },\n  },\n});\n\nexport const {\n  setMessages,\n  prependMessages,\n  addMessage,\n  updateMessage,\n  deleteMessage,\n  addReaction,\n  removeReaction,\n  setReplies,\n  toggleExpanded\n} = messagesSlice.actions;\n\nexport default messagesSlice.reducer; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}