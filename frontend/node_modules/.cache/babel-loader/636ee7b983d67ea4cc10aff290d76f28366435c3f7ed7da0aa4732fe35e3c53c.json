{"ast":null,"code":"class MessageQueue {\n  constructor() {\n    this.messages = new Map();\n    this.lastSequence = 0;\n    this.STORAGE_KEY = 'ws_message_queue';\n    this.MAX_RETRIES = 3;\n    this.MAX_QUEUE_SIZE = 100;\n    this.loadFromStorage();\n    window.addEventListener('beforeunload', () => this.saveToStorage());\n  }\n  generateId() {\n    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n  loadFromStorage() {\n    try {\n      const stored = localStorage.getItem(this.STORAGE_KEY);\n      if (stored) {\n        const data = JSON.parse(stored);\n        this.messages = new Map(Object.entries(data.messages));\n        this.lastSequence = data.lastSequence;\n      }\n    } catch (error) {\n      console.error('Error loading message queue from storage:', error);\n      // Clear potentially corrupted data\n      this.messages.clear();\n      this.lastSequence = 0;\n    }\n  }\n  saveToStorage() {\n    try {\n      const data = {\n        messages: Object.fromEntries(this.messages),\n        lastSequence: this.lastSequence\n      };\n      localStorage.setItem(this.STORAGE_KEY, JSON.stringify(data));\n    } catch (error) {\n      console.error('Error saving message queue to storage:', error);\n    }\n  }\n  addMessage(channelId, content, type = 'message', parentId) {\n    const messageId = this.generateId();\n    const queuedMessage = {\n      id: messageId,\n      channelId,\n      content,\n      sequence: ++this.lastSequence,\n      timestamp: Date.now(),\n      attempts: 0,\n      type,\n      parentId\n    };\n    if (!this.messages.has(channelId)) {\n      this.messages.set(channelId, []);\n    }\n    const channelMessages = this.messages.get(channelId);\n    channelMessages.push(queuedMessage);\n\n    // Enforce queue size limit\n    if (channelMessages.length > this.MAX_QUEUE_SIZE) {\n      channelMessages.splice(0, channelMessages.length - this.MAX_QUEUE_SIZE);\n    }\n    this.saveToStorage();\n    return messageId;\n  }\n  getNextMessage(channelId) {\n    const channelMessages = this.messages.get(channelId);\n    if (!(channelMessages !== null && channelMessages !== void 0 && channelMessages.length)) return null;\n\n    // Get the oldest message that hasn't exceeded retry limit\n    const message = channelMessages.find(m => m.attempts < this.MAX_RETRIES);\n    if (!message) {\n      // Remove all failed messages\n      this.messages.set(channelId, channelMessages.filter(m => m.attempts < this.MAX_RETRIES));\n      this.saveToStorage();\n      return null;\n    }\n    return message;\n  }\n  markMessageAttempted(channelId, messageId) {\n    const channelMessages = this.messages.get(channelId);\n    if (!channelMessages) return;\n    const message = channelMessages.find(m => m.id === messageId);\n    if (message) {\n      message.attempts++;\n      this.saveToStorage();\n    }\n  }\n  markMessageSent(channelId, messageId) {\n    const channelMessages = this.messages.get(channelId);\n    if (!channelMessages) return;\n    const index = channelMessages.findIndex(m => m.id === messageId);\n    if (index !== -1) {\n      channelMessages.splice(index, 1);\n      this.saveToStorage();\n    }\n  }\n  getQueueLength(channelId) {\n    var _this$messages$get;\n    return ((_this$messages$get = this.messages.get(channelId)) === null || _this$messages$get === void 0 ? void 0 : _this$messages$get.length) || 0;\n  }\n  clear(channelId) {\n    if (channelId) {\n      this.messages.delete(channelId);\n    } else {\n      this.messages.clear();\n    }\n    this.saveToStorage();\n  }\n}\nexport const messageQueue = new MessageQueue();\nexport default messageQueue;","map":{"version":3,"names":["MessageQueue","constructor","messages","Map","lastSequence","STORAGE_KEY","MAX_RETRIES","MAX_QUEUE_SIZE","loadFromStorage","window","addEventListener","saveToStorage","generateId","Date","now","Math","random","toString","substr","stored","localStorage","getItem","data","JSON","parse","Object","entries","error","console","clear","fromEntries","setItem","stringify","addMessage","channelId","content","type","parentId","messageId","queuedMessage","id","sequence","timestamp","attempts","has","set","channelMessages","get","push","length","splice","getNextMessage","message","find","m","filter","markMessageAttempted","markMessageSent","index","findIndex","getQueueLength","_this$messages$get","delete","messageQueue"],"sources":["Z:/GAUNTLET/projects/SERMO/sermo-app/frontend/src/services/websocket/messageQueue.ts"],"sourcesContent":["import { WebSocketMessage } from '../../types';\n\ninterface QueuedMessage {\n  id: string;\n  channelId: string;\n  content: string;\n  sequence: number;\n  timestamp: number;\n  attempts: number;\n  type: 'message' | 'reply';\n  parentId?: string;\n}\n\nclass MessageQueue {\n  private messages: Map<string, QueuedMessage[]> = new Map();\n  private lastSequence: number = 0;\n  private readonly STORAGE_KEY = 'ws_message_queue';\n  private readonly MAX_RETRIES = 3;\n  private readonly MAX_QUEUE_SIZE = 100;\n\n  constructor() {\n    this.loadFromStorage();\n    window.addEventListener('beforeunload', () => this.saveToStorage());\n  }\n\n  private generateId(): string {\n    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private loadFromStorage(): void {\n    try {\n      const stored = localStorage.getItem(this.STORAGE_KEY);\n      if (stored) {\n        const data = JSON.parse(stored);\n        this.messages = new Map(Object.entries(data.messages));\n        this.lastSequence = data.lastSequence;\n      }\n    } catch (error) {\n      console.error('Error loading message queue from storage:', error);\n      // Clear potentially corrupted data\n      this.messages.clear();\n      this.lastSequence = 0;\n    }\n  }\n\n  private saveToStorage(): void {\n    try {\n      const data = {\n        messages: Object.fromEntries(this.messages),\n        lastSequence: this.lastSequence\n      };\n      localStorage.setItem(this.STORAGE_KEY, JSON.stringify(data));\n    } catch (error) {\n      console.error('Error saving message queue to storage:', error);\n    }\n  }\n\n  addMessage(channelId: string, content: string, type: 'message' | 'reply' = 'message', parentId?: string): string {\n    const messageId = this.generateId();\n    const queuedMessage: QueuedMessage = {\n      id: messageId,\n      channelId,\n      content,\n      sequence: ++this.lastSequence,\n      timestamp: Date.now(),\n      attempts: 0,\n      type,\n      parentId\n    };\n\n    if (!this.messages.has(channelId)) {\n      this.messages.set(channelId, []);\n    }\n\n    const channelMessages = this.messages.get(channelId)!;\n    channelMessages.push(queuedMessage);\n    \n    // Enforce queue size limit\n    if (channelMessages.length > this.MAX_QUEUE_SIZE) {\n      channelMessages.splice(0, channelMessages.length - this.MAX_QUEUE_SIZE);\n    }\n    \n    this.saveToStorage();\n    return messageId;\n  }\n\n  getNextMessage(channelId: string): QueuedMessage | null {\n    const channelMessages = this.messages.get(channelId);\n    if (!channelMessages?.length) return null;\n\n    // Get the oldest message that hasn't exceeded retry limit\n    const message = channelMessages.find(m => m.attempts < this.MAX_RETRIES);\n    if (!message) {\n      // Remove all failed messages\n      this.messages.set(channelId, channelMessages.filter(m => m.attempts < this.MAX_RETRIES));\n      this.saveToStorage();\n      return null;\n    }\n\n    return message;\n  }\n\n  markMessageAttempted(channelId: string, messageId: string): void {\n    const channelMessages = this.messages.get(channelId);\n    if (!channelMessages) return;\n\n    const message = channelMessages.find(m => m.id === messageId);\n    if (message) {\n      message.attempts++;\n      this.saveToStorage();\n    }\n  }\n\n  markMessageSent(channelId: string, messageId: string): void {\n    const channelMessages = this.messages.get(channelId);\n    if (!channelMessages) return;\n\n    const index = channelMessages.findIndex(m => m.id === messageId);\n    if (index !== -1) {\n      channelMessages.splice(index, 1);\n      this.saveToStorage();\n    }\n  }\n\n  getQueueLength(channelId: string): number {\n    return this.messages.get(channelId)?.length || 0;\n  }\n\n  clear(channelId?: string): void {\n    if (channelId) {\n      this.messages.delete(channelId);\n    } else {\n      this.messages.clear();\n    }\n    this.saveToStorage();\n  }\n}\n\nexport const messageQueue = new MessageQueue();\nexport default messageQueue; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}