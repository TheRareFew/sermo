{"ast":null,"code":"import { getAuthToken } from '../api/auth';\n\n// Add WebSocket message types\n\nclass WebSocketService {\n  constructor() {\n    this.socket = null;\n    this.messageHandlers = [];\n    this.errorHandlers = [];\n    this.currentChannelId = null;\n    this.joinedChannels = new Set();\n    this.messageQueue = [];\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectTimeout = null;\n    this.isReconnecting = false;\n    this.connectionPromise = null;\n    this.joinPromise = null;\n    this.lastMessageId = null;\n    this.processingQueue = false;\n    // Update message handler to track last message ID\n    this.handleWebSocketMessage = event => {\n      try {\n        const message = JSON.parse(event.data);\n        if (message.type === 'message' || message.type === 'message_sent') {\n          this.lastMessageId = message.message.id;\n        }\n        this.messageHandlers.forEach(handler => {\n          try {\n            handler(message);\n          } catch (error) {\n            console.error('Error in message handler:', error);\n          }\n        });\n      } catch (error) {\n        console.error('Error parsing WebSocket message:', error);\n      }\n    };\n  }\n  async connect(channelId) {\n    if (this.isConnected() && this.isConnectedToChannel(channelId)) {\n      return;\n    }\n    if (this.connectionPromise) {\n      await this.connectionPromise;\n      if (this.isConnected() && this.isConnectedToChannel(channelId)) {\n        return;\n      }\n    }\n    this.disconnect();\n    this.currentChannelId = channelId;\n    this.isReconnecting = false;\n    this.reconnectAttempts = 0;\n    try {\n      this.connectionPromise = new Promise((resolve, reject) => {\n        const token = getAuthToken();\n        if (!token) {\n          reject(new Error('No authentication token found'));\n          return;\n        }\n        this.socket = new WebSocket(`ws://localhost:8000/ws/chat?token=${token}`);\n        let resolved = false;\n        const connectionTimeout = setTimeout(() => {\n          if (!resolved) {\n            var _this$socket;\n            (_this$socket = this.socket) === null || _this$socket === void 0 ? void 0 : _this$socket.close();\n            reject(new Error('WebSocket connection timeout'));\n          }\n        }, 5000);\n        this.socket.onopen = () => {\n          var _this$socket2;\n          if (((_this$socket2 = this.socket) === null || _this$socket2 === void 0 ? void 0 : _this$socket2.readyState) === WebSocket.OPEN) {\n            clearTimeout(connectionTimeout);\n            this.reconnectAttempts = 0;\n            this.isReconnecting = false;\n            resolved = true;\n            resolve();\n          }\n        };\n        this.socket.onclose = event => {\n          if (!resolved) {\n            clearTimeout(connectionTimeout);\n            reject(new Error('WebSocket closed before connection established'));\n            return;\n          }\n          if (this.socket === null) return;\n          const wasConnected = this.socket.readyState === WebSocket.OPEN;\n          this.socket = null;\n          this.joinedChannels.clear();\n          if (event.code !== 1000 && wasConnected) {\n            if (!this.isReconnecting && this.reconnectAttempts < this.maxReconnectAttempts) {\n              this.attemptReconnect();\n            }\n          }\n        };\n        this.socket.onerror = error => {\n          if (!resolved) {\n            clearTimeout(connectionTimeout);\n            reject(error);\n            return;\n          }\n          this.handleError(new Error('WebSocket connection error'));\n        };\n        this.socket.onmessage = this.handleWebSocketMessage;\n      });\n      await this.connectionPromise;\n      await this.joinChannel(channelId);\n    } catch (error) {\n      this.handleError(error instanceof Error ? error : new Error('WebSocket connection failed'));\n      throw error;\n    } finally {\n      this.connectionPromise = null;\n    }\n  }\n  async joinChannel(channelId) {\n    if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {\n      throw new Error('Cannot join channel: WebSocket is not connected');\n    }\n    if (this.isConnectedToChannel(channelId)) {\n      return;\n    }\n    return new Promise((resolve, reject) => {\n      const joinMessage = {\n        type: 'join_channel',\n        channel_id: channelId\n      };\n      const joinTimeout = setTimeout(() => reject(new Error('Channel join timeout')), 5000);\n      const handleJoinResponse = event => {\n        try {\n          const data = JSON.parse(event.data);\n          if (data.type === 'channel_joined' && data.channel_id === channelId && this.socket) {\n            this.socket.removeEventListener('message', handleJoinResponse);\n            clearTimeout(joinTimeout);\n            this.joinedChannels.add(channelId);\n            resolve();\n          }\n        } catch (error) {}\n      };\n      if (this.socket) {\n        this.socket.addEventListener('message', handleJoinResponse);\n        this.socket.send(JSON.stringify(joinMessage));\n      } else {\n        reject(new Error('WebSocket not available'));\n      }\n    });\n  }\n  handleError(error) {\n    console.error('WebSocket error:', error);\n    this.errorHandlers.forEach(handler => handler(error));\n  }\n  isConnected() {\n    return this.socket !== null && this.socket.readyState === WebSocket.OPEN;\n  }\n  isConnectedToChannel(channelId) {\n    return this.isConnected() && this.joinedChannels.has(channelId) && this.currentChannelId === channelId;\n  }\n  onMessage(handler) {\n    this.messageHandlers.push(handler);\n    return () => {\n      this.messageHandlers = this.messageHandlers.filter(h => h !== handler);\n    };\n  }\n  onError(handler) {\n    this.errorHandlers.push(handler);\n    return () => {\n      this.errorHandlers = this.errorHandlers.filter(h => h !== handler);\n    };\n  }\n  disconnect() {\n    this.isReconnecting = false;\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\n      this.socket.close(1000);\n    }\n    this.socket = null;\n    this.joinedChannels.clear();\n    this.messageHandlers = [];\n    this.errorHandlers = [];\n    this.reconnectAttempts = 0;\n    this.connectionPromise = null;\n    this.joinPromise = null;\n  }\n  async processMessageQueue() {\n    if (this.processingQueue || this.messageQueue.length === 0) return;\n    this.processingQueue = true;\n    console.log(`Processing message queue (${this.messageQueue.length} messages)`);\n    while (this.messageQueue.length > 0) {\n      const message = this.messageQueue[0];\n      try {\n        if (this.isConnectedToChannel(message.channelId)) {\n          await this.sendMessage(message.channelId, message.content);\n          this.messageQueue.shift(); // Remove the successfully sent message\n        } else {\n          // If we're not connected to the channel, try to connect\n          try {\n            await this.connect(message.channelId);\n          } catch (error) {\n            console.error('Failed to connect while processing queue:', error);\n            break; // Stop processing if we can't connect\n          }\n        }\n      } catch (error) {\n        console.error('Failed to send queued message:', error);\n        // If sending fails, leave the message in the queue and try again later\n        break;\n      }\n    }\n    this.processingQueue = false;\n  }\n  async sendMessage(channelId, content) {\n    if (!this.isConnectedToChannel(channelId)) {\n      this.messageQueue.push({\n        channelId,\n        content\n      });\n      try {\n        await this.connect(channelId);\n        await this.processMessageQueue();\n        return;\n      } catch (error) {\n        console.error('Failed to connect while sending message:', error);\n        throw error;\n      }\n    }\n    const message = {\n      type: 'message',\n      channel_id: channelId,\n      content: content,\n      last_message_id: this.lastMessageId\n    };\n    try {\n      var _this$socket3;\n      if (((_this$socket3 = this.socket) === null || _this$socket3 === void 0 ? void 0 : _this$socket3.readyState) === WebSocket.OPEN) {\n        this.socket.send(JSON.stringify(message));\n      } else {\n        this.messageQueue.push({\n          channelId,\n          content\n        });\n        await this.connect(channelId);\n      }\n    } catch (error) {\n      console.error('Failed to send message:', error);\n      this.messageQueue.push({\n        channelId,\n        content\n      });\n      throw error;\n    }\n  }\n  async attemptReconnect() {\n    if (this.isReconnecting || this.reconnectAttempts >= this.maxReconnectAttempts) {\n      console.log('Skipping reconnect: already reconnecting or max attempts reached');\n      return;\n    }\n    this.isReconnecting = true;\n    this.reconnectAttempts++;\n    console.log(`Attempting to reconnect (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})...`);\n    if (this.currentChannelId) {\n      const backoffTime = Math.min(1000 * Math.pow(2, this.reconnectAttempts - 1), 10000);\n      if (this.reconnectTimeout) {\n        clearTimeout(this.reconnectTimeout);\n      }\n      this.reconnectTimeout = setTimeout(async () => {\n        try {\n          await this.connect(this.currentChannelId);\n          this.isReconnecting = false;\n          // Process any queued messages after successful reconnection\n          await this.processMessageQueue();\n        } catch (error) {\n          console.error('Reconnection failed:', error);\n          if (this.reconnectAttempts < this.maxReconnectAttempts) {\n            this.isReconnecting = false; // Reset flag to allow next attempt\n            this.attemptReconnect();\n          } else {\n            console.log('Max reconnection attempts reached');\n            this.isReconnecting = false;\n            this.handleError(new Error('Failed to reconnect after maximum attempts'));\n          }\n        }\n      }, backoffTime);\n    } else {\n      this.isReconnecting = false;\n    }\n  }\n  getChatSocketState() {\n    var _this$socket4;\n    return ((_this$socket4 = this.socket) === null || _this$socket4 === void 0 ? void 0 : _this$socket4.readyState) || WebSocket.CLOSED;\n  }\n}\nconst wsService = new WebSocketService();\nexport default wsService;","map":{"version":3,"names":["getAuthToken","WebSocketService","constructor","socket","messageHandlers","errorHandlers","currentChannelId","joinedChannels","Set","messageQueue","reconnectAttempts","maxReconnectAttempts","reconnectTimeout","isReconnecting","connectionPromise","joinPromise","lastMessageId","processingQueue","handleWebSocketMessage","event","message","JSON","parse","data","type","id","forEach","handler","error","console","connect","channelId","isConnected","isConnectedToChannel","disconnect","Promise","resolve","reject","token","Error","WebSocket","resolved","connectionTimeout","setTimeout","_this$socket","close","onopen","_this$socket2","readyState","OPEN","clearTimeout","onclose","wasConnected","clear","code","attemptReconnect","onerror","handleError","onmessage","joinChannel","joinMessage","channel_id","joinTimeout","handleJoinResponse","removeEventListener","add","addEventListener","send","stringify","has","onMessage","push","filter","h","onError","processMessageQueue","length","log","sendMessage","content","shift","last_message_id","_this$socket3","backoffTime","Math","min","pow","getChatSocketState","_this$socket4","CLOSED","wsService"],"sources":["Z:/GAUNTLET/projects/SERMO/sermo-app/frontend/src/services/websocket/index.ts"],"sourcesContent":["import { WebSocketMessage, WebSocketChannelJoinMessage, WebSocketChannelMessage, StoreMessage } from '../../types';\r\nimport { getAuthToken } from '../api/auth';\r\nimport { store } from '../../store';\r\nimport { addMessage, setReplies } from '../../store/messages/messagesSlice';\r\n\r\n// Add WebSocket message types\r\ninterface WebSocketJoinMessage {\r\n  type: 'join_channel';\r\n  channel_id: string;\r\n}\r\n\r\ninterface WebSocketJoinResponse {\r\n  type: 'channel_joined' | 'channel_join_error';\r\n  channelId: string;\r\n  error?: string;\r\n}\r\n\r\nclass WebSocketService {\r\n  private socket: WebSocket | null = null;\r\n  private messageHandlers: ((message: WebSocketMessage) => void)[] = [];\r\n  private errorHandlers: ((error: Error) => void)[] = [];\r\n  private currentChannelId: string | null = null;\r\n  private joinedChannels: Set<string> = new Set();\r\n  private messageQueue: { channelId: string; content: string }[] = [];\r\n  private reconnectAttempts = 0;\r\n  private maxReconnectAttempts = 5;\r\n  private reconnectTimeout: NodeJS.Timeout | null = null;\r\n  private isReconnecting = false;\r\n  private connectionPromise: Promise<void> | null = null;\r\n  private joinPromise: Promise<void> | null = null;\r\n  private lastMessageId: string | null = null;\r\n  private processingQueue = false;\r\n\r\n  public async connect(channelId: string): Promise<void> {\r\n    if (this.isConnected() && this.isConnectedToChannel(channelId)) {\r\n      return;\r\n    }\r\n\r\n    if (this.connectionPromise) {\r\n      await this.connectionPromise;\r\n      if (this.isConnected() && this.isConnectedToChannel(channelId)) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    this.disconnect();\r\n    this.currentChannelId = channelId;\r\n    this.isReconnecting = false;\r\n    this.reconnectAttempts = 0;\r\n    \r\n    try {\r\n      this.connectionPromise = new Promise((resolve, reject) => {\r\n        const token = getAuthToken();\r\n        if (!token) {\r\n          reject(new Error('No authentication token found'));\r\n          return;\r\n        }\r\n\r\n        this.socket = new WebSocket(`ws://localhost:8000/ws/chat?token=${token}`);\r\n        let resolved = false;\r\n\r\n        const connectionTimeout = setTimeout(() => {\r\n          if (!resolved) {\r\n            this.socket?.close();\r\n            reject(new Error('WebSocket connection timeout'));\r\n          }\r\n        }, 5000);\r\n\r\n        this.socket.onopen = () => {\r\n          if (this.socket?.readyState === WebSocket.OPEN) {\r\n            clearTimeout(connectionTimeout);\r\n            this.reconnectAttempts = 0;\r\n            this.isReconnecting = false;\r\n            resolved = true;\r\n            resolve();\r\n          }\r\n        };\r\n\r\n        this.socket.onclose = (event) => {\r\n          if (!resolved) {\r\n            clearTimeout(connectionTimeout);\r\n            reject(new Error('WebSocket closed before connection established'));\r\n            return;\r\n          }\r\n\r\n          if (this.socket === null) return;\r\n          \r\n          const wasConnected = this.socket.readyState === WebSocket.OPEN;\r\n          this.socket = null;\r\n          this.joinedChannels.clear();\r\n\r\n          if (event.code !== 1000 && wasConnected) {\r\n            if (!this.isReconnecting && this.reconnectAttempts < this.maxReconnectAttempts) {\r\n              this.attemptReconnect();\r\n            }\r\n          }\r\n        };\r\n\r\n        this.socket.onerror = (error) => {\r\n          if (!resolved) {\r\n            clearTimeout(connectionTimeout);\r\n            reject(error);\r\n            return;\r\n          }\r\n          this.handleError(new Error('WebSocket connection error'));\r\n        };\r\n\r\n        this.socket.onmessage = this.handleWebSocketMessage;\r\n      });\r\n\r\n      await this.connectionPromise;\r\n      await this.joinChannel(channelId);\r\n      \r\n    } catch (error) {\r\n      this.handleError(error instanceof Error ? error : new Error('WebSocket connection failed'));\r\n      throw error;\r\n    } finally {\r\n      this.connectionPromise = null;\r\n    }\r\n  }\r\n\r\n  public async joinChannel(channelId: string): Promise<void> {\r\n    if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {\r\n      throw new Error('Cannot join channel: WebSocket is not connected');\r\n    }\r\n\r\n    if (this.isConnectedToChannel(channelId)) {\r\n      return;\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const joinMessage = { type: 'join_channel', channel_id: channelId };\r\n      const joinTimeout = setTimeout(() => reject(new Error('Channel join timeout')), 5000);\r\n      \r\n      const handleJoinResponse = (event: MessageEvent) => {\r\n        try {\r\n          const data = JSON.parse(event.data);\r\n          if (data.type === 'channel_joined' && data.channel_id === channelId && this.socket) {\r\n            this.socket.removeEventListener('message', handleJoinResponse);\r\n            clearTimeout(joinTimeout);\r\n            this.joinedChannels.add(channelId);\r\n            resolve();\r\n          }\r\n        } catch (error) {}\r\n      };\r\n\r\n      if (this.socket) {\r\n        this.socket.addEventListener('message', handleJoinResponse);\r\n        this.socket.send(JSON.stringify(joinMessage));\r\n      } else {\r\n        reject(new Error('WebSocket not available'));\r\n      }\r\n    });\r\n  }\r\n\r\n  private handleError(error: Error): void {\r\n    console.error('WebSocket error:', error);\r\n    this.errorHandlers.forEach(handler => handler(error));\r\n  }\r\n\r\n  public isConnected(): boolean {\r\n    return this.socket !== null && this.socket.readyState === WebSocket.OPEN;\r\n  }\r\n\r\n  private isConnectedToChannel(channelId: string): boolean {\r\n    return this.isConnected() && this.joinedChannels.has(channelId) && this.currentChannelId === channelId;\r\n  }\r\n\r\n  public onMessage(handler: (message: WebSocketMessage) => void): () => void {\r\n    this.messageHandlers.push(handler);\r\n    return () => {\r\n      this.messageHandlers = this.messageHandlers.filter(h => h !== handler);\r\n    };\r\n  }\r\n\r\n  public onError(handler: (error: Error) => void): () => void {\r\n    this.errorHandlers.push(handler);\r\n    return () => {\r\n      this.errorHandlers = this.errorHandlers.filter(h => h !== handler);\r\n    };\r\n  }\r\n\r\n  public disconnect(): void {\r\n    this.isReconnecting = false;\r\n    if (this.reconnectTimeout) {\r\n      clearTimeout(this.reconnectTimeout);\r\n      this.reconnectTimeout = null;\r\n    }\r\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\r\n      this.socket.close(1000);\r\n    }\r\n    this.socket = null;\r\n    this.joinedChannels.clear();\r\n    this.messageHandlers = [];\r\n    this.errorHandlers = [];\r\n    this.reconnectAttempts = 0;\r\n    this.connectionPromise = null;\r\n    this.joinPromise = null;\r\n  }\r\n\r\n  private async processMessageQueue(): Promise<void> {\r\n    if (this.processingQueue || this.messageQueue.length === 0) return;\r\n\r\n    this.processingQueue = true;\r\n    console.log(`Processing message queue (${this.messageQueue.length} messages)`);\r\n\r\n    while (this.messageQueue.length > 0) {\r\n      const message = this.messageQueue[0];\r\n      \r\n      try {\r\n        if (this.isConnectedToChannel(message.channelId)) {\r\n          await this.sendMessage(message.channelId, message.content);\r\n          this.messageQueue.shift(); // Remove the successfully sent message\r\n        } else {\r\n          // If we're not connected to the channel, try to connect\r\n          try {\r\n            await this.connect(message.channelId);\r\n          } catch (error) {\r\n            console.error('Failed to connect while processing queue:', error);\r\n            break; // Stop processing if we can't connect\r\n          }\r\n        }\r\n      } catch (error) {\r\n        console.error('Failed to send queued message:', error);\r\n        // If sending fails, leave the message in the queue and try again later\r\n        break;\r\n      }\r\n    }\r\n\r\n    this.processingQueue = false;\r\n  }\r\n\r\n  public async sendMessage(channelId: string, content: string): Promise<void> {\r\n    if (!this.isConnectedToChannel(channelId)) {\r\n      this.messageQueue.push({ channelId, content });\r\n      \r\n      try {\r\n        await this.connect(channelId);\r\n        await this.processMessageQueue();\r\n        return;\r\n      } catch (error) {\r\n        console.error('Failed to connect while sending message:', error);\r\n        throw error;\r\n      }\r\n    }\r\n\r\n    const message = {\r\n      type: 'message',\r\n      channel_id: channelId,\r\n      content: content,\r\n      last_message_id: this.lastMessageId\r\n    };\r\n\r\n    try {\r\n      if (this.socket?.readyState === WebSocket.OPEN) {\r\n        this.socket.send(JSON.stringify(message));\r\n      } else {\r\n        this.messageQueue.push({ channelId, content });\r\n        await this.connect(channelId);\r\n      }\r\n    } catch (error) {\r\n      console.error('Failed to send message:', error);\r\n      this.messageQueue.push({ channelId, content });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  private async attemptReconnect(): Promise<void> {\r\n    if (this.isReconnecting || this.reconnectAttempts >= this.maxReconnectAttempts) {\r\n      console.log('Skipping reconnect: already reconnecting or max attempts reached');\r\n      return;\r\n    }\r\n\r\n    this.isReconnecting = true;\r\n    this.reconnectAttempts++;\r\n\r\n    console.log(`Attempting to reconnect (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})...`);\r\n\r\n    if (this.currentChannelId) {\r\n      const backoffTime = Math.min(1000 * Math.pow(2, this.reconnectAttempts - 1), 10000);\r\n      \r\n      if (this.reconnectTimeout) {\r\n        clearTimeout(this.reconnectTimeout);\r\n      }\r\n\r\n      this.reconnectTimeout = setTimeout(async () => {\r\n        try {\r\n          await this.connect(this.currentChannelId!);\r\n          this.isReconnecting = false;\r\n          // Process any queued messages after successful reconnection\r\n          await this.processMessageQueue();\r\n        } catch (error) {\r\n          console.error('Reconnection failed:', error);\r\n          if (this.reconnectAttempts < this.maxReconnectAttempts) {\r\n            this.isReconnecting = false; // Reset flag to allow next attempt\r\n            this.attemptReconnect();\r\n          } else {\r\n            console.log('Max reconnection attempts reached');\r\n            this.isReconnecting = false;\r\n            this.handleError(new Error('Failed to reconnect after maximum attempts'));\r\n          }\r\n        }\r\n      }, backoffTime);\r\n    } else {\r\n      this.isReconnecting = false;\r\n    }\r\n  }\r\n\r\n  public getChatSocketState(): number {\r\n    return this.socket?.readyState || WebSocket.CLOSED;\r\n  }\r\n\r\n  // Update message handler to track last message ID\r\n  private handleWebSocketMessage = (event: MessageEvent) => {\r\n    try {\r\n      const message = JSON.parse(event.data) as WebSocketMessage;\r\n      if (message.type === 'message' || message.type === 'message_sent') {\r\n        this.lastMessageId = message.message.id;\r\n      }\r\n      this.messageHandlers.forEach(handler => {\r\n        try {\r\n          handler(message);\r\n        } catch (error) {\r\n          console.error('Error in message handler:', error);\r\n        }\r\n      });\r\n    } catch (error) {\r\n      console.error('Error parsing WebSocket message:', error);\r\n    }\r\n  };\r\n}\r\n\r\nconst wsService = new WebSocketService();\r\nexport default wsService; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}