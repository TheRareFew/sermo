{"ast":null,"code":"import { createSlice } from '@reduxjs/toolkit';\nconst initialState = {\n  messagesByChannel: {},\n  loading: false,\n  error: null\n};\nconst messagesSlice = createSlice({\n  name: 'messages',\n  initialState,\n  reducers: {\n    setMessages: (state, action) => {\n      const {\n        channelId,\n        messages\n      } = action.payload;\n\n      // Organize messages by parent/reply relationship\n      const mainMessages = [];\n      const repliesByParentId = {};\n\n      // First pass: separate messages into main messages and replies\n      messages.forEach(msg => {\n        if (msg.parentId) {\n          // This is a reply\n          if (!repliesByParentId[msg.parentId]) {\n            repliesByParentId[msg.parentId] = [];\n          }\n          repliesByParentId[msg.parentId].push(msg);\n        } else {\n          // This is a main message\n          mainMessages.push(msg);\n        }\n      });\n\n      // Second pass: attach replies to their parent messages\n      mainMessages.forEach(msg => {\n        if (repliesByParentId[msg.id]) {\n          msg.replies = repliesByParentId[msg.id];\n          msg.replyCount = repliesByParentId[msg.id].length;\n          msg.repliesLoaded = true;\n        }\n      });\n\n      // Update the state with organized messages\n      state.messagesByChannel[channelId] = mainMessages;\n      state.loading = false;\n      state.error = null;\n    },\n    prependMessages: (state, action) => {\n      const {\n        channelId,\n        messages\n      } = action.payload;\n      if (!state.messagesByChannel[channelId]) {\n        state.messagesByChannel[channelId] = [];\n      }\n      // Add messages to the beginning of the array, avoiding duplicates\n      const existingIds = new Set(state.messagesByChannel[channelId].map(msg => msg.id));\n      const newMessages = messages.filter(msg => !existingIds.has(msg.id));\n      state.messagesByChannel[channelId] = [...newMessages, ...state.messagesByChannel[channelId]];\n    },\n    addMessage: (state, action) => {\n      const {\n        channelId,\n        message\n      } = action.payload;\n      if (!state.messagesByChannel[channelId]) {\n        state.messagesByChannel[channelId] = [];\n      }\n\n      // If it's a reply, add it to the parent's replies\n      if (message.parentId) {\n        const parentMessage = state.messagesByChannel[channelId].find(m => m.id === message.parentId);\n        if (parentMessage) {\n          if (!parentMessage.replies) {\n            parentMessage.replies = [];\n          }\n          parentMessage.replies.push(message);\n          parentMessage.replyCount = (parentMessage.replyCount || 0) + 1;\n          parentMessage.repliesLoaded = true;\n        }\n      } else {\n        // Add as a main message\n        state.messagesByChannel[channelId].push(message);\n      }\n    },\n    updateMessage: (state, action) => {\n      const {\n        channelId,\n        message\n      } = action.payload;\n      if (!state.messagesByChannel[channelId]) return;\n\n      // Update main message\n      const messageIndex = state.messagesByChannel[channelId].findIndex(m => m.id === message.id);\n      if (messageIndex !== -1) {\n        // Preserve replies and expanded state\n        const existingMessage = state.messagesByChannel[channelId][messageIndex];\n        state.messagesByChannel[channelId][messageIndex] = {\n          ...message,\n          replies: existingMessage.replies || [],\n          isExpanded: existingMessage.isExpanded || false,\n          repliesLoaded: existingMessage.repliesLoaded || false,\n          replyCount: existingMessage.replyCount || 0\n        };\n        return;\n      }\n\n      // Update reply\n      state.messagesByChannel[channelId].forEach(mainMessage => {\n        if (mainMessage.replies) {\n          const replyIndex = mainMessage.replies.findIndex(r => r.id === message.id);\n          if (replyIndex !== -1) {\n            mainMessage.replies[replyIndex] = {\n              ...message,\n              parentId: mainMessage.id\n            };\n          }\n        }\n      });\n    },\n    deleteMessage: (state, action) => {\n      const {\n        channelId,\n        messageId\n      } = action.payload;\n      if (!state.messagesByChannel[channelId]) return;\n\n      // Delete main message\n      state.messagesByChannel[channelId] = state.messagesByChannel[channelId].filter(m => m.id !== messageId);\n\n      // Delete reply and update reply count\n      state.messagesByChannel[channelId].forEach(mainMessage => {\n        if (mainMessage.replies) {\n          const originalLength = mainMessage.replies.length;\n          mainMessage.replies = mainMessage.replies.filter(r => r.id !== messageId);\n          if (mainMessage.replies.length !== originalLength) {\n            mainMessage.replyCount = mainMessage.replies.length;\n          }\n        }\n      });\n    },\n    addReaction: (state, action) => {\n      const {\n        channelId,\n        messageId,\n        reaction\n      } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const message = messages.find(msg => msg.id === messageId);\n        if (message) {\n          // Check if reaction already exists\n          const existingReactionIndex = message.reactions.findIndex(r => r.id === reaction.id || r.emoji === reaction.emoji && r.userId === reaction.userId);\n          if (existingReactionIndex === -1) {\n            message.reactions.push(reaction);\n          }\n        }\n      }\n    },\n    removeReaction: (state, action) => {\n      const {\n        channelId,\n        messageId,\n        reactionId\n      } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const message = messages.find(msg => msg.id === messageId);\n        if (message) {\n          message.reactions = message.reactions.filter(reaction => reaction.id !== reactionId);\n        }\n      }\n    },\n    setReplies: (state, action) => {\n      const {\n        channelId,\n        parentMessageId,\n        replies\n      } = action.payload;\n      if (!state.messagesByChannel[channelId]) return;\n      const parentMessage = state.messagesByChannel[channelId].find(m => m.id === parentMessageId);\n      if (parentMessage) {\n        if (!parentMessage.replies) {\n          parentMessage.replies = [];\n        }\n        // Append new replies while preserving existing ones\n        const newReplies = replies.filter(reply => {\n          var _parentMessage$replie;\n          return !((_parentMessage$replie = parentMessage.replies) !== null && _parentMessage$replie !== void 0 && _parentMessage$replie.some(existing => existing.id === reply.id));\n        });\n        parentMessage.replies = [...parentMessage.replies, ...newReplies];\n        parentMessage.replyCount = parentMessage.replies.length;\n        parentMessage.repliesLoaded = true;\n      }\n    },\n    toggleExpanded: (state, action) => {\n      const {\n        channelId,\n        messageId\n      } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const message = messages.find(msg => msg.id === messageId);\n        if (message) {\n          message.isExpanded = !message.isExpanded;\n        }\n      }\n    },\n    setExpanded: (state, action) => {\n      const {\n        channelId,\n        messageId,\n        expanded\n      } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const message = messages.find(msg => msg.id === messageId);\n        if (message) {\n          message.isExpanded = expanded;\n        }\n      }\n    },\n    addReply: (state, action) => {\n      const {\n        channelId,\n        parentMessageId,\n        reply\n      } = action.payload;\n      const channelMessages = state.messagesByChannel[channelId];\n      if (channelMessages) {\n        const parentMessage = channelMessages.find(msg => msg.id === parentMessageId);\n        if (parentMessage) {\n          if (!parentMessage.replies) {\n            parentMessage.replies = [];\n          }\n          parentMessage.replies.push(reply);\n          parentMessage.replyCount = (parentMessage.replyCount || 0) + 1;\n        }\n      }\n    }\n  }\n});\nexport const {\n  setMessages,\n  prependMessages,\n  addMessage,\n  updateMessage,\n  deleteMessage,\n  addReaction,\n  removeReaction,\n  setReplies,\n  toggleExpanded,\n  setExpanded,\n  addReply\n} = messagesSlice.actions;\nexport default messagesSlice.reducer;","map":{"version":3,"names":["createSlice","initialState","messagesByChannel","loading","error","messagesSlice","name","reducers","setMessages","state","action","channelId","messages","payload","mainMessages","repliesByParentId","forEach","msg","parentId","push","id","replies","replyCount","length","repliesLoaded","prependMessages","existingIds","Set","map","newMessages","filter","has","addMessage","message","parentMessage","find","m","updateMessage","messageIndex","findIndex","existingMessage","isExpanded","mainMessage","replyIndex","r","deleteMessage","messageId","originalLength","addReaction","reaction","existingReactionIndex","reactions","emoji","userId","removeReaction","reactionId","setReplies","parentMessageId","newReplies","reply","_parentMessage$replie","some","existing","toggleExpanded","setExpanded","expanded","addReply","channelMessages","actions","reducer"],"sources":["Z:/GAUNTLET/projects/SERMO/sermo-app/frontend/src/store/messages/messagesSlice.ts"],"sourcesContent":["import { createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { MessagesState, Reaction, StoreMessage } from '../../types';\n\nconst initialState: MessagesState = {\n  messagesByChannel: {},\n  loading: false,\n  error: null,\n};\n\nconst messagesSlice = createSlice({\n  name: 'messages',\n  initialState,\n  reducers: {\n    setMessages: (state, action: PayloadAction<{ channelId: string; messages: StoreMessage[] }>) => {\n      const { channelId, messages } = action.payload;\n      \n      // Organize messages by parent/reply relationship\n      const mainMessages: StoreMessage[] = [];\n      const repliesByParentId: { [key: string]: StoreMessage[] } = {};\n\n      // First pass: separate messages into main messages and replies\n      messages.forEach(msg => {\n        if (msg.parentId) {\n          // This is a reply\n          if (!repliesByParentId[msg.parentId]) {\n            repliesByParentId[msg.parentId] = [];\n          }\n          repliesByParentId[msg.parentId].push(msg);\n        } else {\n          // This is a main message\n          mainMessages.push(msg);\n        }\n      });\n\n      // Second pass: attach replies to their parent messages\n      mainMessages.forEach(msg => {\n        if (repliesByParentId[msg.id]) {\n          msg.replies = repliesByParentId[msg.id];\n          msg.replyCount = repliesByParentId[msg.id].length;\n          msg.repliesLoaded = true;\n        }\n      });\n\n      // Update the state with organized messages\n      state.messagesByChannel[channelId] = mainMessages;\n      state.loading = false;\n      state.error = null;\n    },\n    prependMessages: (state, action: PayloadAction<{ channelId: string; messages: StoreMessage[] }>) => {\n      const { channelId, messages } = action.payload;\n      if (!state.messagesByChannel[channelId]) {\n        state.messagesByChannel[channelId] = [];\n      }\n      // Add messages to the beginning of the array, avoiding duplicates\n      const existingIds = new Set(state.messagesByChannel[channelId].map(msg => msg.id));\n      const newMessages = messages.filter(msg => !existingIds.has(msg.id));\n      state.messagesByChannel[channelId] = [...newMessages, ...state.messagesByChannel[channelId]];\n    },\n    addMessage: (state, action: PayloadAction<{ channelId: string; message: StoreMessage }>) => {\n      const { channelId, message } = action.payload;\n      \n      if (!state.messagesByChannel[channelId]) {\n        state.messagesByChannel[channelId] = [];\n      }\n\n      // If it's a reply, add it to the parent's replies\n      if (message.parentId) {\n        const parentMessage = state.messagesByChannel[channelId].find(m => m.id === message.parentId);\n        if (parentMessage) {\n          if (!parentMessage.replies) {\n            parentMessage.replies = [];\n          }\n          parentMessage.replies.push(message);\n          parentMessage.replyCount = (parentMessage.replyCount || 0) + 1;\n          parentMessage.repliesLoaded = true;\n        }\n      } else {\n        // Add as a main message\n        state.messagesByChannel[channelId].push(message);\n      }\n    },\n    updateMessage: (state, action: PayloadAction<{ channelId: string; message: StoreMessage }>) => {\n      const { channelId, message } = action.payload;\n      \n      if (!state.messagesByChannel[channelId]) return;\n\n      // Update main message\n      const messageIndex = state.messagesByChannel[channelId].findIndex(m => m.id === message.id);\n      if (messageIndex !== -1) {\n        // Preserve replies and expanded state\n        const existingMessage = state.messagesByChannel[channelId][messageIndex];\n        state.messagesByChannel[channelId][messageIndex] = {\n          ...message,\n          replies: existingMessage.replies || [],\n          isExpanded: existingMessage.isExpanded || false,\n          repliesLoaded: existingMessage.repliesLoaded || false,\n          replyCount: existingMessage.replyCount || 0\n        };\n        return;\n      }\n\n      // Update reply\n      state.messagesByChannel[channelId].forEach(mainMessage => {\n        if (mainMessage.replies) {\n          const replyIndex = mainMessage.replies.findIndex(r => r.id === message.id);\n          if (replyIndex !== -1) {\n            mainMessage.replies[replyIndex] = {\n              ...message,\n              parentId: mainMessage.id\n            };\n          }\n        }\n      });\n    },\n    deleteMessage: (state, action: PayloadAction<{ channelId: string; messageId: string }>) => {\n      const { channelId, messageId } = action.payload;\n      \n      if (!state.messagesByChannel[channelId]) return;\n\n      // Delete main message\n      state.messagesByChannel[channelId] = state.messagesByChannel[channelId].filter(m => m.id !== messageId);\n\n      // Delete reply and update reply count\n      state.messagesByChannel[channelId].forEach(mainMessage => {\n        if (mainMessage.replies) {\n          const originalLength = mainMessage.replies.length;\n          mainMessage.replies = mainMessage.replies.filter(r => r.id !== messageId);\n          if (mainMessage.replies.length !== originalLength) {\n            mainMessage.replyCount = mainMessage.replies.length;\n          }\n        }\n      });\n    },\n    addReaction: (state, action: PayloadAction<{ channelId: string; messageId: string; reaction: Reaction }>) => {\n      const { channelId, messageId, reaction } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const message = messages.find((msg: StoreMessage) => msg.id === messageId);\n        if (message) {\n          // Check if reaction already exists\n          const existingReactionIndex = message.reactions.findIndex(\n            (r: Reaction) => r.id === reaction.id || (r.emoji === reaction.emoji && r.userId === reaction.userId)\n          );\n          if (existingReactionIndex === -1) {\n            message.reactions.push(reaction);\n          }\n        }\n      }\n    },\n    removeReaction: (state, action: PayloadAction<{ channelId: string; messageId: string; reactionId: string }>) => {\n      const { channelId, messageId, reactionId } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const message = messages.find((msg: StoreMessage) => msg.id === messageId);\n        if (message) {\n          message.reactions = message.reactions.filter((reaction: Reaction) => reaction.id !== reactionId);\n        }\n      }\n    },\n    setReplies: (state, action: PayloadAction<{ channelId: string; parentMessageId: string; replies: StoreMessage[] }>) => {\n      const { channelId, parentMessageId, replies } = action.payload;\n      \n      if (!state.messagesByChannel[channelId]) return;\n\n      const parentMessage = state.messagesByChannel[channelId].find(m => m.id === parentMessageId);\n      if (parentMessage) {\n        if (!parentMessage.replies) {\n          parentMessage.replies = [];\n        }\n        // Append new replies while preserving existing ones\n        const newReplies = replies.filter(reply => \n          !parentMessage.replies?.some(existing => existing.id === reply.id)\n        );\n        parentMessage.replies = [...parentMessage.replies, ...newReplies];\n        parentMessage.replyCount = parentMessage.replies.length;\n        parentMessage.repliesLoaded = true;\n      }\n    },\n    toggleExpanded: (state, action: PayloadAction<{ channelId: string; messageId: string }>) => {\n      const { channelId, messageId } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const message = messages.find((msg: StoreMessage) => msg.id === messageId);\n        if (message) {\n          message.isExpanded = !message.isExpanded;\n        }\n      }\n    },\n    setExpanded: (state, action: PayloadAction<{ channelId: string; messageId: string; expanded: boolean }>) => {\n      const { channelId, messageId, expanded } = action.payload;\n      const messages = state.messagesByChannel[channelId];\n      if (messages) {\n        const message = messages.find((msg: StoreMessage) => msg.id === messageId);\n        if (message) {\n          message.isExpanded = expanded;\n        }\n      }\n    },\n    addReply: (state, action: PayloadAction<{ channelId: number; parentMessageId: number; reply: StoreMessage }>) => {\n      const { channelId, parentMessageId, reply } = action.payload;\n      const channelMessages = state.messagesByChannel[channelId];\n      if (channelMessages) {\n        const parentMessage = channelMessages.find(msg => msg.id === parentMessageId);\n        if (parentMessage) {\n          if (!parentMessage.replies) {\n            parentMessage.replies = [];\n          }\n          parentMessage.replies.push(reply);\n          parentMessage.replyCount = (parentMessage.replyCount || 0) + 1;\n        }\n      }\n    },\n  },\n});\n\nexport const {\n  setMessages,\n  prependMessages,\n  addMessage,\n  updateMessage,\n  deleteMessage,\n  addReaction,\n  removeReaction,\n  setReplies,\n  toggleExpanded,\n  setExpanded,\n  addReply\n} = messagesSlice.actions;\n\nexport default messagesSlice.reducer; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}