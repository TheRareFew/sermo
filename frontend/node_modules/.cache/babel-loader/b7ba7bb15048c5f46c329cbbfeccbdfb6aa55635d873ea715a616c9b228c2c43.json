{"ast":null,"code":"import { createSlice } from '@reduxjs/toolkit';\nconst initialState = {};\nconst messagesSlice = createSlice({\n  name: 'messages',\n  initialState,\n  reducers: {\n    setMessages: (state, action) => {\n      const {\n        channelId,\n        messages\n      } = action.payload;\n\n      // Organize messages by parent/reply relationship\n      const mainMessages = [];\n      const repliesByParentId = {};\n\n      // First pass: separate messages into main messages and replies\n      messages.forEach(msg => {\n        if (msg.parentId) {\n          // This is a reply\n          if (!repliesByParentId[msg.parentId]) {\n            repliesByParentId[msg.parentId] = [];\n          }\n          repliesByParentId[msg.parentId].push(msg);\n        } else {\n          // This is a main message\n          mainMessages.push(msg);\n        }\n      });\n\n      // Second pass: attach replies to their parent messages\n      mainMessages.forEach(msg => {\n        if (repliesByParentId[msg.id]) {\n          msg.replies = repliesByParentId[msg.id];\n          msg.replyCount = repliesByParentId[msg.id].length;\n          msg.repliesLoaded = true;\n        }\n      });\n\n      // Update the state with organized messages\n      state[channelId] = mainMessages;\n    },\n    prependMessages: (state, action) => {\n      const {\n        channelId,\n        messages\n      } = action.payload;\n      if (!state[channelId]) {\n        state[channelId] = [];\n      }\n      // Add messages to the beginning of the array, avoiding duplicates\n      const existingIds = new Set(state[channelId].map(msg => msg.id));\n      const newMessages = messages.filter(msg => !existingIds.has(msg.id));\n      state[channelId] = [...newMessages, ...state[channelId]];\n    },\n    addMessage: (state, action) => {\n      const {\n        channelId\n      } = action.payload;\n\n      // Initialize channel messages array if it doesn't exist\n      if (!state[channelId]) {\n        state[channelId] = [];\n      }\n\n      // Check if message already exists by ID\n      const existingMessageIndex = state[channelId].findIndex(msg => msg.id === action.payload.id);\n      if (existingMessageIndex === -1) {\n        // Add new message\n        state[channelId].push(action.payload);\n\n        // Sort messages by creation time, ensuring chronological order\n        state[channelId].sort((a, b) => {\n          const timeA = new Date(a.createdAt).getTime();\n          const timeB = new Date(b.createdAt).getTime();\n          return timeA - timeB;\n        });\n\n        // Ensure parent messages are marked as having replies\n        if (action.payload.parentId) {\n          const parentMessage = state[channelId].find(msg => msg.id === action.payload.parentId);\n          if (parentMessage) {\n            parentMessage.replyCount = (parentMessage.replyCount || 0) + 1;\n          }\n        }\n      } else {\n        // Update existing message if it has changed\n        const existingMessage = state[channelId][existingMessageIndex];\n        if (existingMessage.updatedAt !== action.payload.updatedAt || existingMessage.content !== action.payload.content || existingMessage.replyCount !== action.payload.replyCount) {\n          state[channelId][existingMessageIndex] = {\n            ...existingMessage,\n            ...action.payload,\n            reactions: [...existingMessage.reactions] // Preserve existing reactions\n          };\n        }\n      }\n    },\n    updateMessage: (state, action) => {\n      const {\n        channelId,\n        messageId,\n        content,\n        updatedAt\n      } = action.payload;\n      if (state[channelId]) {\n        const message = state[channelId].find(msg => msg.id === messageId);\n        if (message) {\n          message.content = content;\n          message.updatedAt = updatedAt;\n        }\n      }\n    },\n    deleteMessage: (state, action) => {\n      const {\n        channelId,\n        messageId\n      } = action.payload;\n      if (state[channelId]) {\n        state[channelId] = state[channelId].filter(msg => msg.id !== messageId);\n      }\n    },\n    addReaction: (state, action) => {\n      const {\n        channelId,\n        messageId,\n        reaction\n      } = action.payload;\n      if (state[channelId]) {\n        const message = state[channelId].find(msg => msg.id === messageId);\n        if (message) {\n          // Check if reaction already exists\n          const existingReactionIndex = message.reactions.findIndex(r => r.id === reaction.id || r.emoji === reaction.emoji && r.userId === reaction.userId);\n          if (existingReactionIndex === -1) {\n            message.reactions.push(reaction);\n          }\n        }\n      }\n    },\n    removeReaction: (state, action) => {\n      const {\n        channelId,\n        messageId,\n        reactionId\n      } = action.payload;\n      if (state[channelId]) {\n        const message = state[channelId].find(msg => msg.id === messageId);\n        if (message) {\n          message.reactions = message.reactions.filter(reaction => reaction.id !== reactionId);\n        }\n      }\n    },\n    setReplies: (state, action) => {\n      const {\n        channelId,\n        messageId,\n        replies\n      } = action.payload;\n      if (state[channelId]) {\n        const messageIndex = state[channelId].findIndex(msg => msg.id === messageId);\n        if (messageIndex !== -1) {\n          // Create a new message object with the updated replies\n          const updatedMessage = {\n            ...state[channelId][messageIndex],\n            replies: [...(state[channelId][messageIndex].replies || []), ...replies.filter(reply => {\n              var _state$channelId$mess;\n              return !((_state$channelId$mess = state[channelId][messageIndex].replies) !== null && _state$channelId$mess !== void 0 && _state$channelId$mess.some(existingReply => existingReply.id === reply.id));\n            })],\n            repliesLoaded: true,\n            isExpanded: true // Auto-expand when new replies are added\n          };\n\n          // Update reply count\n          updatedMessage.replyCount = updatedMessage.replies.length;\n\n          // Update the message in the array\n          state[channelId][messageIndex] = updatedMessage;\n        }\n      }\n    },\n    toggleExpanded: (state, action) => {\n      const {\n        channelId,\n        messageId\n      } = action.payload;\n      if (state[channelId]) {\n        const message = state[channelId].find(msg => msg.id === messageId);\n        if (message) {\n          message.isExpanded = !message.isExpanded;\n        }\n      }\n    }\n  }\n});\nexport const {\n  addMessage,\n  setMessages,\n  setReplies,\n  deleteMessage,\n  updateMessage\n} = messagesSlice.actions;\nexport default messagesSlice.reducer;","map":{"version":3,"names":["createSlice","initialState","messagesSlice","name","reducers","setMessages","state","action","channelId","messages","payload","mainMessages","repliesByParentId","forEach","msg","parentId","push","id","replies","replyCount","length","repliesLoaded","prependMessages","existingIds","Set","map","newMessages","filter","has","addMessage","existingMessageIndex","findIndex","sort","a","b","timeA","Date","createdAt","getTime","timeB","parentMessage","find","existingMessage","updatedAt","content","reactions","updateMessage","messageId","message","deleteMessage","addReaction","reaction","existingReactionIndex","r","emoji","userId","removeReaction","reactionId","setReplies","messageIndex","updatedMessage","reply","_state$channelId$mess","some","existingReply","isExpanded","toggleExpanded","actions","reducer"],"sources":["Z:/GAUNTLET/projects/SERMO/sermo-app/frontend/src/store/messages/messagesSlice.ts"],"sourcesContent":["import { createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { StoreMessage } from '../../types';\n\ninterface MessagesState {\n  [channelId: string]: StoreMessage[];\n}\n\nconst initialState: MessagesState = {};\n\nconst messagesSlice = createSlice({\n  name: 'messages',\n  initialState,\n  reducers: {\n    setMessages: (state, action: PayloadAction<{ channelId: string; messages: StoreMessage[] }>) => {\n      const { channelId, messages } = action.payload;\n      \n      // Organize messages by parent/reply relationship\n      const mainMessages: StoreMessage[] = [];\n      const repliesByParentId: { [key: string]: StoreMessage[] } = {};\n\n      // First pass: separate messages into main messages and replies\n      messages.forEach(msg => {\n        if (msg.parentId) {\n          // This is a reply\n          if (!repliesByParentId[msg.parentId]) {\n            repliesByParentId[msg.parentId] = [];\n          }\n          repliesByParentId[msg.parentId].push(msg);\n        } else {\n          // This is a main message\n          mainMessages.push(msg);\n        }\n      });\n\n      // Second pass: attach replies to their parent messages\n      mainMessages.forEach(msg => {\n        if (repliesByParentId[msg.id]) {\n          msg.replies = repliesByParentId[msg.id];\n          msg.replyCount = repliesByParentId[msg.id].length;\n          msg.repliesLoaded = true;\n        }\n      });\n\n      // Update the state with organized messages\n      state[channelId] = mainMessages;\n    },\n    prependMessages: (state, action: PayloadAction<{ channelId: string; messages: StoreMessage[] }>) => {\n      const { channelId, messages } = action.payload;\n      if (!state[channelId]) {\n        state[channelId] = [];\n      }\n      // Add messages to the beginning of the array, avoiding duplicates\n      const existingIds = new Set(state[channelId].map(msg => msg.id));\n      const newMessages = messages.filter(msg => !existingIds.has(msg.id));\n      state[channelId] = [...newMessages, ...state[channelId]];\n    },\n    addMessage: (state, action: PayloadAction<StoreMessage>) => {\n      const { channelId } = action.payload;\n      \n      // Initialize channel messages array if it doesn't exist\n      if (!state[channelId]) {\n        state[channelId] = [];\n      }\n\n      // Check if message already exists by ID\n      const existingMessageIndex = state[channelId].findIndex(\n        (msg: StoreMessage) => msg.id === action.payload.id\n      );\n\n      if (existingMessageIndex === -1) {\n        // Add new message\n        state[channelId].push(action.payload);\n        \n        // Sort messages by creation time, ensuring chronological order\n        state[channelId].sort((a, b) => {\n          const timeA = new Date(a.createdAt).getTime();\n          const timeB = new Date(b.createdAt).getTime();\n          return timeA - timeB;\n        });\n\n        // Ensure parent messages are marked as having replies\n        if (action.payload.parentId) {\n          const parentMessage = state[channelId].find(\n            msg => msg.id === action.payload.parentId\n          );\n          if (parentMessage) {\n            parentMessage.replyCount = (parentMessage.replyCount || 0) + 1;\n          }\n        }\n      } else {\n        // Update existing message if it has changed\n        const existingMessage = state[channelId][existingMessageIndex];\n        if (\n          existingMessage.updatedAt !== action.payload.updatedAt ||\n          existingMessage.content !== action.payload.content ||\n          existingMessage.replyCount !== action.payload.replyCount\n        ) {\n          state[channelId][existingMessageIndex] = {\n            ...existingMessage,\n            ...action.payload,\n            reactions: [...existingMessage.reactions] // Preserve existing reactions\n          };\n        }\n      }\n    },\n    updateMessage: (state, action: PayloadAction<{ channelId: string; messageId: string; content: string; updatedAt: string }>) => {\n      const { channelId, messageId, content, updatedAt } = action.payload;\n      if (state[channelId]) {\n        const message = state[channelId].find(msg => msg.id === messageId);\n        if (message) {\n          message.content = content;\n          message.updatedAt = updatedAt;\n        }\n      }\n    },\n    deleteMessage: (state, action: PayloadAction<{ channelId: string; messageId: string }>) => {\n      const { channelId, messageId } = action.payload;\n      if (state[channelId]) {\n        state[channelId] = state[channelId].filter(msg => msg.id !== messageId);\n      }\n    },\n    addReaction: (state, action: PayloadAction<{ channelId: string; messageId: string; reaction: Reaction }>) => {\n      const { channelId, messageId, reaction } = action.payload;\n      if (state[channelId]) {\n        const message = state[channelId].find((msg: StoreMessage) => msg.id === messageId);\n        if (message) {\n          // Check if reaction already exists\n          const existingReactionIndex = message.reactions.findIndex(\n            (r: Reaction) => r.id === reaction.id || (r.emoji === reaction.emoji && r.userId === reaction.userId)\n          );\n          if (existingReactionIndex === -1) {\n            message.reactions.push(reaction);\n          }\n        }\n      }\n    },\n    removeReaction: (state, action: PayloadAction<{ channelId: string; messageId: string; reactionId: string }>) => {\n      const { channelId, messageId, reactionId } = action.payload;\n      if (state[channelId]) {\n        const message = state[channelId].find((msg: StoreMessage) => msg.id === messageId);\n        if (message) {\n          message.reactions = message.reactions.filter((reaction: Reaction) => reaction.id !== reactionId);\n        }\n      }\n    },\n    setReplies: (state, action: PayloadAction<{ channelId: string; messageId: string; replies: StoreMessage[] }>) => {\n      const { channelId, messageId, replies } = action.payload;\n      if (state[channelId]) {\n        const messageIndex = state[channelId].findIndex((msg: StoreMessage) => msg.id === messageId);\n        if (messageIndex !== -1) {\n          // Create a new message object with the updated replies\n          const updatedMessage = {\n            ...state[channelId][messageIndex],\n            replies: [\n              ...(state[channelId][messageIndex].replies || []),\n              ...replies.filter(reply => \n                !state[channelId][messageIndex].replies?.some(existingReply => \n                  existingReply.id === reply.id\n                )\n              )\n            ],\n            repliesLoaded: true,\n            isExpanded: true // Auto-expand when new replies are added\n          };\n          \n          // Update reply count\n          updatedMessage.replyCount = updatedMessage.replies.length;\n          \n          // Update the message in the array\n          state[channelId][messageIndex] = updatedMessage;\n        }\n      }\n    },\n    toggleExpanded: (state, action: PayloadAction<{ channelId: string; messageId: string }>) => {\n      const { channelId, messageId } = action.payload;\n      if (state[channelId]) {\n        const message = state[channelId].find((msg: StoreMessage) => msg.id === messageId);\n        if (message) {\n          message.isExpanded = !message.isExpanded;\n        }\n      }\n    },\n  },\n});\n\nexport const { addMessage, setMessages, setReplies, deleteMessage, updateMessage } = messagesSlice.actions;\nexport default messagesSlice.reducer; "],"mappings":"AAAA,SAASA,WAAW,QAAuB,kBAAkB;AAO7D,MAAMC,YAA2B,GAAG,CAAC,CAAC;AAEtC,MAAMC,aAAa,GAAGF,WAAW,CAAC;EAChCG,IAAI,EAAE,UAAU;EAChBF,YAAY;EACZG,QAAQ,EAAE;IACRC,WAAW,EAAEA,CAACC,KAAK,EAAEC,MAAsE,KAAK;MAC9F,MAAM;QAAEC,SAAS;QAAEC;MAAS,CAAC,GAAGF,MAAM,CAACG,OAAO;;MAE9C;MACA,MAAMC,YAA4B,GAAG,EAAE;MACvC,MAAMC,iBAAoD,GAAG,CAAC,CAAC;;MAE/D;MACAH,QAAQ,CAACI,OAAO,CAACC,GAAG,IAAI;QACtB,IAAIA,GAAG,CAACC,QAAQ,EAAE;UAChB;UACA,IAAI,CAACH,iBAAiB,CAACE,GAAG,CAACC,QAAQ,CAAC,EAAE;YACpCH,iBAAiB,CAACE,GAAG,CAACC,QAAQ,CAAC,GAAG,EAAE;UACtC;UACAH,iBAAiB,CAACE,GAAG,CAACC,QAAQ,CAAC,CAACC,IAAI,CAACF,GAAG,CAAC;QAC3C,CAAC,MAAM;UACL;UACAH,YAAY,CAACK,IAAI,CAACF,GAAG,CAAC;QACxB;MACF,CAAC,CAAC;;MAEF;MACAH,YAAY,CAACE,OAAO,CAACC,GAAG,IAAI;QAC1B,IAAIF,iBAAiB,CAACE,GAAG,CAACG,EAAE,CAAC,EAAE;UAC7BH,GAAG,CAACI,OAAO,GAAGN,iBAAiB,CAACE,GAAG,CAACG,EAAE,CAAC;UACvCH,GAAG,CAACK,UAAU,GAAGP,iBAAiB,CAACE,GAAG,CAACG,EAAE,CAAC,CAACG,MAAM;UACjDN,GAAG,CAACO,aAAa,GAAG,IAAI;QAC1B;MACF,CAAC,CAAC;;MAEF;MACAf,KAAK,CAACE,SAAS,CAAC,GAAGG,YAAY;IACjC,CAAC;IACDW,eAAe,EAAEA,CAAChB,KAAK,EAAEC,MAAsE,KAAK;MAClG,MAAM;QAAEC,SAAS;QAAEC;MAAS,CAAC,GAAGF,MAAM,CAACG,OAAO;MAC9C,IAAI,CAACJ,KAAK,CAACE,SAAS,CAAC,EAAE;QACrBF,KAAK,CAACE,SAAS,CAAC,GAAG,EAAE;MACvB;MACA;MACA,MAAMe,WAAW,GAAG,IAAIC,GAAG,CAAClB,KAAK,CAACE,SAAS,CAAC,CAACiB,GAAG,CAACX,GAAG,IAAIA,GAAG,CAACG,EAAE,CAAC,CAAC;MAChE,MAAMS,WAAW,GAAGjB,QAAQ,CAACkB,MAAM,CAACb,GAAG,IAAI,CAACS,WAAW,CAACK,GAAG,CAACd,GAAG,CAACG,EAAE,CAAC,CAAC;MACpEX,KAAK,CAACE,SAAS,CAAC,GAAG,CAAC,GAAGkB,WAAW,EAAE,GAAGpB,KAAK,CAACE,SAAS,CAAC,CAAC;IAC1D,CAAC;IACDqB,UAAU,EAAEA,CAACvB,KAAK,EAAEC,MAAmC,KAAK;MAC1D,MAAM;QAAEC;MAAU,CAAC,GAAGD,MAAM,CAACG,OAAO;;MAEpC;MACA,IAAI,CAACJ,KAAK,CAACE,SAAS,CAAC,EAAE;QACrBF,KAAK,CAACE,SAAS,CAAC,GAAG,EAAE;MACvB;;MAEA;MACA,MAAMsB,oBAAoB,GAAGxB,KAAK,CAACE,SAAS,CAAC,CAACuB,SAAS,CACpDjB,GAAiB,IAAKA,GAAG,CAACG,EAAE,KAAKV,MAAM,CAACG,OAAO,CAACO,EACnD,CAAC;MAED,IAAIa,oBAAoB,KAAK,CAAC,CAAC,EAAE;QAC/B;QACAxB,KAAK,CAACE,SAAS,CAAC,CAACQ,IAAI,CAACT,MAAM,CAACG,OAAO,CAAC;;QAErC;QACAJ,KAAK,CAACE,SAAS,CAAC,CAACwB,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAK;UAC9B,MAAMC,KAAK,GAAG,IAAIC,IAAI,CAACH,CAAC,CAACI,SAAS,CAAC,CAACC,OAAO,CAAC,CAAC;UAC7C,MAAMC,KAAK,GAAG,IAAIH,IAAI,CAACF,CAAC,CAACG,SAAS,CAAC,CAACC,OAAO,CAAC,CAAC;UAC7C,OAAOH,KAAK,GAAGI,KAAK;QACtB,CAAC,CAAC;;QAEF;QACA,IAAIhC,MAAM,CAACG,OAAO,CAACK,QAAQ,EAAE;UAC3B,MAAMyB,aAAa,GAAGlC,KAAK,CAACE,SAAS,CAAC,CAACiC,IAAI,CACzC3B,GAAG,IAAIA,GAAG,CAACG,EAAE,KAAKV,MAAM,CAACG,OAAO,CAACK,QACnC,CAAC;UACD,IAAIyB,aAAa,EAAE;YACjBA,aAAa,CAACrB,UAAU,GAAG,CAACqB,aAAa,CAACrB,UAAU,IAAI,CAAC,IAAI,CAAC;UAChE;QACF;MACF,CAAC,MAAM;QACL;QACA,MAAMuB,eAAe,GAAGpC,KAAK,CAACE,SAAS,CAAC,CAACsB,oBAAoB,CAAC;QAC9D,IACEY,eAAe,CAACC,SAAS,KAAKpC,MAAM,CAACG,OAAO,CAACiC,SAAS,IACtDD,eAAe,CAACE,OAAO,KAAKrC,MAAM,CAACG,OAAO,CAACkC,OAAO,IAClDF,eAAe,CAACvB,UAAU,KAAKZ,MAAM,CAACG,OAAO,CAACS,UAAU,EACxD;UACAb,KAAK,CAACE,SAAS,CAAC,CAACsB,oBAAoB,CAAC,GAAG;YACvC,GAAGY,eAAe;YAClB,GAAGnC,MAAM,CAACG,OAAO;YACjBmC,SAAS,EAAE,CAAC,GAAGH,eAAe,CAACG,SAAS,CAAC,CAAC;UAC5C,CAAC;QACH;MACF;IACF,CAAC;IACDC,aAAa,EAAEA,CAACxC,KAAK,EAAEC,MAAmG,KAAK;MAC7H,MAAM;QAAEC,SAAS;QAAEuC,SAAS;QAAEH,OAAO;QAAED;MAAU,CAAC,GAAGpC,MAAM,CAACG,OAAO;MACnE,IAAIJ,KAAK,CAACE,SAAS,CAAC,EAAE;QACpB,MAAMwC,OAAO,GAAG1C,KAAK,CAACE,SAAS,CAAC,CAACiC,IAAI,CAAC3B,GAAG,IAAIA,GAAG,CAACG,EAAE,KAAK8B,SAAS,CAAC;QAClE,IAAIC,OAAO,EAAE;UACXA,OAAO,CAACJ,OAAO,GAAGA,OAAO;UACzBI,OAAO,CAACL,SAAS,GAAGA,SAAS;QAC/B;MACF;IACF,CAAC;IACDM,aAAa,EAAEA,CAAC3C,KAAK,EAAEC,MAA+D,KAAK;MACzF,MAAM;QAAEC,SAAS;QAAEuC;MAAU,CAAC,GAAGxC,MAAM,CAACG,OAAO;MAC/C,IAAIJ,KAAK,CAACE,SAAS,CAAC,EAAE;QACpBF,KAAK,CAACE,SAAS,CAAC,GAAGF,KAAK,CAACE,SAAS,CAAC,CAACmB,MAAM,CAACb,GAAG,IAAIA,GAAG,CAACG,EAAE,KAAK8B,SAAS,CAAC;MACzE;IACF,CAAC;IACDG,WAAW,EAAEA,CAAC5C,KAAK,EAAEC,MAAmF,KAAK;MAC3G,MAAM;QAAEC,SAAS;QAAEuC,SAAS;QAAEI;MAAS,CAAC,GAAG5C,MAAM,CAACG,OAAO;MACzD,IAAIJ,KAAK,CAACE,SAAS,CAAC,EAAE;QACpB,MAAMwC,OAAO,GAAG1C,KAAK,CAACE,SAAS,CAAC,CAACiC,IAAI,CAAE3B,GAAiB,IAAKA,GAAG,CAACG,EAAE,KAAK8B,SAAS,CAAC;QAClF,IAAIC,OAAO,EAAE;UACX;UACA,MAAMI,qBAAqB,GAAGJ,OAAO,CAACH,SAAS,CAACd,SAAS,CACtDsB,CAAW,IAAKA,CAAC,CAACpC,EAAE,KAAKkC,QAAQ,CAAClC,EAAE,IAAKoC,CAAC,CAACC,KAAK,KAAKH,QAAQ,CAACG,KAAK,IAAID,CAAC,CAACE,MAAM,KAAKJ,QAAQ,CAACI,MAChG,CAAC;UACD,IAAIH,qBAAqB,KAAK,CAAC,CAAC,EAAE;YAChCJ,OAAO,CAACH,SAAS,CAAC7B,IAAI,CAACmC,QAAQ,CAAC;UAClC;QACF;MACF;IACF,CAAC;IACDK,cAAc,EAAEA,CAAClD,KAAK,EAAEC,MAAmF,KAAK;MAC9G,MAAM;QAAEC,SAAS;QAAEuC,SAAS;QAAEU;MAAW,CAAC,GAAGlD,MAAM,CAACG,OAAO;MAC3D,IAAIJ,KAAK,CAACE,SAAS,CAAC,EAAE;QACpB,MAAMwC,OAAO,GAAG1C,KAAK,CAACE,SAAS,CAAC,CAACiC,IAAI,CAAE3B,GAAiB,IAAKA,GAAG,CAACG,EAAE,KAAK8B,SAAS,CAAC;QAClF,IAAIC,OAAO,EAAE;UACXA,OAAO,CAACH,SAAS,GAAGG,OAAO,CAACH,SAAS,CAAClB,MAAM,CAAEwB,QAAkB,IAAKA,QAAQ,CAAClC,EAAE,KAAKwC,UAAU,CAAC;QAClG;MACF;IACF,CAAC;IACDC,UAAU,EAAEA,CAACpD,KAAK,EAAEC,MAAwF,KAAK;MAC/G,MAAM;QAAEC,SAAS;QAAEuC,SAAS;QAAE7B;MAAQ,CAAC,GAAGX,MAAM,CAACG,OAAO;MACxD,IAAIJ,KAAK,CAACE,SAAS,CAAC,EAAE;QACpB,MAAMmD,YAAY,GAAGrD,KAAK,CAACE,SAAS,CAAC,CAACuB,SAAS,CAAEjB,GAAiB,IAAKA,GAAG,CAACG,EAAE,KAAK8B,SAAS,CAAC;QAC5F,IAAIY,YAAY,KAAK,CAAC,CAAC,EAAE;UACvB;UACA,MAAMC,cAAc,GAAG;YACrB,GAAGtD,KAAK,CAACE,SAAS,CAAC,CAACmD,YAAY,CAAC;YACjCzC,OAAO,EAAE,CACP,IAAIZ,KAAK,CAACE,SAAS,CAAC,CAACmD,YAAY,CAAC,CAACzC,OAAO,IAAI,EAAE,CAAC,EACjD,GAAGA,OAAO,CAACS,MAAM,CAACkC,KAAK;cAAA,IAAAC,qBAAA;cAAA,OACrB,GAAAA,qBAAA,GAACxD,KAAK,CAACE,SAAS,CAAC,CAACmD,YAAY,CAAC,CAACzC,OAAO,cAAA4C,qBAAA,eAAtCA,qBAAA,CAAwCC,IAAI,CAACC,aAAa,IACzDA,aAAa,CAAC/C,EAAE,KAAK4C,KAAK,CAAC5C,EAC7B,CAAC;YAAA,CACH,CAAC,CACF;YACDI,aAAa,EAAE,IAAI;YACnB4C,UAAU,EAAE,IAAI,CAAC;UACnB,CAAC;;UAED;UACAL,cAAc,CAACzC,UAAU,GAAGyC,cAAc,CAAC1C,OAAO,CAACE,MAAM;;UAEzD;UACAd,KAAK,CAACE,SAAS,CAAC,CAACmD,YAAY,CAAC,GAAGC,cAAc;QACjD;MACF;IACF,CAAC;IACDM,cAAc,EAAEA,CAAC5D,KAAK,EAAEC,MAA+D,KAAK;MAC1F,MAAM;QAAEC,SAAS;QAAEuC;MAAU,CAAC,GAAGxC,MAAM,CAACG,OAAO;MAC/C,IAAIJ,KAAK,CAACE,SAAS,CAAC,EAAE;QACpB,MAAMwC,OAAO,GAAG1C,KAAK,CAACE,SAAS,CAAC,CAACiC,IAAI,CAAE3B,GAAiB,IAAKA,GAAG,CAACG,EAAE,KAAK8B,SAAS,CAAC;QAClF,IAAIC,OAAO,EAAE;UACXA,OAAO,CAACiB,UAAU,GAAG,CAACjB,OAAO,CAACiB,UAAU;QAC1C;MACF;IACF;EACF;AACF,CAAC,CAAC;AAEF,OAAO,MAAM;EAAEpC,UAAU;EAAExB,WAAW;EAAEqD,UAAU;EAAET,aAAa;EAAEH;AAAc,CAAC,GAAG5C,aAAa,CAACiE,OAAO;AAC1G,eAAejE,aAAa,CAACkE,OAAO","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}