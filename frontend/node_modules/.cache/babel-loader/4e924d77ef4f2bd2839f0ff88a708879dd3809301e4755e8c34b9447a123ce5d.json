{"ast":null,"code":"import { getAuthToken } from '../api/auth';\nconst WS_URL = process.env.REACT_APP_WS_URL || 'ws://localhost:8000/ws';\nclass WebSocketService {\n  // 5 seconds\n\n  constructor() {\n    this.chatSocket = null;\n    this.presenceSocket = null;\n    this.messageHandlers = [];\n    this.presenceHandlers = [];\n    this.reconnectTimeout = null;\n    this.RECONNECT_DELAY = 5000;\n    // Bind methods\n    this.connect = this.connect.bind(this);\n    this.disconnect = this.disconnect.bind(this);\n    this.sendMessage = this.sendMessage.bind(this);\n    this.updateStatus = this.updateStatus.bind(this);\n    this.joinChannel = this.joinChannel.bind(this);\n    this.leaveChannel = this.leaveChannel.bind(this);\n  }\n  connect() {\n    const token = getAuthToken();\n    if (!token) {\n      console.error('No auth token available');\n      return;\n    }\n\n    // Connect to chat WebSocket\n    this.chatSocket = new WebSocket(`${WS_URL}/chat?token=${encodeURIComponent(token)}`);\n    this.setupWebSocketHandlers(this.chatSocket, 'chat');\n\n    // Connect to presence WebSocket\n    this.presenceSocket = new WebSocket(`${WS_URL}/presence?token=${encodeURIComponent(token)}`);\n    this.setupWebSocketHandlers(this.presenceSocket, 'presence');\n  }\n  setupWebSocketHandlers(socket, type) {\n    socket.onopen = () => {\n      console.log(`${type} WebSocket connected`);\n    };\n    socket.onmessage = event => {\n      try {\n        const message = JSON.parse(event.data);\n        if (type === 'chat') {\n          this.messageHandlers.forEach(handler => handler(message));\n        } else {\n          this.presenceHandlers.forEach(handler => handler(message));\n        }\n      } catch (error) {\n        console.error(`Failed to parse ${type} message:`, error);\n      }\n    };\n    socket.onclose = event => {\n      console.log(`${type} WebSocket closed with code ${event.code}. Attempting to reconnect...`);\n      if (event.code === 4001) {\n        console.error('Authentication failed. Please log in again.');\n        // Trigger logout or auth refresh here if needed\n        return;\n      }\n      this.scheduleReconnect();\n    };\n    socket.onerror = error => {\n      console.error(`${type} WebSocket error:`, error);\n    };\n  }\n  disconnect() {\n    if (this.chatSocket) {\n      this.chatSocket.close();\n      this.chatSocket = null;\n    }\n    if (this.presenceSocket) {\n      this.presenceSocket.close();\n      this.presenceSocket = null;\n    }\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n  }\n  sendMessage(channelId, content) {\n    if (!this.chatSocket || this.chatSocket.readyState !== WebSocket.OPEN) {\n      console.error('Chat WebSocket is not connected');\n      return;\n    }\n    const message = {\n      type: 'message',\n      channel_id: channelId,\n      content\n    };\n    this.chatSocket.send(JSON.stringify(message));\n  }\n  updateStatus(status) {\n    if (!this.presenceSocket || this.presenceSocket.readyState !== WebSocket.OPEN) {\n      console.error('Presence WebSocket is not connected');\n      return;\n    }\n    const message = {\n      type: 'status_update',\n      status\n    };\n    this.presenceSocket.send(JSON.stringify(message));\n  }\n  joinChannel(channelId) {\n    if (!this.chatSocket || this.chatSocket.readyState !== WebSocket.OPEN) {\n      console.error('Chat WebSocket is not connected');\n      return;\n    }\n    const message = {\n      type: 'join_channel',\n      channel_id: channelId\n    };\n    this.chatSocket.send(JSON.stringify(message));\n  }\n  leaveChannel(channelId) {\n    if (!this.chatSocket || this.chatSocket.readyState !== WebSocket.OPEN) {\n      console.error('Chat WebSocket is not connected');\n      return;\n    }\n    const message = {\n      type: 'leave_channel',\n      channel_id: channelId\n    };\n    this.chatSocket.send(JSON.stringify(message));\n  }\n  onMessage(handler) {\n    this.messageHandlers.push(handler);\n    return () => {\n      this.messageHandlers = this.messageHandlers.filter(h => h !== handler);\n    };\n  }\n  onPresence(handler) {\n    this.presenceHandlers.push(handler);\n    return () => {\n      this.presenceHandlers = this.presenceHandlers.filter(h => h !== handler);\n    };\n  }\n  scheduleReconnect() {\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n    }\n    this.reconnectTimeout = setTimeout(() => {\n      console.log('Attempting to reconnect WebSocket...');\n      this.connect();\n    }, this.RECONNECT_DELAY);\n  }\n}\n\n// Create a singleton instance\nconst wsService = new WebSocketService();\nexport { WebSocketService };\nexport default wsService;","map":{"version":3,"names":["getAuthToken","WS_URL","process","env","REACT_APP_WS_URL","WebSocketService","constructor","chatSocket","presenceSocket","messageHandlers","presenceHandlers","reconnectTimeout","RECONNECT_DELAY","connect","bind","disconnect","sendMessage","updateStatus","joinChannel","leaveChannel","token","console","error","WebSocket","encodeURIComponent","setupWebSocketHandlers","socket","type","onopen","log","onmessage","event","message","JSON","parse","data","forEach","handler","onclose","code","scheduleReconnect","onerror","close","clearTimeout","channelId","content","readyState","OPEN","channel_id","send","stringify","status","onMessage","push","filter","h","onPresence","setTimeout","wsService"],"sources":["Z:/GAUNTLET/projects/SERMO/sermo-app/frontend/src/services/websocket/index.ts"],"sourcesContent":["import { getAuthToken } from '../api/auth';\r\n\r\nconst WS_URL = process.env.REACT_APP_WS_URL || 'ws://localhost:8000/ws';\r\n\r\ninterface WebSocketMessage {\r\n  type: string;\r\n  [key: string]: any;\r\n}\r\n\r\nclass WebSocketService {\r\n  private chatSocket: WebSocket | null = null;\r\n  private presenceSocket: WebSocket | null = null;\r\n  private messageHandlers: ((message: WebSocketMessage) => void)[] = [];\r\n  private presenceHandlers: ((message: WebSocketMessage) => void)[] = [];\r\n  private reconnectTimeout: NodeJS.Timeout | null = null;\r\n  private readonly RECONNECT_DELAY = 5000; // 5 seconds\r\n\r\n  constructor() {\r\n    // Bind methods\r\n    this.connect = this.connect.bind(this);\r\n    this.disconnect = this.disconnect.bind(this);\r\n    this.sendMessage = this.sendMessage.bind(this);\r\n    this.updateStatus = this.updateStatus.bind(this);\r\n    this.joinChannel = this.joinChannel.bind(this);\r\n    this.leaveChannel = this.leaveChannel.bind(this);\r\n  }\r\n\r\n  public connect(): void {\r\n    const token = getAuthToken();\r\n    if (!token) {\r\n      console.error('No auth token available');\r\n      return;\r\n    }\r\n\r\n    // Connect to chat WebSocket\r\n    this.chatSocket = new WebSocket(`${WS_URL}/chat?token=${encodeURIComponent(token)}`);\r\n    this.setupWebSocketHandlers(this.chatSocket, 'chat');\r\n\r\n    // Connect to presence WebSocket\r\n    this.presenceSocket = new WebSocket(`${WS_URL}/presence?token=${encodeURIComponent(token)}`);\r\n    this.setupWebSocketHandlers(this.presenceSocket, 'presence');\r\n  }\r\n\r\n  private setupWebSocketHandlers(socket: WebSocket, type: 'chat' | 'presence'): void {\r\n    socket.onopen = () => {\r\n      console.log(`${type} WebSocket connected`);\r\n    };\r\n\r\n    socket.onmessage = (event) => {\r\n      try {\r\n        const message = JSON.parse(event.data);\r\n        if (type === 'chat') {\r\n          this.messageHandlers.forEach(handler => handler(message));\r\n        } else {\r\n          this.presenceHandlers.forEach(handler => handler(message));\r\n        }\r\n      } catch (error) {\r\n        console.error(`Failed to parse ${type} message:`, error);\r\n      }\r\n    };\r\n\r\n    socket.onclose = (event) => {\r\n      console.log(`${type} WebSocket closed with code ${event.code}. Attempting to reconnect...`);\r\n      if (event.code === 4001) {\r\n        console.error('Authentication failed. Please log in again.');\r\n        // Trigger logout or auth refresh here if needed\r\n        return;\r\n      }\r\n      this.scheduleReconnect();\r\n    };\r\n\r\n    socket.onerror = (error) => {\r\n      console.error(`${type} WebSocket error:`, error);\r\n    };\r\n  }\r\n\r\n  public disconnect(): void {\r\n    if (this.chatSocket) {\r\n      this.chatSocket.close();\r\n      this.chatSocket = null;\r\n    }\r\n    if (this.presenceSocket) {\r\n      this.presenceSocket.close();\r\n      this.presenceSocket = null;\r\n    }\r\n    if (this.reconnectTimeout) {\r\n      clearTimeout(this.reconnectTimeout);\r\n      this.reconnectTimeout = null;\r\n    }\r\n  }\r\n\r\n  public sendMessage(channelId: number, content: string): void {\r\n    if (!this.chatSocket || this.chatSocket.readyState !== WebSocket.OPEN) {\r\n      console.error('Chat WebSocket is not connected');\r\n      return;\r\n    }\r\n\r\n    const message = {\r\n      type: 'message',\r\n      channel_id: channelId,\r\n      content\r\n    };\r\n\r\n    this.chatSocket.send(JSON.stringify(message));\r\n  }\r\n\r\n  public updateStatus(status: 'online' | 'offline' | 'away' | 'busy'): void {\r\n    if (!this.presenceSocket || this.presenceSocket.readyState !== WebSocket.OPEN) {\r\n      console.error('Presence WebSocket is not connected');\r\n      return;\r\n    }\r\n\r\n    const message = {\r\n      type: 'status_update',\r\n      status\r\n    };\r\n\r\n    this.presenceSocket.send(JSON.stringify(message));\r\n  }\r\n\r\n  public joinChannel(channelId: number): void {\r\n    if (!this.chatSocket || this.chatSocket.readyState !== WebSocket.OPEN) {\r\n      console.error('Chat WebSocket is not connected');\r\n      return;\r\n    }\r\n\r\n    const message = {\r\n      type: 'join_channel',\r\n      channel_id: channelId\r\n    };\r\n\r\n    this.chatSocket.send(JSON.stringify(message));\r\n  }\r\n\r\n  public leaveChannel(channelId: number): void {\r\n    if (!this.chatSocket || this.chatSocket.readyState !== WebSocket.OPEN) {\r\n      console.error('Chat WebSocket is not connected');\r\n      return;\r\n    }\r\n\r\n    const message = {\r\n      type: 'leave_channel',\r\n      channel_id: channelId\r\n    };\r\n\r\n    this.chatSocket.send(JSON.stringify(message));\r\n  }\r\n\r\n  public onMessage(handler: (message: WebSocketMessage) => void): () => void {\r\n    this.messageHandlers.push(handler);\r\n    return () => {\r\n      this.messageHandlers = this.messageHandlers.filter(h => h !== handler);\r\n    };\r\n  }\r\n\r\n  public onPresence(handler: (message: WebSocketMessage) => void): () => void {\r\n    this.presenceHandlers.push(handler);\r\n    return () => {\r\n      this.presenceHandlers = this.presenceHandlers.filter(h => h !== handler);\r\n    };\r\n  }\r\n\r\n  private scheduleReconnect(): void {\r\n    if (this.reconnectTimeout) {\r\n      clearTimeout(this.reconnectTimeout);\r\n    }\r\n    this.reconnectTimeout = setTimeout(() => {\r\n      console.log('Attempting to reconnect WebSocket...');\r\n      this.connect();\r\n    }, this.RECONNECT_DELAY);\r\n  }\r\n}\r\n\r\n// Create a singleton instance\r\nconst wsService = new WebSocketService();\r\n\r\nexport { WebSocketService };\r\nexport default wsService; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}