{"ast":null,"code":"class MessageQueue {\n  constructor() {\n    this.messages = new Map();\n    this.lastSequence = 0;\n    this.STORAGE_KEY = 'ws_message_queue';\n    this.MAX_RETRIES = 3;\n    this.MAX_QUEUE_SIZE = 100;\n    this.loadFromStorage();\n    window.addEventListener('beforeunload', () => this.saveToStorage());\n  }\n  generateId() {\n    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n  loadFromStorage() {\n    try {\n      const stored = localStorage.getItem(this.STORAGE_KEY);\n      if (stored) {\n        const data = JSON.parse(stored);\n        this.messages = new Map(Object.entries(data.messages));\n        this.lastSequence = data.lastSequence;\n      }\n    } catch (error) {\n      console.error('Error loading message queue from storage:', error);\n    }\n  }\n  saveToStorage() {\n    try {\n      const data = {\n        messages: Object.fromEntries(this.messages),\n        lastSequence: this.lastSequence\n      };\n      localStorage.setItem(this.STORAGE_KEY, JSON.stringify(data));\n    } catch (error) {\n      console.error('Error saving message queue to storage:', error);\n    }\n  }\n  addMessage(channelId, content, type = 'message', parentId) {\n    const messageId = this.generateId();\n    const queuedMessage = {\n      id: messageId,\n      channelId,\n      content,\n      sequence: ++this.lastSequence,\n      timestamp: Date.now(),\n      attempts: 0,\n      type,\n      parentId\n    };\n    if (!this.messages.has(channelId)) {\n      this.messages.set(channelId, []);\n    }\n    const channelMessages = this.messages.get(channelId);\n\n    // Enforce queue size limit\n    if (channelMessages.length >= this.MAX_QUEUE_SIZE) {\n      channelMessages.shift(); // Remove oldest message\n    }\n    channelMessages.push(queuedMessage);\n    this.saveToStorage();\n    return messageId;\n  }\n  getNextMessage(channelId) {\n    const channelMessages = this.messages.get(channelId);\n    if (!(channelMessages !== null && channelMessages !== void 0 && channelMessages.length)) return null;\n\n    // Sort by sequence number to maintain order\n    channelMessages.sort((a, b) => a.sequence - b.sequence);\n\n    // Find first message that hasn't exceeded retry limit\n    const message = channelMessages.find(m => m.attempts < this.MAX_RETRIES);\n    if (!message) {\n      // If all messages have exceeded retries, remove them and return null\n      this.messages.set(channelId, channelMessages.filter(m => m.attempts < this.MAX_RETRIES));\n      return null;\n    }\n    return message;\n  }\n  markMessageAttempted(channelId, messageId) {\n    const channelMessages = this.messages.get(channelId);\n    if (!channelMessages) return;\n    const message = channelMessages.find(m => m.id === messageId);\n    if (message) {\n      message.attempts++;\n      this.saveToStorage();\n    }\n  }\n  markMessageSent(channelId, messageId) {\n    const channelMessages = this.messages.get(channelId);\n    if (!channelMessages) return;\n    this.messages.set(channelId, channelMessages.filter(m => m.id !== messageId));\n    this.saveToStorage();\n  }\n  getQueueLength(channelId) {\n    var _this$messages$get;\n    return ((_this$messages$get = this.messages.get(channelId)) === null || _this$messages$get === void 0 ? void 0 : _this$messages$get.length) || 0;\n  }\n  clear(channelId) {\n    if (channelId) {\n      this.messages.delete(channelId);\n    } else {\n      this.messages.clear();\n    }\n    this.saveToStorage();\n  }\n}\nexport const messageQueue = new MessageQueue();\nexport default messageQueue;","map":{"version":3,"names":["MessageQueue","constructor","messages","Map","lastSequence","STORAGE_KEY","MAX_RETRIES","MAX_QUEUE_SIZE","loadFromStorage","window","addEventListener","saveToStorage","generateId","Date","now","Math","random","toString","substr","stored","localStorage","getItem","data","JSON","parse","Object","entries","error","console","fromEntries","setItem","stringify","addMessage","channelId","content","type","parentId","messageId","queuedMessage","id","sequence","timestamp","attempts","has","set","channelMessages","get","length","shift","push","getNextMessage","sort","a","b","message","find","m","filter","markMessageAttempted","markMessageSent","getQueueLength","_this$messages$get","clear","delete","messageQueue"],"sources":["Z:/GAUNTLET/projects/SERMO/sermo-app/frontend/src/services/websocket/messageQueue.ts"],"sourcesContent":["import { WebSocketMessage } from '../../types';\r\n\r\ninterface QueuedMessage {\r\n  id: string;\r\n  channelId: string;\r\n  content: string;\r\n  sequence: number;\r\n  timestamp: number;\r\n  attempts: number;\r\n  type: 'message' | 'reply';\r\n  parentId?: string;\r\n}\r\n\r\nclass MessageQueue {\r\n  private messages: Map<string, QueuedMessage[]> = new Map();\r\n  private lastSequence: number = 0;\r\n  private readonly STORAGE_KEY = 'ws_message_queue';\r\n  private readonly MAX_RETRIES = 3;\r\n  private readonly MAX_QUEUE_SIZE = 100;\r\n\r\n  constructor() {\r\n    this.loadFromStorage();\r\n    window.addEventListener('beforeunload', () => this.saveToStorage());\r\n  }\r\n\r\n  private generateId(): string {\r\n    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\r\n  }\r\n\r\n  private loadFromStorage(): void {\r\n    try {\r\n      const stored = localStorage.getItem(this.STORAGE_KEY);\r\n      if (stored) {\r\n        const data = JSON.parse(stored);\r\n        this.messages = new Map(Object.entries(data.messages));\r\n        this.lastSequence = data.lastSequence;\r\n      }\r\n    } catch (error) {\r\n      console.error('Error loading message queue from storage:', error);\r\n    }\r\n  }\r\n\r\n  private saveToStorage(): void {\r\n    try {\r\n      const data = {\r\n        messages: Object.fromEntries(this.messages),\r\n        lastSequence: this.lastSequence\r\n      };\r\n      localStorage.setItem(this.STORAGE_KEY, JSON.stringify(data));\r\n    } catch (error) {\r\n      console.error('Error saving message queue to storage:', error);\r\n    }\r\n  }\r\n\r\n  addMessage(channelId: string, content: string, type: 'message' | 'reply' = 'message', parentId?: string): string {\r\n    const messageId = this.generateId();\r\n    const queuedMessage: QueuedMessage = {\r\n      id: messageId,\r\n      channelId,\r\n      content,\r\n      sequence: ++this.lastSequence,\r\n      timestamp: Date.now(),\r\n      attempts: 0,\r\n      type,\r\n      parentId\r\n    };\r\n\r\n    if (!this.messages.has(channelId)) {\r\n      this.messages.set(channelId, []);\r\n    }\r\n\r\n    const channelMessages = this.messages.get(channelId)!;\r\n    \r\n    // Enforce queue size limit\r\n    if (channelMessages.length >= this.MAX_QUEUE_SIZE) {\r\n      channelMessages.shift(); // Remove oldest message\r\n    }\r\n    \r\n    channelMessages.push(queuedMessage);\r\n    this.saveToStorage();\r\n    \r\n    return messageId;\r\n  }\r\n\r\n  getNextMessage(channelId: string): QueuedMessage | null {\r\n    const channelMessages = this.messages.get(channelId);\r\n    if (!channelMessages?.length) return null;\r\n\r\n    // Sort by sequence number to maintain order\r\n    channelMessages.sort((a, b) => a.sequence - b.sequence);\r\n    \r\n    // Find first message that hasn't exceeded retry limit\r\n    const message = channelMessages.find(m => m.attempts < this.MAX_RETRIES);\r\n    if (!message) {\r\n      // If all messages have exceeded retries, remove them and return null\r\n      this.messages.set(channelId, channelMessages.filter(m => m.attempts < this.MAX_RETRIES));\r\n      return null;\r\n    }\r\n\r\n    return message;\r\n  }\r\n\r\n  markMessageAttempted(channelId: string, messageId: string): void {\r\n    const channelMessages = this.messages.get(channelId);\r\n    if (!channelMessages) return;\r\n\r\n    const message = channelMessages.find(m => m.id === messageId);\r\n    if (message) {\r\n      message.attempts++;\r\n      this.saveToStorage();\r\n    }\r\n  }\r\n\r\n  markMessageSent(channelId: string, messageId: string): void {\r\n    const channelMessages = this.messages.get(channelId);\r\n    if (!channelMessages) return;\r\n\r\n    this.messages.set(\r\n      channelId,\r\n      channelMessages.filter(m => m.id !== messageId)\r\n    );\r\n    this.saveToStorage();\r\n  }\r\n\r\n  getQueueLength(channelId: string): number {\r\n    return this.messages.get(channelId)?.length || 0;\r\n  }\r\n\r\n  clear(channelId?: string): void {\r\n    if (channelId) {\r\n      this.messages.delete(channelId);\r\n    } else {\r\n      this.messages.clear();\r\n    }\r\n    this.saveToStorage();\r\n  }\r\n}\r\n\r\nexport const messageQueue = new MessageQueue();\r\nexport default messageQueue; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}