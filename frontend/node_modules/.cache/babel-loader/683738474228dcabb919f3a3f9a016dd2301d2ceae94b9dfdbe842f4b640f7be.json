{"ast":null,"code":"import { store } from '../../store';\nimport { addReaction, removeReaction } from '../../store/messages/messagesSlice';\n// Get WebSocket URL from environment variable or fallback to localhost\nconst WS_BASE_URL = process.env.REACT_APP_WS_URL || 'ws://localhost:8000/ws';\n\n// Helper function to get the correct WebSocket URL based on the current protocol\nconst getWebSocketUrl = () => {\n  // If we're on HTTPS, use WSS\n  if (window.location.protocol === 'https:' && WS_BASE_URL.startsWith('ws:')) {\n    return WS_BASE_URL.replace('ws:', 'wss:');\n  }\n  return WS_BASE_URL;\n};\nfunction isReactionAddedMessage(message) {\n  return message.type === 'reaction_added' && 'payload' in message && message.payload && 'channelId' in message.payload && 'messageId' in message.payload && 'reaction' in message.payload;\n}\nfunction isReactionRemovedMessage(message) {\n  return message.type === 'reaction_removed' && 'payload' in message && message.payload && 'channelId' in message.payload && 'messageId' in message.payload && 'userId' in message.payload && 'emoji' in message.payload;\n}\nfunction isNewMessageMessage(message) {\n  return message.type === 'new_message' && 'channelId' in message && 'message' in message;\n}\nfunction isUpdateMessageMessage(message) {\n  return message.type === 'update_message' && 'channelId' in message && 'id' in message && 'updates' in message;\n}\nfunction isUserStatusMessage(message) {\n  return message.type === 'user_status' && 'userId' in message && 'status' in message;\n}\nexport class WebSocketService {\n  static connect() {\n    var _this$ws;\n    if (((_this$ws = this.ws) === null || _this$ws === void 0 ? void 0 : _this$ws.readyState) === WebSocket.OPEN) {\n      console.log('WebSocket already connected');\n      return;\n    }\n    console.log('Connecting WebSocket...');\n    this.ws = new WebSocket(WEBSOCKET_URL);\n    this.ws.onopen = () => {\n      console.log('WebSocket connected, current channels:', Array.from(this.channels));\n      // Rejoin all channels after reconnection\n      for (const channelId of Array.from(this.channels)) {\n        console.log('Rejoining channel after connection:', channelId);\n        this.joinChannel(channelId);\n      }\n    };\n    this.ws.onclose = () => {\n      console.log('WebSocket disconnected, channels at disconnect:', Array.from(this.channels));\n      setTimeout(() => this.connect(), 1000);\n    };\n    this.ws.onerror = error => {\n      console.error('WebSocket error:', error);\n    };\n    this.ws.onmessage = event => {\n      try {\n        const data = JSON.parse(event.data);\n        console.log('Received WebSocket message:', data);\n        if (isReactionAddedMessage(data)) {\n          const {\n            channelId,\n            messageId,\n            reaction\n          } = data.payload;\n          console.log('Checking channel subscription for reaction:', channelId, 'Current channels:', Array.from(this.channels));\n          if (!this.channels.has(channelId)) {\n            console.warn('Received reaction for unsubscribed channel:', channelId);\n            return;\n          }\n          console.log('Dispatching addReaction:', {\n            channelId,\n            messageId,\n            reaction\n          });\n          this.store.dispatch(addReaction({\n            channelId,\n            messageId,\n            reaction\n          }));\n        } else if (isReactionRemovedMessage(data)) {\n          const {\n            channelId,\n            messageId,\n            userId,\n            emoji\n          } = data.payload;\n          console.log('Checking channel subscription for reaction removal:', channelId, 'Current channels:', Array.from(this.channels));\n          if (!this.channels.has(channelId)) {\n            console.warn('Received reaction removal for unsubscribed channel:', channelId);\n            return;\n          }\n          console.log('Dispatching removeReaction:', {\n            channelId,\n            messageId,\n            userId,\n            emoji\n          });\n          this.store.dispatch(removeReaction({\n            channelId,\n            messageId,\n            userId,\n            emoji\n          }));\n        }\n        // ... rest of the message handling\n      } catch (error) {\n        console.error('Error handling WebSocket message:', error);\n      }\n    };\n  }\n  static joinChannel(channelId) {\n    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\n      console.warn('Cannot join channel - WebSocket not connected:', channelId);\n      return;\n    }\n    console.log('Joining channel:', channelId);\n    this.channels.add(channelId);\n    this.ws.send(JSON.stringify({\n      type: 'join',\n      channel: channelId\n    }));\n  }\n  static leaveChannel(channelId) {\n    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\n      console.warn('Cannot leave channel - WebSocket not connected:', channelId);\n      return;\n    }\n    console.log('Leaving channel:', channelId);\n    this.channels.delete(channelId);\n    this.ws.send(JSON.stringify({\n      type: 'leave',\n      channel: channelId\n    }));\n  }\n}\nWebSocketService.ws = null;\nWebSocketService.channels = new Set();\nWebSocketService.store = void 0;\nexport default new WebSocketService(store);","map":{"version":3,"names":["store","addReaction","removeReaction","WS_BASE_URL","process","env","REACT_APP_WS_URL","getWebSocketUrl","window","location","protocol","startsWith","replace","isReactionAddedMessage","message","type","payload","isReactionRemovedMessage","isNewMessageMessage","isUpdateMessageMessage","isUserStatusMessage","WebSocketService","connect","_this$ws","ws","readyState","WebSocket","OPEN","console","log","WEBSOCKET_URL","onopen","Array","from","channels","channelId","joinChannel","onclose","setTimeout","onerror","error","onmessage","event","data","JSON","parse","messageId","reaction","has","warn","dispatch","userId","emoji","add","send","stringify","channel","leaveChannel","delete","Set"],"sources":["Z:/GAUNTLET/projects/SERMO/sermo-app/frontend/src/services/websocket/index.ts"],"sourcesContent":["import { Reaction, RawMessage, UserStatus } from '../../types';\nimport { store } from '../../store';\nimport { addMessage, updateMessage, addReaction, removeReaction } from '../../store/messages/messagesSlice';\nimport { updateUserStatus } from '../../store/chat/chatSlice';\nimport { Store } from 'redux';\nimport { transformMessage } from '../../utils/messageTransform';\n\n// Get WebSocket URL from environment variable or fallback to localhost\nconst WS_BASE_URL = process.env.REACT_APP_WS_URL || 'ws://localhost:8000/ws';\n\n// Helper function to get the correct WebSocket URL based on the current protocol\nconst getWebSocketUrl = () => {\n  // If we're on HTTPS, use WSS\n  if (window.location.protocol === 'https:' && WS_BASE_URL.startsWith('ws:')) {\n    return WS_BASE_URL.replace('ws:', 'wss:');\n  }\n  return WS_BASE_URL;\n};\n\ninterface BaseWebSocketMessage {\n  type: string;\n  data?: any;\n}\n\ninterface ReactionAddedMessage extends BaseWebSocketMessage {\n  type: 'reaction_added';\n  payload: {\n    channelId: string;\n    messageId: string;\n    reaction: Reaction;\n  };\n}\n\ninterface ReactionRemovedMessage extends BaseWebSocketMessage {\n  type: 'reaction_removed';\n  payload: {\n    channelId: string;\n    messageId: string;\n    userId: string;\n    emoji: string;\n  };\n}\n\ninterface NewMessageMessage extends BaseWebSocketMessage {\n  type: 'new_message';\n  channelId: string;\n  message: RawMessage;\n  isReply?: boolean;\n  parentId?: string;\n}\n\ninterface UpdateMessageMessage extends BaseWebSocketMessage {\n  type: 'update_message';\n  channelId: string;\n  id: string;\n  updates: Partial<RawMessage>;\n}\n\ninterface UserStatusMessage extends BaseWebSocketMessage {\n  type: 'user_status';\n  userId: string;\n  status: UserStatus;\n}\n\ntype WebSocketMessage = \n  | ReactionAddedMessage \n  | ReactionRemovedMessage \n  | NewMessageMessage \n  | UpdateMessageMessage \n  | UserStatusMessage \n  | BaseWebSocketMessage;\n\nfunction isReactionAddedMessage(message: WebSocketMessage): message is ReactionAddedMessage {\n  return message.type === 'reaction_added' && \n         'payload' in message && \n         message.payload && \n         'channelId' in message.payload &&\n         'messageId' in message.payload &&\n         'reaction' in message.payload;\n}\n\nfunction isReactionRemovedMessage(message: WebSocketMessage): message is ReactionRemovedMessage {\n  return message.type === 'reaction_removed' && \n         'payload' in message && \n         message.payload && \n         'channelId' in message.payload &&\n         'messageId' in message.payload &&\n         'userId' in message.payload &&\n         'emoji' in message.payload;\n}\n\nfunction isNewMessageMessage(message: WebSocketMessage): message is NewMessageMessage {\n  return message.type === 'new_message' && \n         'channelId' in message && \n         'message' in message;\n}\n\nfunction isUpdateMessageMessage(message: WebSocketMessage): message is UpdateMessageMessage {\n  return message.type === 'update_message' && \n         'channelId' in message && \n         'id' in message && \n         'updates' in message;\n}\n\nfunction isUserStatusMessage(message: WebSocketMessage): message is UserStatusMessage {\n  return message.type === 'user_status' && \n         'userId' in message && \n         'status' in message;\n}\n\nexport class WebSocketService {\n  private static ws: WebSocket | null = null;\n  private static channels: Set<string> = new Set();\n  private static store: Store;\n\n  static connect() {\n    if (this.ws?.readyState === WebSocket.OPEN) {\n      console.log('WebSocket already connected');\n      return;\n    }\n\n    console.log('Connecting WebSocket...');\n    this.ws = new WebSocket(WEBSOCKET_URL);\n\n    this.ws.onopen = () => {\n      console.log('WebSocket connected, current channels:', Array.from(this.channels));\n      // Rejoin all channels after reconnection\n      for (const channelId of Array.from(this.channels)) {\n        console.log('Rejoining channel after connection:', channelId);\n        this.joinChannel(channelId);\n      }\n    };\n\n    this.ws.onclose = () => {\n      console.log('WebSocket disconnected, channels at disconnect:', Array.from(this.channels));\n      setTimeout(() => this.connect(), 1000);\n    };\n\n    this.ws.onerror = (error) => {\n      console.error('WebSocket error:', error);\n    };\n\n    this.ws.onmessage = (event) => {\n      try {\n        const data = JSON.parse(event.data);\n        console.log('Received WebSocket message:', data);\n\n        if (isReactionAddedMessage(data)) {\n          const { channelId, messageId, reaction } = data.payload;\n          console.log('Checking channel subscription for reaction:', channelId, 'Current channels:', Array.from(this.channels));\n          \n          if (!this.channels.has(channelId)) {\n            console.warn('Received reaction for unsubscribed channel:', channelId);\n            return;\n          }\n\n          console.log('Dispatching addReaction:', { channelId, messageId, reaction });\n          this.store.dispatch(addReaction({ channelId, messageId, reaction }));\n        }\n        else if (isReactionRemovedMessage(data)) {\n          const { channelId, messageId, userId, emoji } = data.payload;\n          console.log('Checking channel subscription for reaction removal:', channelId, 'Current channels:', Array.from(this.channels));\n          \n          if (!this.channels.has(channelId)) {\n            console.warn('Received reaction removal for unsubscribed channel:', channelId);\n            return;\n          }\n\n          console.log('Dispatching removeReaction:', { channelId, messageId, userId, emoji });\n          this.store.dispatch(removeReaction({ channelId, messageId, userId, emoji }));\n        }\n        // ... rest of the message handling\n      } catch (error) {\n        console.error('Error handling WebSocket message:', error);\n      }\n    };\n  }\n\n  static joinChannel(channelId: string) {\n    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\n      console.warn('Cannot join channel - WebSocket not connected:', channelId);\n      return;\n    }\n\n    console.log('Joining channel:', channelId);\n    this.channels.add(channelId);\n    this.ws.send(JSON.stringify({ type: 'join', channel: channelId }));\n  }\n\n  static leaveChannel(channelId: string) {\n    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\n      console.warn('Cannot leave channel - WebSocket not connected:', channelId);\n      return;\n    }\n\n    console.log('Leaving channel:', channelId);\n    this.channels.delete(channelId);\n    this.ws.send(JSON.stringify({ type: 'leave', channel: channelId }));\n  }\n}\n\nexport default new WebSocketService(store); "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}