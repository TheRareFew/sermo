{"ast":null,"code":"import { getAuthToken } from '../api/auth';\nimport { store } from '../../store';\nimport { setError } from '../../store/error/errorSlice';\nimport messageQueue from './messageQueue';\n// Default configuration\nconst DEFAULT_CONFIG = {\n  baseUrl: 'ws://localhost:8000',\n  heartbeatInterval: 15000,\n  heartbeatTimeout: 30000,\n  reconnectInterval: 1000,\n  maxReconnectAttempts: 5,\n  connectionTimeout: 5000\n};\nclass WebSocketService {\n  constructor(config = {}) {\n    this.chatSocket = null;\n    this.presenceSocket = null;\n    this.config = void 0;\n    this.messageHandlers = new Map();\n    this.errorHandlers = new Map();\n    this.joinedChannels = new Set();\n    this.reconnectAttempts = new Map();\n    this.heartbeatIntervals = new Map();\n    this.lastHeartbeatResponses = new Map();\n    this.isReconnecting = new Map();\n    this.config = {\n      ...DEFAULT_CONFIG,\n      ...config\n    };\n    this.setupErrorHandlers();\n  }\n  setupErrorHandlers() {\n    window.addEventListener('online', () => {\n      this.handleOnline();\n    });\n    window.addEventListener('offline', () => {\n      this.handleOffline();\n    });\n    window.addEventListener('beforeunload', () => {\n      this.cleanup();\n    });\n  }\n  handleOnline() {\n    console.log('[WebSocket] Network connection restored');\n    this.reconnectAll();\n  }\n  handleOffline() {\n    console.log('[WebSocket] Network connection lost');\n    this.cleanup();\n  }\n  async reconnectAll() {\n    try {\n      await this.connectPresence();\n      await this.processJoinedChannels();\n    } catch (error) {\n      console.error('[WebSocket] Reconnection failed:', error);\n    }\n  }\n  async processJoinedChannels() {\n    for (const channelId of this.joinedChannels) {\n      try {\n        await this.joinChannel(channelId);\n      } catch (error) {\n        console.error(`[WebSocket] Failed to rejoin channel ${channelId}:`, error);\n      }\n    }\n  }\n\n  // Connect to the presence WebSocket\n  async connectPresence() {\n    var _this$presenceSocket;\n    if (((_this$presenceSocket = this.presenceSocket) === null || _this$presenceSocket === void 0 ? void 0 : _this$presenceSocket.readyState) === WebSocket.OPEN) {\n      return;\n    }\n    const token = getAuthToken();\n    if (!token) {\n      throw new Error('No authentication token found');\n    }\n    try {\n      this.presenceSocket = new WebSocket(`${this.config.baseUrl}/presence?token=${token}`);\n      await this.setupSocketConnection('presence', this.presenceSocket);\n      this.startHeartbeat('presence');\n    } catch (error) {\n      console.error('[WebSocket] Presence connection failed:', error);\n      this.handleError('presence', error instanceof Error ? error : new Error('Presence connection failed'));\n      throw error;\n    }\n  }\n\n  // Connect to the chat WebSocket\n  async connectChat() {\n    var _this$chatSocket;\n    if (((_this$chatSocket = this.chatSocket) === null || _this$chatSocket === void 0 ? void 0 : _this$chatSocket.readyState) === WebSocket.OPEN) {\n      return;\n    }\n    const token = getAuthToken();\n    if (!token) {\n      throw new Error('No authentication token found');\n    }\n    try {\n      this.chatSocket = new WebSocket(`${this.config.baseUrl}/chat?token=${token}`);\n      await this.setupSocketConnection('chat', this.chatSocket);\n      this.startHeartbeat('chat');\n    } catch (error) {\n      console.error('[WebSocket] Chat connection failed:', error);\n      this.handleError('chat', error instanceof Error ? error : new Error('Chat connection failed'));\n      throw error;\n    }\n  }\n  async setupSocketConnection(type, socket) {\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error(`${type} connection timeout`));\n      }, this.config.connectionTimeout);\n      socket.onopen = () => {\n        console.log(`[WebSocket] ${type} connection opened`);\n        clearTimeout(timeout);\n        resolve();\n      };\n      socket.onclose = event => {\n        console.log(`[WebSocket] ${type} connection closed:`, event);\n        this.handleClose(type);\n      };\n      socket.onerror = error => {\n        console.error(`[WebSocket] ${type} connection error:`, error);\n        clearTimeout(timeout);\n        reject(error);\n      };\n      socket.onmessage = event => {\n        this.handleMessage(type, event);\n      };\n    });\n  }\n  startHeartbeat(type) {\n    if (this.heartbeatIntervals.has(type)) {\n      clearInterval(this.heartbeatIntervals.get(type));\n    }\n    this.heartbeatIntervals.set(type, setInterval(() => {\n      const socket = type === 'chat' ? this.chatSocket : this.presenceSocket;\n      if ((socket === null || socket === void 0 ? void 0 : socket.readyState) === WebSocket.OPEN) {\n        socket.send(JSON.stringify({\n          type: 'ping'\n        }));\n        if (Date.now() - (this.lastHeartbeatResponses.get(type) || 0) > this.config.heartbeatTimeout) {\n          console.error(`[WebSocket] ${type} heartbeat timeout, reconnecting...`);\n          this.handleClose(type);\n        }\n      }\n    }, this.config.heartbeatInterval));\n  }\n  async handleClose(type) {\n    if (this.isReconnecting.get(type)) return;\n    this.isReconnecting.set(type, true);\n    const attempts = this.reconnectAttempts.get(type) || 0;\n    if (attempts < this.config.maxReconnectAttempts) {\n      const delay = Math.min(this.config.reconnectInterval * Math.pow(2, attempts), 30000);\n      console.log(`[WebSocket] Attempting to reconnect ${type} in ${delay}ms (attempt ${attempts + 1})`);\n      setTimeout(async () => {\n        try {\n          this.reconnectAttempts.set(type, attempts + 1);\n          if (type === 'chat') {\n            await this.connectChat();\n            await this.processJoinedChannels();\n          } else {\n            await this.connectPresence();\n          }\n          this.isReconnecting.set(type, false);\n          this.reconnectAttempts.set(type, 0);\n        } catch (error) {\n          console.error(`[WebSocket] ${type} reconnection failed:`, error);\n          this.handleClose(type);\n        }\n      }, delay);\n    } else {\n      console.error(`[WebSocket] ${type} max reconnection attempts reached`);\n      this.isReconnecting.set(type, false);\n      store.dispatch(setError(`Lost connection to ${type} server. Please refresh the page.`));\n    }\n  }\n  handleMessage(type, event) {\n    try {\n      const message = JSON.parse(event.data);\n\n      // Update heartbeat timestamp for pong messages\n      if (message.type === 'pong') {\n        this.lastHeartbeatResponses.set(type, Date.now());\n        return;\n      }\n\n      // Handle error messages\n      if (message.type === 'error') {\n        console.error(`[WebSocket] ${type} error:`, message);\n        store.dispatch(setError(message.message));\n        return;\n      }\n\n      // Dispatch message to handlers\n      const handlers = this.messageHandlers.get(type) || [];\n      handlers.forEach(handler => {\n        try {\n          handler(message);\n        } catch (error) {\n          console.error(`[WebSocket] Error in ${type} message handler:`, error);\n        }\n      });\n    } catch (error) {\n      console.error(`[WebSocket] Error parsing ${type} message:`, error);\n    }\n  }\n  handleError(type, error) {\n    console.error(`[WebSocket] ${type} error:`, error);\n    const handlers = this.errorHandlers.get(type) || [];\n    handlers.forEach(handler => handler(error));\n  }\n\n  // Join a chat channel\n  async joinChannel(channelId) {\n    if (!this.chatSocket || this.chatSocket.readyState !== WebSocket.OPEN) {\n      await this.connectChat();\n    }\n    if (this.joinedChannels.has(channelId)) {\n      return;\n    }\n    return new Promise((resolve, reject) => {\n      const joinMessage = {\n        type: 'join_channel',\n        channel_id: channelId\n      };\n      const timeout = setTimeout(() => {\n        reject(new Error('Channel join timeout'));\n      }, 10000);\n      const handleJoinResponse = message => {\n        if (message.type === 'channel_joined' && 'channel_id' in message && message.channel_id === channelId) {\n          clearTimeout(timeout);\n          this.joinedChannels.add(channelId);\n          resolve();\n        } else if (message.type === 'error') {\n          clearTimeout(timeout);\n          reject(new Error(message.message));\n        }\n      };\n      this.onMessage('chat', handleJoinResponse);\n      this.chatSocket.send(JSON.stringify(joinMessage));\n    });\n  }\n\n  // Leave a chat channel\n  async leaveChannel(channelId) {\n    if (!this.chatSocket || this.chatSocket.readyState !== WebSocket.OPEN) {\n      return;\n    }\n    const leaveMessage = {\n      type: 'leave_channel',\n      channel_id: channelId\n    };\n    this.chatSocket.send(JSON.stringify(leaveMessage));\n    this.joinedChannels.delete(channelId);\n  }\n\n  // Send a chat message\n  async sendMessage(channelId, content, parentId) {\n    const message = {\n      type: 'message',\n      channel_id: channelId,\n      content,\n      parent_id: parentId\n    };\n    const queueId = messageQueue.enqueue(message);\n    if (!this.chatSocket || this.chatSocket.readyState !== WebSocket.OPEN) {\n      try {\n        await this.connectChat();\n        await this.joinChannel(channelId);\n      } catch (error) {\n        console.error('[WebSocket] Failed to connect for message:', error);\n        return;\n      }\n    }\n    try {\n      messageQueue.markAttempted(queueId);\n      this.chatSocket.send(JSON.stringify(message));\n    } catch (error) {\n      console.error('[WebSocket] Error sending message:', error);\n    }\n  }\n\n  // Update user status\n  async updateStatus(status) {\n    if (!this.presenceSocket || this.presenceSocket.readyState !== WebSocket.OPEN) {\n      await this.connectPresence();\n    }\n    const statusMessage = {\n      type: 'status_update',\n      status\n    };\n    this.presenceSocket.send(JSON.stringify(statusMessage));\n  }\n\n  // Add message handler\n  onMessage(type, handler) {\n    if (!this.messageHandlers.has(type)) {\n      this.messageHandlers.set(type, []);\n    }\n    this.messageHandlers.get(type).push(handler);\n    return () => this.offMessage(type, handler);\n  }\n\n  // Remove message handler\n  offMessage(type, handler) {\n    if (!this.messageHandlers.has(type)) return;\n    this.messageHandlers.set(type, this.messageHandlers.get(type).filter(h => h !== handler));\n  }\n\n  // Add error handler\n  onError(type, handler) {\n    if (!this.errorHandlers.has(type)) {\n      this.errorHandlers.set(type, []);\n    }\n    this.errorHandlers.get(type).push(handler);\n    return () => this.offError(type, handler);\n  }\n\n  // Remove error handler\n  offError(type, handler) {\n    if (!this.errorHandlers.has(type)) return;\n    this.errorHandlers.set(type, this.errorHandlers.get(type).filter(h => h !== handler));\n  }\n\n  // Get connection state\n  getConnectionState(type) {\n    var _socket$readyState;\n    const socket = type === 'chat' ? this.chatSocket : this.presenceSocket;\n    return (_socket$readyState = socket === null || socket === void 0 ? void 0 : socket.readyState) !== null && _socket$readyState !== void 0 ? _socket$readyState : WebSocket.CLOSED;\n  }\n\n  // Cleanup connections\n  cleanup() {\n    ['chat', 'presence'].forEach(type => {\n      const socket = type === 'chat' ? this.chatSocket : this.presenceSocket;\n      if (socket && socket.readyState === WebSocket.OPEN) {\n        socket.close(1000);\n      }\n      if (this.heartbeatIntervals.has(type)) {\n        clearInterval(this.heartbeatIntervals.get(type));\n      }\n    });\n    this.chatSocket = null;\n    this.presenceSocket = null;\n    this.joinedChannels.clear();\n    this.messageHandlers.clear();\n    this.errorHandlers.clear();\n    this.reconnectAttempts.clear();\n    this.heartbeatIntervals.clear();\n    this.lastHeartbeatResponses.clear();\n    this.isReconnecting.clear();\n  }\n}\n\n// Create and export singleton instance\nconst wsService = new WebSocketService();\nexport default wsService;","map":{"version":3,"names":["getAuthToken","store","setError","messageQueue","DEFAULT_CONFIG","baseUrl","heartbeatInterval","heartbeatTimeout","reconnectInterval","maxReconnectAttempts","connectionTimeout","WebSocketService","constructor","config","chatSocket","presenceSocket","messageHandlers","Map","errorHandlers","joinedChannels","Set","reconnectAttempts","heartbeatIntervals","lastHeartbeatResponses","isReconnecting","setupErrorHandlers","window","addEventListener","handleOnline","handleOffline","cleanup","console","log","reconnectAll","connectPresence","processJoinedChannels","error","channelId","joinChannel","_this$presenceSocket","readyState","WebSocket","OPEN","token","Error","setupSocketConnection","startHeartbeat","handleError","connectChat","_this$chatSocket","type","socket","Promise","resolve","reject","timeout","setTimeout","onopen","clearTimeout","onclose","event","handleClose","onerror","onmessage","handleMessage","has","clearInterval","get","set","setInterval","send","JSON","stringify","Date","now","attempts","delay","Math","min","pow","dispatch","message","parse","data","handlers","forEach","handler","joinMessage","channel_id","handleJoinResponse","add","onMessage","leaveChannel","leaveMessage","delete","sendMessage","content","parentId","parent_id","queueId","enqueue","markAttempted","updateStatus","status","statusMessage","push","offMessage","filter","h","onError","offError","getConnectionState","_socket$readyState","CLOSED","close","clear","wsService"],"sources":["Z:/GAUNTLET/projects/SERMO/sermo-app/frontend/src/services/websocket/index.ts"],"sourcesContent":["import { WebSocketMessage, WebSocketConfig, WebSocketConnectionState, StatusUpdateMessage, ChatMessage } from '../../types/websocket';\nimport { getAuthToken } from '../api/auth';\nimport { store } from '../../store';\nimport { setError } from '../../store/error/errorSlice';\nimport { updateUserStatus } from '../../store/users/usersSlice';\nimport { addMessage, updateMessage, deleteMessage } from '../../store/messages/messagesSlice';\nimport messageQueue from './messageQueue';\nimport { v4 as uuidv4 } from 'uuid';\n\n// Default configuration\nconst DEFAULT_CONFIG: WebSocketConfig = {\n  baseUrl: 'ws://localhost:8000',\n  heartbeatInterval: 15000,\n  heartbeatTimeout: 30000,\n  reconnectInterval: 1000,\n  maxReconnectAttempts: 5,\n  connectionTimeout: 5000\n};\n\nclass WebSocketService {\n  private chatSocket: WebSocket | null = null;\n  private presenceSocket: WebSocket | null = null;\n  private config: WebSocketConfig;\n  private messageHandlers: Map<string, ((message: WebSocketMessage) => void)[]> = new Map();\n  private errorHandlers: Map<string, ((error: Error) => void)[]> = new Map();\n  private joinedChannels: Set<number> = new Set();\n  private reconnectAttempts: Map<string, number> = new Map();\n  private heartbeatIntervals: Map<string, NodeJS.Timeout> = new Map();\n  private lastHeartbeatResponses: Map<string, number> = new Map();\n  private isReconnecting: Map<string, boolean> = new Map();\n\n  constructor(config: Partial<WebSocketConfig> = {}) {\n    this.config = { ...DEFAULT_CONFIG, ...config };\n    this.setupErrorHandlers();\n  }\n\n  private setupErrorHandlers(): void {\n    window.addEventListener('online', () => {\n      this.handleOnline();\n    });\n\n    window.addEventListener('offline', () => {\n      this.handleOffline();\n    });\n\n    window.addEventListener('beforeunload', () => {\n      this.cleanup();\n    });\n  }\n\n  private handleOnline(): void {\n    console.log('[WebSocket] Network connection restored');\n    this.reconnectAll();\n  }\n\n  private handleOffline(): void {\n    console.log('[WebSocket] Network connection lost');\n    this.cleanup();\n  }\n\n  private async reconnectAll(): Promise<void> {\n    try {\n      await this.connectPresence();\n      await this.processJoinedChannels();\n    } catch (error) {\n      console.error('[WebSocket] Reconnection failed:', error);\n    }\n  }\n\n  private async processJoinedChannels(): Promise<void> {\n    for (const channelId of this.joinedChannels) {\n      try {\n        await this.joinChannel(channelId);\n      } catch (error) {\n        console.error(`[WebSocket] Failed to rejoin channel ${channelId}:`, error);\n      }\n    }\n  }\n\n  // Connect to the presence WebSocket\n  public async connectPresence(): Promise<void> {\n    if (this.presenceSocket?.readyState === WebSocket.OPEN) {\n      return;\n    }\n\n    const token = getAuthToken();\n    if (!token) {\n      throw new Error('No authentication token found');\n    }\n\n    try {\n      this.presenceSocket = new WebSocket(`${this.config.baseUrl}/presence?token=${token}`);\n      await this.setupSocketConnection('presence', this.presenceSocket);\n      this.startHeartbeat('presence');\n    } catch (error) {\n      console.error('[WebSocket] Presence connection failed:', error);\n      this.handleError('presence', error instanceof Error ? error : new Error('Presence connection failed'));\n      throw error;\n    }\n  }\n\n  // Connect to the chat WebSocket\n  private async connectChat(): Promise<void> {\n    if (this.chatSocket?.readyState === WebSocket.OPEN) {\n      return;\n    }\n\n    const token = getAuthToken();\n    if (!token) {\n      throw new Error('No authentication token found');\n    }\n\n    try {\n      this.chatSocket = new WebSocket(`${this.config.baseUrl}/chat?token=${token}`);\n      await this.setupSocketConnection('chat', this.chatSocket);\n      this.startHeartbeat('chat');\n    } catch (error) {\n      console.error('[WebSocket] Chat connection failed:', error);\n      this.handleError('chat', error instanceof Error ? error : new Error('Chat connection failed'));\n      throw error;\n    }\n  }\n\n  private async setupSocketConnection(type: string, socket: WebSocket): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error(`${type} connection timeout`));\n      }, this.config.connectionTimeout);\n\n      socket.onopen = () => {\n        console.log(`[WebSocket] ${type} connection opened`);\n        clearTimeout(timeout);\n        resolve();\n      };\n\n      socket.onclose = (event) => {\n        console.log(`[WebSocket] ${type} connection closed:`, event);\n        this.handleClose(type);\n      };\n\n      socket.onerror = (error) => {\n        console.error(`[WebSocket] ${type} connection error:`, error);\n        clearTimeout(timeout);\n        reject(error);\n      };\n\n      socket.onmessage = (event) => {\n        this.handleMessage(type, event);\n      };\n    });\n  }\n\n  private startHeartbeat(type: string): void {\n    if (this.heartbeatIntervals.has(type)) {\n      clearInterval(this.heartbeatIntervals.get(type)!);\n    }\n\n    this.heartbeatIntervals.set(\n      type,\n      setInterval(() => {\n        const socket = type === 'chat' ? this.chatSocket : this.presenceSocket;\n        if (socket?.readyState === WebSocket.OPEN) {\n          socket.send(JSON.stringify({ type: 'ping' }));\n\n          if (Date.now() - (this.lastHeartbeatResponses.get(type) || 0) > this.config.heartbeatTimeout) {\n            console.error(`[WebSocket] ${type} heartbeat timeout, reconnecting...`);\n            this.handleClose(type);\n          }\n        }\n      }, this.config.heartbeatInterval)\n    );\n  }\n\n  private async handleClose(type: string): Promise<void> {\n    if (this.isReconnecting.get(type)) return;\n\n    this.isReconnecting.set(type, true);\n    const attempts = this.reconnectAttempts.get(type) || 0;\n\n    if (attempts < this.config.maxReconnectAttempts) {\n      const delay = Math.min(\n        this.config.reconnectInterval * Math.pow(2, attempts),\n        30000\n      );\n\n      console.log(`[WebSocket] Attempting to reconnect ${type} in ${delay}ms (attempt ${attempts + 1})`);\n\n      setTimeout(async () => {\n        try {\n          this.reconnectAttempts.set(type, attempts + 1);\n          if (type === 'chat') {\n            await this.connectChat();\n            await this.processJoinedChannels();\n          } else {\n            await this.connectPresence();\n          }\n          this.isReconnecting.set(type, false);\n          this.reconnectAttempts.set(type, 0);\n        } catch (error) {\n          console.error(`[WebSocket] ${type} reconnection failed:`, error);\n          this.handleClose(type);\n        }\n      }, delay);\n    } else {\n      console.error(`[WebSocket] ${type} max reconnection attempts reached`);\n      this.isReconnecting.set(type, false);\n      store.dispatch(setError(`Lost connection to ${type} server. Please refresh the page.`));\n    }\n  }\n\n  private handleMessage(type: string, event: MessageEvent): void {\n    try {\n      const message = JSON.parse(event.data) as WebSocketMessage;\n      \n      // Update heartbeat timestamp for pong messages\n      if (message.type === 'pong') {\n        this.lastHeartbeatResponses.set(type, Date.now());\n        return;\n      }\n\n      // Handle error messages\n      if (message.type === 'error') {\n        console.error(`[WebSocket] ${type} error:`, message);\n        store.dispatch(setError(message.message));\n        return;\n      }\n\n      // Dispatch message to handlers\n      const handlers = this.messageHandlers.get(type) || [];\n      handlers.forEach(handler => {\n        try {\n          handler(message);\n        } catch (error) {\n          console.error(`[WebSocket] Error in ${type} message handler:`, error);\n        }\n      });\n    } catch (error) {\n      console.error(`[WebSocket] Error parsing ${type} message:`, error);\n    }\n  }\n\n  private handleError(type: string, error: Error): void {\n    console.error(`[WebSocket] ${type} error:`, error);\n    const handlers = this.errorHandlers.get(type) || [];\n    handlers.forEach(handler => handler(error));\n  }\n\n  // Join a chat channel\n  public async joinChannel(channelId: number): Promise<void> {\n    if (!this.chatSocket || this.chatSocket.readyState !== WebSocket.OPEN) {\n      await this.connectChat();\n    }\n\n    if (this.joinedChannels.has(channelId)) {\n      return;\n    }\n\n    return new Promise((resolve, reject) => {\n      const joinMessage = {\n        type: 'join_channel',\n        channel_id: channelId\n      };\n\n      const timeout = setTimeout(() => {\n        reject(new Error('Channel join timeout'));\n      }, 10000);\n\n      const handleJoinResponse = (message: WebSocketMessage) => {\n        if (\n          message.type === 'channel_joined' &&\n          'channel_id' in message &&\n          message.channel_id === channelId\n        ) {\n          clearTimeout(timeout);\n          this.joinedChannels.add(channelId);\n          resolve();\n        } else if (message.type === 'error') {\n          clearTimeout(timeout);\n          reject(new Error(message.message));\n        }\n      };\n\n      this.onMessage('chat', handleJoinResponse);\n      this.chatSocket!.send(JSON.stringify(joinMessage));\n    });\n  }\n\n  // Leave a chat channel\n  public async leaveChannel(channelId: number): Promise<void> {\n    if (!this.chatSocket || this.chatSocket.readyState !== WebSocket.OPEN) {\n      return;\n    }\n\n    const leaveMessage = {\n      type: 'leave_channel',\n      channel_id: channelId\n    };\n\n    this.chatSocket.send(JSON.stringify(leaveMessage));\n    this.joinedChannels.delete(channelId);\n  }\n\n  // Send a chat message\n  public async sendMessage(channelId: number, content: string, parentId?: string): Promise<void> {\n    const message: ChatMessage = {\n      type: 'message',\n      channel_id: channelId,\n      content,\n      parent_id: parentId\n    };\n\n    const queueId = messageQueue.enqueue(message);\n\n    if (!this.chatSocket || this.chatSocket.readyState !== WebSocket.OPEN) {\n      try {\n        await this.connectChat();\n        await this.joinChannel(channelId);\n      } catch (error) {\n        console.error('[WebSocket] Failed to connect for message:', error);\n        return;\n      }\n    }\n\n    try {\n      messageQueue.markAttempted(queueId);\n      this.chatSocket!.send(JSON.stringify(message));\n    } catch (error) {\n      console.error('[WebSocket] Error sending message:', error);\n    }\n  }\n\n  // Update user status\n  public async updateStatus(status: 'online' | 'offline' | 'away' | 'busy'): Promise<void> {\n    if (!this.presenceSocket || this.presenceSocket.readyState !== WebSocket.OPEN) {\n      await this.connectPresence();\n    }\n\n    const statusMessage: StatusUpdateMessage = {\n      type: 'status_update',\n      status\n    };\n\n    this.presenceSocket!.send(JSON.stringify(statusMessage));\n  }\n\n  // Add message handler\n  public onMessage(type: string, handler: (message: WebSocketMessage) => void): () => void {\n    if (!this.messageHandlers.has(type)) {\n      this.messageHandlers.set(type, []);\n    }\n    this.messageHandlers.get(type)!.push(handler);\n    return () => this.offMessage(type, handler);\n  }\n\n  // Remove message handler\n  public offMessage(type: string, handler: (message: WebSocketMessage) => void): void {\n    if (!this.messageHandlers.has(type)) return;\n    this.messageHandlers.set(\n      type,\n      this.messageHandlers.get(type)!.filter(h => h !== handler)\n    );\n  }\n\n  // Add error handler\n  public onError(type: string, handler: (error: Error) => void): () => void {\n    if (!this.errorHandlers.has(type)) {\n      this.errorHandlers.set(type, []);\n    }\n    this.errorHandlers.get(type)!.push(handler);\n    return () => this.offError(type, handler);\n  }\n\n  // Remove error handler\n  public offError(type: string, handler: (error: Error) => void): void {\n    if (!this.errorHandlers.has(type)) return;\n    this.errorHandlers.set(\n      type,\n      this.errorHandlers.get(type)!.filter(h => h !== handler)\n    );\n  }\n\n  // Get connection state\n  public getConnectionState(type: string): WebSocketConnectionState {\n    const socket = type === 'chat' ? this.chatSocket : this.presenceSocket;\n    return (socket?.readyState ?? WebSocket.CLOSED) as WebSocketConnectionState;\n  }\n\n  // Cleanup connections\n  public cleanup(): void {\n    ['chat', 'presence'].forEach(type => {\n      const socket = type === 'chat' ? this.chatSocket : this.presenceSocket;\n      if (socket && socket.readyState === WebSocket.OPEN) {\n        socket.close(1000);\n      }\n      if (this.heartbeatIntervals.has(type)) {\n        clearInterval(this.heartbeatIntervals.get(type)!);\n      }\n    });\n\n    this.chatSocket = null;\n    this.presenceSocket = null;\n    this.joinedChannels.clear();\n    this.messageHandlers.clear();\n    this.errorHandlers.clear();\n    this.reconnectAttempts.clear();\n    this.heartbeatIntervals.clear();\n    this.lastHeartbeatResponses.clear();\n    this.isReconnecting.clear();\n  }\n}\n\n// Create and export singleton instance\nconst wsService = new WebSocketService();\nexport default wsService; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}