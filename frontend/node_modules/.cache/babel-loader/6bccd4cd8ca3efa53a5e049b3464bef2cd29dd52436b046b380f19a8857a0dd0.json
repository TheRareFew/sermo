{"ast":null,"code":"import { getAuthToken } from '../api/auth';\nclass WebSocketService {\n  constructor() {\n    this.socket = null;\n    this.messageHandlers = [];\n    this.errorHandlers = [];\n  }\n  connect() {\n    var _this$socket;\n    if (((_this$socket = this.socket) === null || _this$socket === void 0 ? void 0 : _this$socket.readyState) === WebSocket.OPEN) {\n      console.log('WebSocket already connected');\n      return;\n    }\n    const token = getAuthToken();\n    if (!token) {\n      console.error('No auth token available for WebSocket connection');\n      return;\n    }\n    const baseWsUrl = process.env.REACT_APP_WS_URL || 'ws://localhost:8000/ws/chat';\n    const wsUrl = `${baseWsUrl}?token=${token}`;\n    console.log('Connecting to WebSocket with URL:', wsUrl);\n    this.socket = new WebSocket(wsUrl);\n    this.socket.onopen = () => {\n      console.log('WebSocket connected');\n    };\n    this.socket.onmessage = event => {\n      try {\n        const message = JSON.parse(event.data);\n        console.log('WebSocket message received:', message);\n\n        // Handle error messages\n        if (message.type === 'error') {\n          console.error('WebSocket error message:', message);\n          this.errorHandlers.forEach(handler => handler({\n            code: message.code || 'UNKNOWN_ERROR',\n            message: message.content || 'Unknown error occurred'\n          }));\n          return;\n        }\n\n        // Handle channel access errors\n        if (message.type === 'channel_access_denied') {\n          console.error('Channel access denied:', message);\n          this.errorHandlers.forEach(handler => handler({\n            code: 'CHANNEL_ACCESS_DENIED',\n            message: message.content || 'Access to this channel was denied'\n          }));\n          return;\n        }\n\n        // Handle successful messages\n        this.messageHandlers.forEach(handler => handler(message));\n      } catch (error) {\n        console.error('Error parsing WebSocket message:', error);\n      }\n    };\n    this.socket.onerror = error => {\n      console.error('WebSocket error:', error);\n      this.errorHandlers.forEach(handler => handler({\n        code: 'WEBSOCKET_ERROR',\n        message: 'WebSocket connection error'\n      }));\n    };\n    this.socket.onclose = event => {\n      console.log('WebSocket disconnected with code:', event.code);\n      this.socket = null;\n\n      // Handle specific close codes\n      switch (event.code) {\n        case 1003:\n          // Unsupported\n          this.errorHandlers.forEach(handler => handler({\n            code: 'UNSUPPORTED',\n            message: 'WebSocket connection not supported'\n          }));\n          break;\n        case 4001:\n          // Channel access denied\n          this.errorHandlers.forEach(handler => handler({\n            code: 'CHANNEL_ACCESS_DENIED',\n            message: 'Access to the channel was denied'\n          }));\n          break;\n        case 4002:\n          // Authentication failed\n          this.errorHandlers.forEach(handler => handler({\n            code: 'AUTH_FAILED',\n            message: 'Authentication failed'\n          }));\n          break;\n        default:\n          // Try to reconnect for other close codes\n          setTimeout(() => {\n            console.log('Attempting to reconnect WebSocket...');\n            this.connect();\n          }, 5000);\n      }\n    };\n  }\n  disconnect() {\n    if (this.socket) {\n      this.socket.close();\n      this.socket = null;\n    }\n  }\n  sendMessage(channelId, content) {\n    var _this$socket2;\n    if (((_this$socket2 = this.socket) === null || _this$socket2 === void 0 ? void 0 : _this$socket2.readyState) === WebSocket.OPEN) {\n      const message = {\n        type: 'message',\n        channel_id: channelId,\n        content: content\n      };\n      this.socket.send(JSON.stringify(message));\n    } else {\n      console.error('WebSocket is not connected');\n      this.errorHandlers.forEach(handler => handler({\n        code: 'NOT_CONNECTED',\n        message: 'WebSocket is not connected'\n      }));\n    }\n  }\n  joinChannel(channelId) {\n    var _this$socket3;\n    if (((_this$socket3 = this.socket) === null || _this$socket3 === void 0 ? void 0 : _this$socket3.readyState) === WebSocket.OPEN) {\n      const message = {\n        type: 'join_channel',\n        channel_id: channelId\n      };\n      this.socket.send(JSON.stringify(message));\n    } else {\n      console.error('WebSocket is not connected');\n      this.errorHandlers.forEach(handler => handler({\n        code: 'NOT_CONNECTED',\n        message: 'WebSocket is not connected'\n      }));\n    }\n  }\n  leaveChannel(channelId) {\n    var _this$socket4;\n    if (((_this$socket4 = this.socket) === null || _this$socket4 === void 0 ? void 0 : _this$socket4.readyState) === WebSocket.OPEN) {\n      const message = {\n        type: 'leave_channel',\n        channel_id: channelId\n      };\n      this.socket.send(JSON.stringify(message));\n    } else {\n      console.error('WebSocket is not connected');\n      this.errorHandlers.forEach(handler => handler({\n        code: 'NOT_CONNECTED',\n        message: 'WebSocket is not connected'\n      }));\n    }\n  }\n  onMessage(handler) {\n    this.messageHandlers.push(handler);\n    return () => {\n      this.messageHandlers = this.messageHandlers.filter(h => h !== handler);\n    };\n  }\n  onError(handler) {\n    this.errorHandlers.push(handler);\n    return () => {\n      this.errorHandlers = this.errorHandlers.filter(h => h !== handler);\n    };\n  }\n  getChatSocketState() {\n    var _this$socket5;\n    return ((_this$socket5 = this.socket) === null || _this$socket5 === void 0 ? void 0 : _this$socket5.readyState) || WebSocket.CLOSED;\n  }\n}\nconst wsService = new WebSocketService();\nexport default wsService;","map":{"version":3,"names":["getAuthToken","WebSocketService","constructor","socket","messageHandlers","errorHandlers","connect","_this$socket","readyState","WebSocket","OPEN","console","log","token","error","baseWsUrl","process","env","REACT_APP_WS_URL","wsUrl","onopen","onmessage","event","message","JSON","parse","data","type","forEach","handler","code","content","onerror","onclose","setTimeout","disconnect","close","sendMessage","channelId","_this$socket2","channel_id","send","stringify","joinChannel","_this$socket3","leaveChannel","_this$socket4","onMessage","push","filter","h","onError","getChatSocketState","_this$socket5","CLOSED","wsService"],"sources":["Z:/GAUNTLET/projects/SERMO/sermo-app/frontend/src/services/websocket/index.ts"],"sourcesContent":["import { WebSocketMessage } from '../../types';\r\nimport { getAuthToken } from '../api/auth';\r\n\r\nclass WebSocketService {\r\n  private socket: WebSocket | null = null;\r\n  private messageHandlers: ((message: WebSocketMessage) => void)[] = [];\r\n  private errorHandlers: ((error: { code: string; message: string }) => void)[] = [];\r\n\r\n  connect() {\r\n    if (this.socket?.readyState === WebSocket.OPEN) {\r\n      console.log('WebSocket already connected');\r\n      return;\r\n    }\r\n\r\n    const token = getAuthToken();\r\n    if (!token) {\r\n      console.error('No auth token available for WebSocket connection');\r\n      return;\r\n    }\r\n\r\n    const baseWsUrl = process.env.REACT_APP_WS_URL || 'ws://localhost:8000/ws/chat';\r\n    const wsUrl = `${baseWsUrl}?token=${token}`;\r\n    console.log('Connecting to WebSocket with URL:', wsUrl);\r\n    \r\n    this.socket = new WebSocket(wsUrl);\r\n\r\n    this.socket.onopen = () => {\r\n      console.log('WebSocket connected');\r\n    };\r\n\r\n    this.socket.onmessage = (event) => {\r\n      try {\r\n        const message = JSON.parse(event.data) as WebSocketMessage;\r\n        console.log('WebSocket message received:', message);\r\n\r\n        // Handle error messages\r\n        if (message.type === 'error') {\r\n          console.error('WebSocket error message:', message);\r\n          this.errorHandlers.forEach(handler => handler({\r\n            code: message.code || 'UNKNOWN_ERROR',\r\n            message: message.content || 'Unknown error occurred'\r\n          }));\r\n          return;\r\n        }\r\n\r\n        // Handle channel access errors\r\n        if (message.type === 'channel_access_denied') {\r\n          console.error('Channel access denied:', message);\r\n          this.errorHandlers.forEach(handler => handler({\r\n            code: 'CHANNEL_ACCESS_DENIED',\r\n            message: message.content || 'Access to this channel was denied'\r\n          }));\r\n          return;\r\n        }\r\n\r\n        // Handle successful messages\r\n        this.messageHandlers.forEach(handler => handler(message));\r\n      } catch (error) {\r\n        console.error('Error parsing WebSocket message:', error);\r\n      }\r\n    };\r\n\r\n    this.socket.onerror = (error) => {\r\n      console.error('WebSocket error:', error);\r\n      this.errorHandlers.forEach(handler => handler({\r\n        code: 'WEBSOCKET_ERROR',\r\n        message: 'WebSocket connection error'\r\n      }));\r\n    };\r\n\r\n    this.socket.onclose = (event) => {\r\n      console.log('WebSocket disconnected with code:', event.code);\r\n      this.socket = null;\r\n\r\n      // Handle specific close codes\r\n      switch (event.code) {\r\n        case 1003: // Unsupported\r\n          this.errorHandlers.forEach(handler => handler({\r\n            code: 'UNSUPPORTED',\r\n            message: 'WebSocket connection not supported'\r\n          }));\r\n          break;\r\n        case 4001: // Channel access denied\r\n          this.errorHandlers.forEach(handler => handler({\r\n            code: 'CHANNEL_ACCESS_DENIED',\r\n            message: 'Access to the channel was denied'\r\n          }));\r\n          break;\r\n        case 4002: // Authentication failed\r\n          this.errorHandlers.forEach(handler => handler({\r\n            code: 'AUTH_FAILED',\r\n            message: 'Authentication failed'\r\n          }));\r\n          break;\r\n        default:\r\n          // Try to reconnect for other close codes\r\n          setTimeout(() => {\r\n            console.log('Attempting to reconnect WebSocket...');\r\n            this.connect();\r\n          }, 5000);\r\n      }\r\n    };\r\n  }\r\n\r\n  disconnect() {\r\n    if (this.socket) {\r\n      this.socket.close();\r\n      this.socket = null;\r\n    }\r\n  }\r\n\r\n  sendMessage(channelId: string, content: string) {\r\n    if (this.socket?.readyState === WebSocket.OPEN) {\r\n      const message = {\r\n        type: 'message',\r\n        channel_id: channelId,\r\n        content: content\r\n      };\r\n      this.socket.send(JSON.stringify(message));\r\n    } else {\r\n      console.error('WebSocket is not connected');\r\n      this.errorHandlers.forEach(handler => handler({\r\n        code: 'NOT_CONNECTED',\r\n        message: 'WebSocket is not connected'\r\n      }));\r\n    }\r\n  }\r\n\r\n  joinChannel(channelId: string) {\r\n    if (this.socket?.readyState === WebSocket.OPEN) {\r\n      const message = {\r\n        type: 'join_channel',\r\n        channel_id: channelId\r\n      };\r\n      this.socket.send(JSON.stringify(message));\r\n    } else {\r\n      console.error('WebSocket is not connected');\r\n      this.errorHandlers.forEach(handler => handler({\r\n        code: 'NOT_CONNECTED',\r\n        message: 'WebSocket is not connected'\r\n      }));\r\n    }\r\n  }\r\n\r\n  leaveChannel(channelId: string) {\r\n    if (this.socket?.readyState === WebSocket.OPEN) {\r\n      const message = {\r\n        type: 'leave_channel',\r\n        channel_id: channelId\r\n      };\r\n      this.socket.send(JSON.stringify(message));\r\n    } else {\r\n      console.error('WebSocket is not connected');\r\n      this.errorHandlers.forEach(handler => handler({\r\n        code: 'NOT_CONNECTED',\r\n        message: 'WebSocket is not connected'\r\n      }));\r\n    }\r\n  }\r\n\r\n  onMessage(handler: (message: WebSocketMessage) => void) {\r\n    this.messageHandlers.push(handler);\r\n    return () => {\r\n      this.messageHandlers = this.messageHandlers.filter(h => h !== handler);\r\n    };\r\n  }\r\n\r\n  onError(handler: (error: { code: string; message: string }) => void) {\r\n    this.errorHandlers.push(handler);\r\n    return () => {\r\n      this.errorHandlers = this.errorHandlers.filter(h => h !== handler);\r\n    };\r\n  }\r\n\r\n  getChatSocketState() {\r\n    return this.socket?.readyState || WebSocket.CLOSED;\r\n  }\r\n}\r\n\r\nconst wsService = new WebSocketService();\r\nexport default wsService; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}